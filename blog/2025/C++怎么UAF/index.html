<!DOCTYPE html> <html lang="cn"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> [水贴]C++应该怎么UAF | Leak Box 258 </title> <meta name="author" content="Leak Box 258"> <meta name="description" content="A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. "> <meta name="keywords" content="PL, Rust, C++, Linux"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" href="/assets/css/scholar-icons.css?62b2ac103a88034e6882a5be5f3e2772"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%99%BF%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://leakbox258.github.io/blog/2025/C++%E6%80%8E%E4%B9%88UAF/"> <script src="/assets/js/theme.js?a81d82887dd692e91686b43de4542f18"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>
    initTheme();
  </script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Leak</span> Box 258 </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">repositories </a> </li> <li class="nav-item "> <a class="nav-link" href="/books/">bookshelf </a> </li> <li class="nav-item dropdown "> <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">submenus </a> <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown"> <a class="dropdown-item " href="/books/">bookshelf</a> <div class="dropdown-divider"></div> <a class="dropdown-item " href="/blog/">blog</a> </div> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title">[水贴]C++应该怎么UAF</h1> <p class="post-meta"> Created on January 24, 2025 by 久菜合子 </p> <p class="post-tags"> <a href="/blog/2025"> <i class="fa-solid fa-calendar fa-sm"></i> 2025 </a>   ·   <a href="/blog/tag/pwn"> <i class="fa-solid fa-hashtag fa-sm"></i> pwn</a>   <a href="/blog/tag/%E6%B0%B4"> <i class="fa-solid fa-hashtag fa-sm"></i> 水</a> </p> </header> <article class="post-content"> <div id="markdown-content"> <p>ps1: UAF方法不全面, 没写不代表不能用或者没有<br> ps2: 尽量避免裸指针出现, 只在模拟漏洞(各种任意写)时使用裸指针达到目的, 也就是非必要不用<code class="language-plaintext highlighter-rouge">.get()</code></p> <h2 id="智能指针">智能指针</h2> <h5 id="智能指针是c的常用特性之一-用于解决c语言以及早期c中的内存分配和释放过于复杂-或者内存泄露的问题一般使用的智能指针有stdunique_ptr-stdshared_ptr-stdweak_ptr-stdweak_ptr可以看作是stdshared_ptr在特定情况下的补充-需要include-memory然而-即使有智能指针-也不能高枕无忧-因为内存问题是所有人都要面对的-除非你是高贵的数据分析科学家-或者你使用语言yuan神rust下面简单列一下本人发现的可以对智能指针uaf的方法">   智能指针是C++的常用特性之一, 用于解决C语言以及早期C++中的内存分配和释放过于复杂, 或者内存泄露的问题.<br>   一般使用的智能指针有<code class="language-plaintext highlighter-rouge">std::unique_ptr, std::shared_ptr, std::weak_ptr</code>, <code class="language-plaintext highlighter-rouge">std::weak_ptr</code>可以看作是<code class="language-plaintext highlighter-rouge">std::shared_ptr</code>在特定情况下的补充. 需要<code class="language-plaintext highlighter-rouge">#include &lt;memory&gt;</code>.<br>   然而, 即使有智能指针, 也不能高枕无忧, 因为内存问题是所有人都要面对的, 除非你是高贵的数据分析科学家, 或者你使用语言(yu’an)神Rust<br>   下面简单列一下本人发现的可以对智能指针UAF的方法.</h5> <h2 id="shared_ptr">shared_ptr</h2> <h3 id="内存回收方式"> 内存回收方式<br> </h3> <h5 id="shared_ptr是比较常用的智能指针-一块堆内存可以被多个若干个shared_ptr指向-这块内存会记录被指向的数目引用计数shared_count-当引用归零时-内存被释放-表面上看是这样的实际上stdmake_shared分配的内存有两个计数器-shared_count和weak_count各4字节-当然是为了配合weak_ptr使用">   <code class="language-plaintext highlighter-rouge">shared_ptr</code>是比较常用的智能指针, 一块堆内存可以被多个若干个<code class="language-plaintext highlighter-rouge">shared_ptr</code>指向, 这块内存会记录被指向的数目(引用计数shared_count), 当引用归零时, 内存被释放. 表面上看是这样的.<br>   实际上<code class="language-plaintext highlighter-rouge">std::make_shared&lt;&gt;</code>分配的内存有两个计数器, <code class="language-plaintext highlighter-rouge">shared_count和weak_count</code>(各4字节), 当然是为了配合<code class="language-plaintext highlighter-rouge">weak_ptr</code>使用<br> </h5> <h5 id="那么shared_ptr在内存中是什么样的的组织方式-下面一个demo">   那么<code class="language-plaintext highlighter-rouge">shared_ptr</code>在内存中是什么样的的组织方式, 下面一个demo</h5> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">ptr1</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="mh">0x12345678</span><span class="p">);</span>
        <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">ptr2</span> <span class="o">=</span> <span class="n">ptr1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><img src="https://www.helloimg.com/i/2025/01/24/6793ad0a07ea8.png" alt="Screenshot 2025-01-24 231137.png"></p> <h5 id="上图是ptr2--ptr1之后的栈空间">   上图是<code class="language-plaintext highlighter-rouge">ptr2 = ptr1</code>之后的栈空间</h5> <h5 id="可以看到其实比较简单-shared_ptr对象本身是-地址指针--一个虚表指针">   可以看到其实比较简单, <code class="language-plaintext highlighter-rouge">shared_ptr</code>对象本身是 <code class="language-plaintext highlighter-rouge">地址(指针) + 一个虚表指针</code> </h5> <p><img src="https://www.helloimg.com/i/2025/01/24/6793ae2a45c2a.png" alt="Screenshot 2025-01-24 231631.png"></p> <h5 id="上述指针即get获取的裸指针指向的一个chunk的中间部分-对象的位置-前面的是0x555555557cc8虚表地址-和0x1weak_count-0x2shared_countuse-count值得一提的是weak_count返回的是0-但实际上在内存中存的是1-在之后提到的weak_count指的是内存中的weak_count">   上述指针(即<code class="language-plaintext highlighter-rouge">.get()</code>获取的裸指针)指向的一个<code class="language-plaintext highlighter-rouge">chunk</code>的中间部分, 对象的位置. 前面的是<code class="language-plaintext highlighter-rouge">0x555555557cc8</code>虚表地址, 和<code class="language-plaintext highlighter-rouge">0x1</code>weak_count, <code class="language-plaintext highlighter-rouge">0x2</code>shared_count(use count).<br>   值得一提的是weak_count返回的是0, 但实际上在内存中存的是1, 在之后提到的weak_count指的是内存中的weak_count</h5> <h5 id="作用域结束之后-分别对两个stdshared_ptr对象进行析构">   作用域结束之后, 分别对两个<code class="language-plaintext highlighter-rouge">std::shared_ptr</code>对象进行析构<br> </h5> <h5 id="第一个析构之后-堆肯定是没有释放的-但是use-count变成了0x1">   第一个析构之后, 堆肯定是没有释放的, 但是use count变成了<code class="language-plaintext highlighter-rouge">0x1</code><br> </h5> <h5 id="然后追踪一下第二个析构">   然后追踪一下第二个析构</h5> <p><img src="https://www.helloimg.com/i/2025/01/24/6793b05b77e6a.png" alt="Screenshot 2025-01-24 213734.png"></p> <h5 id="注意下面的调用栈-现在在_m_release中">   注意下面的调用栈, 现在在<code class="language-plaintext highlighter-rouge">_M_release()</code>中<br> </h5> <h5 id="movabs这一句-0x100000001直接硬编码在指令里-看来是有bear而来">   <code class="language-plaintext highlighter-rouge">movabs</code>这一句, 0x100000001直接硬编码在指令里, 看来是有bear而来<br> </h5> <h5 id="cmp-rax里是堆块中use-count--weak-count的那一个字长的拷贝-这里就是比较此时是不是两个count都只剩1了-也就是该堆块只有当前正在析构的指针还在引用-如果是的话-zf标志位为1">   <code class="language-plaintext highlighter-rouge">cmp</code>, <code class="language-plaintext highlighter-rouge">rax</code>里是堆块中<code class="language-plaintext highlighter-rouge">use count + weak count</code>的那一个字长的拷贝. 这里就是比较此时是不是两个<code class="language-plaintext highlighter-rouge">count</code>都只剩1了, 也就是该堆块只有当前正在析构的指针还在引用, 如果是的话, ZF标志位为1<br> </h5> <h5 id="sete-al-当equalzf为1时-al被设置为1-反之为0">   <code class="language-plaintext highlighter-rouge">sete al</code>, 当equal(ZF为1)时, al被设置为1, 反之为0<br> </h5> <h5 id="test-al-al-经典按位与用来判断是不是0-结果不是0-zf变成0">   <code class="language-plaintext highlighter-rouge">test al, al</code>, 经典按位与用来判断是不是0, 结果不是0, ZF变成0</h5> <h5 id="je--此时不跳转-进入下面的堆块释放环节">   <code class="language-plaintext highlighter-rouge">je ...</code>, 此时不跳转, 进入下面的堆块释放环节.</h5> <h5 id="释放的环节调用了两个方法-_m_dispose-和_m_destroy-但是在这之前-use-count和weak-count被清零了-如下图">   释放的环节调用了两个方法, <code class="language-plaintext highlighter-rouge">_M_dispose</code>, 和<code class="language-plaintext highlighter-rouge">_M_destroy</code>, 但是在这之前, <code class="language-plaintext highlighter-rouge">use count</code>和<code class="language-plaintext highlighter-rouge">weak count</code>被清零了, 如下图</h5> <p><img src="https://www.helloimg.com/i/2025/01/24/6793b4c72b804.png" alt="Screenshot 2025-01-24 214047.png"></p> <h5 id="然后分别call了_m_dispose-和_m_destroy">   然后分别<code class="language-plaintext highlighter-rouge">call</code>了<code class="language-plaintext highlighter-rouge">_M_dispose</code>, 和<code class="language-plaintext highlighter-rouge">_M_destroy</code> </h5> <p><img src="https://www.helloimg.com/i/2025/01/24/6793b574dd8dd.png" alt="Screenshot 2025-01-24 221428.png"> <img src="https://www.helloimg.com/i/2025/01/24/6793b5a67c6ff.png" alt="Screenshot 2025-01-24 215026.png"></p> <h5 id="在_m_destory中-在__allocator_ptr-之后堆块释放-更细节的调用没再追踪了">   在<code class="language-plaintext highlighter-rouge">_M_destory</code>中, 在<code class="language-plaintext highlighter-rouge">~__allocator_ptr</code>, 之后堆块释放. 更细节的调用没再追踪了</h5> <p><img src="https://www.helloimg.com/i/2025/01/24/6793b6565a060.png" alt="Screenshot 2025-01-24 221129.png"></p> <h5 id="如果两个count不是1-会进入下面的分支">   如果两个<code class="language-plaintext highlighter-rouge">count</code>不是1, 会进入下面的分支</h5> <p><img src="https://www.helloimg.com/i/2025/01/24/6793b6d9c1d7e.png" alt="Screenshot 2025-01-24 220024.png"></p> <h3 id="shared_ptr的uaf"> shared_ptr的UAF</h3> <h5 id="根据上面的分析-得知两点">   根据上面的分析, 得知两点<br> </h5> <h5 id="第一-必须要让use-count和weak-count都是1-才能触发堆块释放的操作">   第一, 必须要让<code class="language-plaintext highlighter-rouge">use count</code>和<code class="language-plaintext highlighter-rouge">weak count</code>都是1, 才能触发堆块释放的操作<br> </h5> <h5 id="第二-想要让一个堆块释放-应该先进入一个shared_ptr的析构函数-毕竟没人会在用了智能指针之后还手动delete">   第二, 想要让一个堆块释放, 应该先进入一个<code class="language-plaintext highlighter-rouge">shared_ptr</code>的析构函数, 毕竟没人会在用了智能指针之后还手动delete.<br> </h5> <h5 id="如此-一个简单的uaf思路产生了-利用程序漏洞篡改两个count都是1-然后触发析构-如果此时还有别的shared_ptr没析构-那么就成功uaf了-不过需要注意的是-因为chunk内成员的排布中-虚表和两个count在指针获得的空间的低位-如果想要改这两个成员-可能需要借助别的漏洞">   如此, 一个简单的UAF思路产生了, 利用程序漏洞篡改两个<code class="language-plaintext highlighter-rouge">count</code>都是1, 然后触发析构, 如果此时还有别的<code class="language-plaintext highlighter-rouge">shared_ptr</code>没析构, 那么就成功UAF了, 不过需要注意的是, 因为<code class="language-plaintext highlighter-rouge">chunk</code>内成员的排布中, 虚表和两个<code class="language-plaintext highlighter-rouge">count</code>在指针获得的空间的低位. 如果想要改这两个成员, 可能需要借助别的漏洞.</h5> <h5 id="看另一个demo">   看另一个demo</h5> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    
    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="mh">0x12345678</span><span class="p">);</span>
    
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">ptr1</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">;</span>
        <span class="c1">// change use count: 2 -&gt; 1</span>
        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">use_count</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="p">)((</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)(</span><span class="n">ptr1</span><span class="p">.</span><span class="n">get</span><span class="p">())</span> <span class="o">-</span> <span class="mi">8</span><span class="p">);</span>
        <span class="o">*</span><span class="n">use_count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="c1">// 生命周期结束, ptr1析构, 同时触发ptr和ptr1指向的堆块free</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">ptr_new</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">114514</span><span class="p">);</span>

    <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="mi">1919810</span><span class="p">;</span> <span class="c1">// UAF</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">ptr_new</span> <span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
     
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></div></div> <h5 id="uaf大成功-没用的知识又增加了">   UAF大成功, 没用的知识又增加了</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ g++ test.cpp -g -o test
$ ./test 
1919810
</code></pre></div></div> <h2 id="weak_ptr">weak_ptr</h2> <h3 id="内存回收方式-1"> 内存回收方式</h3> <h5 id="首先了解一下weak_ptr的使用场景-就是为了避免shared_ptr之间的循环引用">   首先了解一下<code class="language-plaintext highlighter-rouge">weak_ptr</code>的使用场景, 就是为了避免<code class="language-plaintext highlighter-rouge">shared_ptr</code>`之间的循环引用.</h5> <h5 id="先看一个没有循环引用的demo-结构体wrapper有一个成员ptr">   先看一个没有循环引用的demo, 结构体wrapper有一个成员ptr.</h5> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span>
<span class="k">struct</span> <span class="nc">wrapper</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">wrapper</span><span class="o">&gt;</span> <span class="n">ptr</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    
    <span class="p">{</span>
        <span class="c1">///@note wrapprx 应该叫做 wrapperx_ptr 才符合语义, 但是图都截了...</span>
        <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">wrapper</span><span class="o">&gt;</span> <span class="n">wrapper1</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">wrapper</span><span class="o">&gt;</span><span class="p">();</span>
        <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">wrapper</span><span class="o">&gt;</span> <span class="n">wrapper2</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">wrapper</span><span class="o">&gt;</span><span class="p">();</span>
        <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">wrapper</span><span class="o">&gt;</span> <span class="n">wrapper3</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">wrapper</span><span class="o">&gt;</span><span class="p">();</span>
        <span class="n">wrapper1</span><span class="o">-&gt;</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">wrapper2</span><span class="p">;</span>
        <span class="n">wrapper2</span><span class="o">-&gt;</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">wrapper3</span><span class="p">;</span>
        <span class="n">wrapper3</span><span class="o">-&gt;</span><span class="n">ptr</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><img src="https://www.helloimg.com/i/2025/01/25/679500556e25c.png" alt="Screenshot 2025-01-25 232012.png"></p> <h5 id="如图-在wrapper3析构之后-对应的内存没有free-事实上-在wrapper1之后-三个chunk才会一起释放-但这个过程中-三个wrapper指向的内存的引用计数在正确地减少">   如图, 在wrapper3析构之后, 对应的内存没有free. 事实上, 在wrapper1之后, 三个chunk才会一起释放. 但这个过程中, 三个wrapper指向的内存的引用计数在正确地减少.</h5> <h5 id="ps-作用域结束时-析构的顺序是构造的顺序是相反的-v12是赋值是产生的copy-可以不管">   ps: 作用域结束时, 析构的顺序是构造的顺序是相反的, v12是赋值是产生的copy, 可以不管</h5> <p><img src="https://www.helloimg.com/i/2025/01/25/67950718340db.png" alt="Screenshot 2025-01-25 234952.png"></p> <h5 id="stdshared_ptrwrappershared_ptrwrapper1析构wrapper1时-析构了wrapper1-ptr-wrapper1-ptr指针析构时又其指向的对象wrapper2-wrapper2析构时-需要析构wrapper2-ptr-析构wrapper2-ptr是析构了指向的对象wrapper3">   <code class="language-plaintext highlighter-rouge">std::shared_ptr&lt;wrapper&gt;::~shared_ptr(wrapper1);</code>析构<code class="language-plaintext highlighter-rouge">wrapper1</code>时, 析构了<code class="language-plaintext highlighter-rouge">wrapper1-&gt;ptr</code>, <code class="language-plaintext highlighter-rouge">wrapper1-&gt;ptr</code>指针析构时又其指向的对象(wrapper2), <code class="language-plaintext highlighter-rouge">wrapper2</code>析构时, 需要析构<code class="language-plaintext highlighter-rouge">wrapper2-&gt;ptr</code>, 析构<code class="language-plaintext highlighter-rouge">wrapper2-&gt;ptr</code>是析构了指向的对象<code class="language-plaintext highlighter-rouge">*wrapper3</code><br> </h5> <h5 id="wrapper3的chunk释放之后-调用栈回溯-逐个又free其他chunk">   <code class="language-plaintext highlighter-rouge">*wrapper3</code>的chunk释放之后, 调用栈回溯, 逐个又free其他chunk<br> </h5> <h5 id="如果说话的方式简单点-就是析构智能指针就会析构所指向的对象-析构所指向的对象就会该对象使用的智能指针">   如果说话的方式简单点, 就是析构智能指针就会析构所指向的对象, 析构所指向的对象就会该对象使用的智能指针.<br> </h5> <h5 id="在这个过程中-三块内存保存的use_count">   在这个过程中, 三块内存保存的use_count</h5> <table> <thead> <tr> <th style="text-align: center">析构状态</th> <th style="text-align: center">chunk1</th> <th style="text-align: center">chunk2</th> <th style="text-align: center">chunk3</th> </tr> </thead> <tbody> <tr> <td style="text-align: center">没析构</td> <td style="text-align: center">1</td> <td style="text-align: center">2</td> <td style="text-align: center">2</td> </tr> <tr> <td style="text-align: center">wrapper3析构</td> <td style="text-align: center">1</td> <td style="text-align: center">2</td> <td style="text-align: center">1</td> </tr> <tr> <td style="text-align: center">wrapper2析构</td> <td style="text-align: center">1</td> <td style="text-align: center">1</td> <td style="text-align: center">1</td> </tr> <tr> <td style="text-align: center">wrapper1析构</td> <td style="text-align: center">free</td> <td style="text-align: center">free</td> <td style="text-align: center">free</td> </tr> </tbody> </table> <h5 id="进入正题-有循环引用的demo">   进入正题, 有循环引用的demo</h5> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span>
<span class="k">struct</span> <span class="nc">wrapper</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">wrapper</span><span class="o">&gt;</span> <span class="n">ptr</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">wrapper</span><span class="o">&gt;</span> <span class="n">wrapper1</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">wrapper</span><span class="o">&gt;</span><span class="p">();</span>
        <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">wrapper</span><span class="o">&gt;</span> <span class="n">wrapper2</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">wrapper</span><span class="o">&gt;</span><span class="p">();</span>
        <span class="n">wrapper2</span><span class="o">-&gt;</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">wrapper1</span><span class="p">;</span>
        <span class="n">wrapper1</span><span class="o">-&gt;</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">wrapper2</span><span class="p">;</span> <span class="c1">// 构成循环引用</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><img src="https://www.helloimg.com/i/2025/01/25/6794f93b7560c.png" alt="Screenshot 2025-01-25 224711.png"></p> <h5 id="如图-当作用域结束之后-两块wrapper的内存都没有释放">   如图, 当作用域结束之后, 两块wrapper的内存都没有释放<br> </h5> <h5 id="简单概括一下-智能指针wrapper1析构时-会析构wrapper对象存在第一个chunk里-然后析构ptr成员-析构wrapper存在第二个chunk里-然后又ptr成员-最后回去析构存在第一个chunk里的wrapper-成功转了个圈">   简单概括一下, 智能指针<code class="language-plaintext highlighter-rouge">wrapper1</code>析构时, 会析构<code class="language-plaintext highlighter-rouge">wrapper</code>对象(存在第一个chunk里), 然后析构<code class="language-plaintext highlighter-rouge">ptr</code>成员, 析构<code class="language-plaintext highlighter-rouge">wrapper</code>(存在第二个chunk里), 然后又<code class="language-plaintext highlighter-rouge">ptr</code>成员, 最后回去析构存在第一个chunk里的<code class="language-plaintext highlighter-rouge">wrapper</code>, 成功转了个圈<br> </h5> <h5 id="析构函数应该有什么检查机制可能是检查地址-因为这个循环递归地析构函数调用并不会卡死程序-但是确实会让引用计数无法正确减少-一直都是2-对应的两个chunk永远无法free-变成僵尸内存">   析构函数应该有什么检查机制(可能是检查地址), 因为这个循环递归地析构函数调用并不会卡死程序, 但是确实会让引用计数无法正确减少, 一直都是2, 对应的两个chunk永远无法free, 变成僵尸内存.<br> </h5> <h5 id="打破循环引用的方法之一是将任意一边的指针换成weak_ptr-这样堆块里use_count不增加-取而代之的是weak_count的增加">   打破循环引用的方法之一是将任意一边的指针换成<code class="language-plaintext highlighter-rouge">weak_ptr</code>, 这样堆块里use_count不增加, 取而代之的是weak_count的增加</h5> <h5 id="weak_ptr有几个比较常用的方法">   <code class="language-plaintext highlighter-rouge">weak_ptr</code>有几个比较常用的方法:<br> </h5> <h5 id="1-expired-返回bool值-表示对应的内存是否销毁销毁不等于内存释放">   1. <code class="language-plaintext highlighter-rouge">.expired()</code>, 返回bool值, 表示对应的内存是否销毁(销毁不等于内存释放)<br> </h5> <h5 id="2-lock-返回一个和weak_ptr指向同样内存的shared_ptr-如果已被销毁-将返回一个nullptr">   2. <code class="language-plaintext highlighter-rouge">.lock()</code>, 返回一个和<code class="language-plaintext highlighter-rouge">weak_ptr</code>指向同样内存的<code class="language-plaintext highlighter-rouge">shared_ptr</code>, 如果已被销毁, 将返回一个nullptr<br> </h5> <h5 id="3-use_count-返回内存的引用计数">   3. <code class="language-plaintext highlighter-rouge">.use_count()</code>, 返回内存的引用计数<br> </h5> <h5 id="上述三个特性是相关联的-引用计数为0时-显示已经销毁expired-lock返回nullptr">   上述三个特性是相关联的, 引用计数为0时, 显示已经销毁(expired), <code class="language-plaintext highlighter-rouge">.lock()</code>返回nullptr.<br> </h5> <h5 id="然后关于weak_ptr造成对应内存释放的问题-举个例子">   然后关于<code class="language-plaintext highlighter-rouge">weak_ptr</code>造成对应内存释放的问题, 举个例子</h5> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">weak_ptr</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">weak_ptr</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="mh">0x12345678</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h5 id="作用域结束时-weak_count和use_count为0x0000000100000000-weak_ptr析构时-顺带释放了对应的chunk">   作用域结束时, <code class="language-plaintext highlighter-rouge">weak_count</code>和<code class="language-plaintext highlighter-rouge">use_count</code>为<code class="language-plaintext highlighter-rouge">0x0000000100000000</code>, <code class="language-plaintext highlighter-rouge">weak_ptr</code>析构时, 顺带释放了对应的<code class="language-plaintext highlighter-rouge">chunk</code><br> </h5> <h3 id="利用方式"> 利用方式</h3> <h5 id="方法基本同shared_ptr-但是需要注意weak_ptr必须依赖于一个shared_ptr否则weak_count为0-表示销毁-lock返回nullptr-无法取用该内存-除此之外和上述share_ptr应该一致">   方法基本同<code class="language-plaintext highlighter-rouge">shared_ptr</code>, 但是需要注意<code class="language-plaintext highlighter-rouge">weak_ptr</code>必须依赖于一个<code class="language-plaintext highlighter-rouge">shared_ptr</code>(否则weak_count为0, 表示销毁, <code class="language-plaintext highlighter-rouge">.lock()</code>返回nullptr, 无法取用该内存), 除此之外和上述<code class="language-plaintext highlighter-rouge">share_ptr</code>应该一致</h5> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="mh">0x123456789</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">weak_ptr</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">weak_ptr</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">;</span>

    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">ptr1</span> <span class="o">=</span> <span class="n">weak_ptr</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="o">*</span><span class="n">counts</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)((</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)(</span><span class="n">ptr</span><span class="p">.</span><span class="n">get</span><span class="p">())</span> <span class="o">-</span> <span class="mi">8</span><span class="p">);</span>
        <span class="o">*</span><span class="n">counts</span> <span class="o">=</span> <span class="mh">0x100000001</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">ptr2</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">114514</span><span class="p">);</span>
    
    <span class="o">*</span><span class="p">(</span><span class="n">weak_ptr</span><span class="p">.</span><span class="n">lock</span><span class="p">())</span> <span class="o">=</span> <span class="mi">1919810</span><span class="p">;</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;*</span><span class="n">ptr2</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ g++ test.cpp -g -o test
$ ./test
1919810
</code></pre></div></div> <h5 id="或者反过来-利用weak_ptr的析构导致chunk被提前释放">   或者反过来, 利用<code class="language-plaintext highlighter-rouge">weak_ptr</code>的析构导致<code class="language-plaintext highlighter-rouge">chunk</code>被提前释放<br> </h5> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>

    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="mh">0x12345678</span><span class="p">);</span>

    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">weak_ptr</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">weak_ptr</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="o">*</span><span class="n">counts</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span>
                <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)(</span><span class="n">weak_ptr</span><span class="p">.</span><span class="n">lock</span><span class="p">().</span><span class="n">get</span><span class="p">())</span> <span class="o">-</span> <span class="mi">8</span><span class="p">);</span>
        <span class="o">*</span><span class="n">counts</span> <span class="o">=</span> <span class="mh">0x100000000</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">ptr2</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">114514</span><span class="p">);</span>

    <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="mi">1919810</span><span class="p">;</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">ptr2</span> <span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h5 id="效果上是一致的">   效果上是一致的</h5> <h2 id="unique_ptr">unique_ptr</h2> <h3 id="内存回收方式-2"> 内存回收方式</h3> <h5 id="unique_ptr是独占内存的智能指针-一下是几个常用的用法">   <code class="language-plaintext highlighter-rouge">unique_ptr</code>是独占内存的智能指针, 一下是几个常用的用法<br> </h5> <h5 id="1-构造时用stdmake_uniquet或者stdunique_ptrt-ptrnew-t">   1. 构造时用<code class="language-plaintext highlighter-rouge">std::make_unique&lt;T&gt;(...)</code>或者<code class="language-plaintext highlighter-rouge">std::unique_ptr&lt;T&gt; ptr(new T(...))</code><br> </h5> <h5 id="2-unique_ptr之间赋值时需要使用转移语义stdmove-否则编译不通过">   2. <code class="language-plaintext highlighter-rouge">unique_ptr</code>之间赋值时需要使用转移语义<code class="language-plaintext highlighter-rouge">std::move(...)</code>, 否则编译不通过<br> </h5> <h5 id="3-t-raw_ptr--ptrrelease-release方法解除unique_ptr对一个chunk的绑定变成nullptr-并且会返回对应的裸指针">   3. <code class="language-plaintext highlighter-rouge">T* raw_ptr = ptr.release()</code>, <code class="language-plaintext highlighter-rouge">.release()</code>方法解除<code class="language-plaintext highlighter-rouge">unique_ptr</code>对一个<code class="language-plaintext highlighter-rouge">chunk</code>的绑定(变成nullptr), 并且会返回对应的裸指针.<br> </h5> <h5 id="4-ptrreset-如果ptr不是nullptr-那么会解除绑定并且释放内存-如果ptr是nullptr-则无事发生">   4. <code class="language-plaintext highlighter-rouge">ptr.reset()</code>, 如果<code class="language-plaintext highlighter-rouge">ptr</code>不是nullptr, 那么会解除绑定并且释放内存; 如果ptr是nullptr, 则无事发生<br> </h5> <h5 id="5-ptrreset-接受一个对应类型的裸指针-在4的基础上-将unique_ptr绑定到新的内存上">   5. <code class="language-plaintext highlighter-rouge">ptr.reset(...)</code>, 接受一个对应类型的裸指针, 在<code class="language-plaintext highlighter-rouge">4</code>的基础上, 将<code class="language-plaintext highlighter-rouge">unique_ptr</code>绑定到新的内存上</h5> <h5 id="然后是内存布局">   然后是内存布局</h5> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="mh">0x12345678</span><span class="p">);</span>
</code></pre></div></div> <p><img src="https://www.helloimg.com/i/2025/02/06/67a4a7c1dba9b.png" alt="Screenshot 2025-02-06 201603.png"></p> <h5 id="上图是chunk内的结构-和裸指针一致-也就是说篡改内存导致uaf不可能了-unique_ptr的创建和析构完全是编译器在编译期自动确定的">   上图是<code class="language-plaintext highlighter-rouge">chunk</code>内的结构, 和裸指针一致, 也就是说篡改内存导致UAF不可能了, <code class="language-plaintext highlighter-rouge">unique_ptr</code>的创建和析构完全是编译器在编译期自动确定的.<br> </h5> <h5 id="但是unique_ptr和shared_ptr或者weak_ptr不同在于-后两者对于chunk的释放包含在对智能指针的析构中-要没一起没-而unique_ptr绑定的内存可以在unique_ptr析构前释放-即调用reset">   但是<code class="language-plaintext highlighter-rouge">unique_ptr</code>和<code class="language-plaintext highlighter-rouge">shared_ptr</code>或者<code class="language-plaintext highlighter-rouge">weak_ptr</code>不同在于, 后两者对于<code class="language-plaintext highlighter-rouge">chunk</code>的释放包含在对智能指针的析构中, 要没一起没; 而<code class="language-plaintext highlighter-rouge">unique_ptr</code>绑定的内存可以在<code class="language-plaintext highlighter-rouge">unique_ptr</code>析构前释放, 即调用<code class="language-plaintext highlighter-rouge">.reset()</code><br> </h5> <h5 id="更重要的是-没人会手动调用shared_ptr或者weak_ptr的析构函数-但是unique_ptr的reset却有可能被使用">   更重要的是, 没人会手动调用<code class="language-plaintext highlighter-rouge">shared_ptr</code>或者<code class="language-plaintext highlighter-rouge">weak_ptr</code>的析构函数, 但是<code class="language-plaintext highlighter-rouge">unique_ptr</code>的<code class="language-plaintext highlighter-rouge">.reset()</code>却有可能被使用.<br> </h5> <h5 id="所以-充分考虑开发场景的需要以及开发者可能的失误-可能会有以下的demo出现">   所以, 充分考虑开发场景的需要以及开发者可能的失误, 可能会有以下的demo出现<br> </h5> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>    
    <span class="kt">size_t</span> <span class="o">*</span><span class="n">raw_ptr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">size_t</span><span class="p">(</span><span class="mh">0x12345678</span><span class="p">);</span>

    <span class="c1">// 出于某些原因, 两个智能指针指向了同一个chunk</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">ptr1</span><span class="p">(</span><span class="n">raw_ptr</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">ptr2</span><span class="p">(</span><span class="n">raw_ptr</span><span class="p">);</span>

    <span class="c1">// 以及出于另外的某些原因, 其中一个先于另一个调用了.reset()</span>
    <span class="n">ptr1</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span>

    <span class="c1">// 此时就有了UAF</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">ptr_new</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">114514</span><span class="p">);</span>
    <span class="o">*</span><span class="n">ptr2</span> <span class="o">=</span> <span class="mi">1919810</span><span class="p">;</span>
    
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;*</span><span class="n">ptr_new</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    
    <span class="c1">// 另外, 在此之后, ptr2和ptr_new都需要析构, 会造成double free</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h5 id="结果打印">   结果打印</h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ./test
1919810
free(): double free detected in tcache 2
[1]    65769 IOT instruction (core dumped)  ./test
</code></pre></div></div> <h2 id="比较和综合利用">比较和综合利用</h2> <h5 id="由于shared_ptr或者weak_ptr绑定的内存布局的设计-导致虚表和两个count在get或者operator取得的裸指针的低位-实际上是不容易被篡改的-所以shared_ptr或者weak_ptr的uaf需要比较严重的漏洞-这导致之前篡改两个count时显得非常刻意-取了裸指针-还用了强制类型转换和负偏移">   由于<code class="language-plaintext highlighter-rouge">shared_ptr</code>或者<code class="language-plaintext highlighter-rouge">weak_ptr</code>绑定的内存布局的设计, 导致虚表和两个count在<code class="language-plaintext highlighter-rouge">.get()</code>或者<code class="language-plaintext highlighter-rouge">operator*()</code>取得的裸指针的低位, 实际上是不容易被篡改的 ,所以<code class="language-plaintext highlighter-rouge">shared_ptr</code>或者<code class="language-plaintext highlighter-rouge">weak_ptr</code>的UAF需要比较严重的漏洞, 这导致之前篡改两个count时显得非常刻意: 取了裸指针, 还用了强制类型转换和负偏移.<br> </h5> <h5 id="而此处unique_ptr的漏洞-就是说unique_ptr对象和内存依然没有一一对应-分配的内存先于智能指针对象出现-导致它被多个指针持有-概括性的总结-就是没有从头到尾使用智能指针管理内存-以及裸指针使用不当导致的">   而此处<code class="language-plaintext highlighter-rouge">unique_ptr</code>的漏洞, 就是说<code class="language-plaintext highlighter-rouge">unique_ptr</code>对象和内存依然没有一一对应, 分配的内存先于智能指针对象出现, 导致它被多个指针持有. 概括性的总结, 就是没有从头到尾使用智能指针管理内存, 以及裸指针使用不当导致的<br> </h5> <h5 id="相较而言-后者漏洞更容易出现-尤其是在某些裸指针和智能指针并存的情况之下">   相较而言, 后者漏洞更容易出现, 尤其是在某些裸指针和智能指针并存的情况之下<br> </h5> <h5 id="其次-这里示例的unique_ptr的uaf实际上更加类似于c中的uaf">   其次, 这里示例的<code class="language-plaintext highlighter-rouge">unique_ptr</code>的UAF实际上更加类似于C中的UAF.</h5> <h5 id="前面提到shared_ptr和weak_ptr其实只能修改一个chunk的一部分-chunk释放之后的fd或bk将无法修改仅有uaf时">   前面提到<code class="language-plaintext highlighter-rouge">shared_ptr</code>和<code class="language-plaintext highlighter-rouge">weak_ptr</code>其实只能修改一个<code class="language-plaintext highlighter-rouge">chunk</code>的一部分, <code class="language-plaintext highlighter-rouge">chunk</code>释放之后的<code class="language-plaintext highlighter-rouge">fd</code>或<code class="language-plaintext highlighter-rouge">bk</code>将无法修改(仅有UAF时)<br> </h5> <h5 id="而unique_ptr的uaf可以修改chunk中所有的内容-结合另外两种智能指针-一方面可以用于篡改两个counts-另一方面能够劫持虚表感觉这个更有用">   而<code class="language-plaintext highlighter-rouge">unique_ptr</code>的UAF可以修改<code class="language-plaintext highlighter-rouge">chunk</code>中所有的内容, 结合另外两种智能指针, 一方面可以用于篡改两个counts, 另一方面能够劫持虚表(感觉这个更有用)<br> </h5> <h5 id="下面是第一个demo-用unique_ptr的uaf改shared空间的counts导致chunk提前释放-得到shared_ptr的uaf">   下面是第一个demo, 用<code class="language-plaintext highlighter-rouge">unique_ptr</code>的UAF改shared空间的counts导致<code class="language-plaintext highlighter-rouge">chunk</code>提前释放, 得到<code class="language-plaintext highlighter-rouge">shared_ptr</code>的UAF</h5> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span>
<span class="k">struct</span> <span class="nc">TQWord</span><span class="p">{</span>
    <span class="kt">size_t</span> <span class="n">QWord_1</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">QWord_2</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">QWord_3</span><span class="p">;</span>
    
    <span class="n">TQWord</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">_a</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">_b</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">_c</span><span class="p">)</span><span class="o">:</span> <span class="n">QWord_1</span><span class="p">(</span><span class="n">_a</span><span class="p">),</span> <span class="n">QWord_2</span><span class="p">(</span><span class="n">_b</span><span class="p">),</span> <span class="n">QWord_3</span><span class="p">(</span><span class="n">_c</span><span class="p">){}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>    
    <span class="n">TQWord</span> <span class="o">*</span><span class="n">raw_ptr</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TQWord</span><span class="p">({</span><span class="mh">0x12345678</span><span class="p">,</span> <span class="mh">0x87654321</span><span class="p">,</span> <span class="mh">0xffffffff</span><span class="p">});</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">TQWord</span><span class="o">&gt;</span> <span class="n">unique_ptr_1</span><span class="p">(</span><span class="n">raw_ptr</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">TQWord</span><span class="o">&gt;</span> <span class="n">unique_ptr_2</span><span class="p">(</span><span class="n">raw_ptr</span><span class="p">);</span>

    <span class="n">unique_ptr_1</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span>

    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">shared_ptr</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">114514</span><span class="p">);</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">weak_ptr</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">weak_ptr</span> <span class="o">=</span> <span class="n">shared_ptr</span><span class="p">;</span>
        <span class="n">unique_ptr_2</span><span class="o">-&gt;</span><span class="n">QWord_2</span> <span class="o">=</span> <span class="mh">0x100000000</span><span class="p">;</span> <span class="c1">// UAF</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">TQWord</span><span class="o">&gt;</span> <span class="n">unique_ptr_new</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">TQWord</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">114</span><span class="p">,</span> <span class="mi">514</span><span class="p">,</span> <span class="mi">1919810</span><span class="p">);</span>
    <span class="o">*</span><span class="n">shared_ptr</span> <span class="o">=</span> <span class="mi">114514</span><span class="p">;</span> <span class="c1">// UAF</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">unique_ptr_new</span><span class="o">-&gt;</span><span class="n">QWord_3</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h5 id="结果当然是不出意外地打印了1919810">   结果当然是不出意外地打印了<code class="language-plaintext highlighter-rouge">1919810</code><br> </h5> <h5 id="第二个-unique_ptr的uaf劫持shared_ptr的虚表-执行system">   第二个, <code class="language-plaintext highlighter-rouge">unique_ptr</code>的UAF劫持<code class="language-plaintext highlighter-rouge">shared_ptr</code>的虚表, 执行<code class="language-plaintext highlighter-rouge">system(...)</code><br> </h5> <h5 id="劫持之前-来点分析-一个demo的demo-这里编译时-no-pie便于调试">   劫持之前, 来点分析, 一个demo的demo, 这里编译时<code class="language-plaintext highlighter-rouge">-no-pie</code>便于调试<br> </h5> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="mh">0x12345678</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h5 id="shared_ptr的虚表在0x403d38-有5个函数指针">   <code class="language-plaintext highlighter-rouge">shared_ptr</code>的虚表在<code class="language-plaintext highlighter-rouge">0x403d38</code>, 有5个函数指针</h5> <p><img src="https://www.helloimg.com/i/2025/02/06/67a4d4f168d32.png" alt="Screenshot 2025-02-06 233307.png"></p> <h5 id="可以去搞清楚它们各自是干什么的-但这里我选择直接打5个断点-挨个看rdi">   可以去搞清楚它们各自是干什么的, 但这里我选择直接打5个断点, 挨个看<code class="language-plaintext highlighter-rouge">rdi</code><br> </h5> <p><img src="https://www.helloimg.com/i/2025/02/06/67a4d6bed1e0a.png" alt="Screenshot 2025-02-06 233813.png"></p> <h5 id="到达第一处中断-是虚表的第三个指针_m_dispose-rdi是虚表指针堆上那个-大致这样式的">   到达第一处中断, 是虚表的第三个指针<code class="language-plaintext highlighter-rouge">::_M_dispose()</code>, <code class="language-plaintext highlighter-rouge">rdi</code>是虚表指针(堆上那个), 大致这样式的<br> </h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*RDI  0x4172b0 —▸ 0x403d38 (vtable for std::_Sp_counted_ptr_inplace&lt;unsigned long, std::allocator&lt;void&gt;, (__gnu_cxx::_Lock_policy)2&gt;+16) —▸ 0x401c7e (std::_Sp_counted_ptr_inplace&lt;unsigned long, std::allocator&lt;void&gt;, (__gnu_cxx::_Lock_policy)2&gt;::~_Sp_counted_ptr_inplace()) ◂— endbr64
</code></pre></div></div> <h5 id="与此同时-frame-5是main71-如下图-说明现在在析构中-构造函数似乎没用到虚表函数">   与此同时, <code class="language-plaintext highlighter-rouge">frame 5</code>是<code class="language-plaintext highlighter-rouge">main+71</code>, 如下图, 说明现在在析构中, 构造函数似乎没用到虚表函数<br> </h5> <p><img src="https://www.helloimg.com/i/2025/02/06/67a4d7bba731d.png" alt="Screenshot 2025-02-06 234119.png"></p> <h5 id="到这里就够了-可以申请一个3--8的空间-第一个字长填上binshx00或者别的什么指令的地址-第三个字长填后门函数或者直接是system的地址">   到这里就够了, 可以申请一个<code class="language-plaintext highlighter-rouge">3 * 8</code>的空间, 第一个字长填上<code class="language-plaintext highlighter-rouge">/bin/sh\x00</code>或者别的什么指令的地址, 第三个字长填后门函数或者直接是<code class="language-plaintext highlighter-rouge">system()</code>的地址<br> </h5> <h5 id="demo登场">   demo登场</h5> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span>
<span class="k">struct</span> <span class="nc">TQWord</span><span class="p">{</span>
    <span class="kt">size_t</span> <span class="n">QWord_1</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">QWord_2</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">QWord_3</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">unreachable</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">**</span> <span class="n">command</span><span class="p">){</span>
    <span class="n">system</span><span class="p">(</span><span class="o">*</span><span class="n">command</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">size_t</span> <span class="n">cmd</span> <span class="o">=</span> <span class="mh">0x0068732f6e69622f</span><span class="p">;</span> <span class="c1">// b"/bin/sh"</span>

<span class="n">TQWord</span> <span class="n">fakeVtable</span><span class="p">{</span><span class="n">cmd</span><span class="p">,</span> <span class="mh">0xdeadbeef</span><span class="p">,</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="o">&amp;</span><span class="n">unreachable</span><span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>    
    <span class="n">TQWord</span> <span class="o">*</span><span class="n">raw_ptr</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TQWord</span><span class="p">{</span><span class="mi">114</span><span class="p">,</span> <span class="mi">514</span><span class="p">,</span> <span class="mi">1919810</span><span class="p">};</span>

    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">TQWord</span><span class="o">&gt;</span> <span class="n">unique_ptr_1</span><span class="p">(</span><span class="n">raw_ptr</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">TQWord</span><span class="o">&gt;</span> <span class="n">unique_ptr_2</span><span class="p">(</span><span class="n">raw_ptr</span><span class="p">);</span>

    <span class="n">unique_ptr_1</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span>

    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">shared_ptr</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1919810</span><span class="p">);</span>
    <span class="n">unique_ptr_2</span><span class="o">-&gt;</span><span class="n">QWord_1</span> <span class="o">=</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="o">&amp;</span><span class="n">fakeVtable</span><span class="p">;</span>
    
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><img src="https://www.helloimg.com/i/2025/02/07/67a4e27910ad2.png" alt="Screenshot 2025-02-07 003143.png"></p> <h5 id="这么个写法还是美中不足-虚表函数的第一个参数rdi都是虚表指针或者说地址-导致按照上述的写法-传给unreachable是cmd-需要一次解引用">   这么个写法还是美中不足, 虚表函数的第一个参数(<code class="language-plaintext highlighter-rouge">rdi</code>)都是虚表指针(或者说地址), 导致按照上述的写法, 传给<code class="language-plaintext highlighter-rouge">unreachable</code>是<code class="language-plaintext highlighter-rouge">&amp;&amp;cmd</code>, 需要一次解引用<br> </h5> <h5 id="但是话又说回来-如果虚表地址填上cmd-确实不用解引用-但是没法虚表劫持了">   但是话又说回来, 如果虚表地址填上<code class="language-plaintext highlighter-rouge">cmd</code>, 确实不用解引用, 但是没法虚表劫持了<br> </h5> <h5 id="于是想到不用system-可以发现rsi指向的是shared_ptr指向的数据区域-这一部分是可控的">   于是想到不用<code class="language-plaintext highlighter-rouge">system()</code>, 可以发现<code class="language-plaintext highlighter-rouge">rsi</code>指向的是<code class="language-plaintext highlighter-rouge">shared_ptr</code>指向的数据区域, 这一部分是可控的</h5> <p><img src="https://www.helloimg.com/i/2025/02/07/67a5b70cb4242.png" alt="Screenshot 2025-02-07 120625.png"></p> <h5 id="于是-想到把数据改成binshx00-这样就有一个const-char的参数-然后后门函数方面选择posix_spawn-下面是参数表-可以看到它的第二个参数是path">   于是, 想到把数据改成<code class="language-plaintext highlighter-rouge">/bin/sh\x00</code>, 这样就有一个<code class="language-plaintext highlighter-rouge">const char*</code>的参数, 然后后门函数方面选择<code class="language-plaintext highlighter-rouge">posix_spawn</code>, 下面是参数表, 可以看到它的第二个参数是<code class="language-plaintext highlighter-rouge">path</code> </h5> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">posix_spawn</span><span class="p">(</span><span class="n">pid_t</span> <span class="o">*</span><span class="k">restrict</span> <span class="n">pid</span><span class="p">,</span> 
                <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="k">restrict</span> <span class="n">path</span><span class="p">,</span>
                <span class="k">const</span> <span class="n">posix_spawn_file_actions_t</span> <span class="o">*</span><span class="n">file_actions</span><span class="p">,</span>
                <span class="k">const</span> <span class="n">posix_spawnattr_t</span> <span class="o">*</span><span class="k">restrict</span> <span class="n">attrp</span><span class="p">,</span>
                <span class="kt">char</span> <span class="o">*</span><span class="k">const</span> <span class="n">argv</span><span class="p">[</span><span class="k">restrict</span><span class="p">],</span> <span class="kt">char</span> <span class="o">*</span><span class="k">const</span> <span class="n">envp</span><span class="p">[</span><span class="k">restrict</span><span class="p">]);</span>
</code></pre></div></div> <h5 id="但是还是有问题-函数本身对file_actions有检查-rdx为nullptr可以绕过检查-但调用这几个虚表函数时rdx都不是nullptr-出现以下perror">   但是还是有问题, 函数本身对<code class="language-plaintext highlighter-rouge">file_actions</code>有检查, <code class="language-plaintext highlighter-rouge">rdx</code>为nullptr可以绕过检查, 但调用这几个虚表函数时<code class="language-plaintext highlighter-rouge">rdx</code>都不是nullptr, 出现以下<code class="language-plaintext highlighter-rouge">perror</code> </h5> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>posix_spawn failed: Bad file descriptor
</code></pre></div></div> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="https://blog.google/technology/ai/google-gemini-update-flash-ai-assistant-io-2024/" target="_blank" rel="external nofollow noopener">Google Gemini updates: Flash 1.5, Gemma 2 and Project Astra</a> <svg width="1rem" height="1rem" viewbox="0 0 30 30" xmlns="http://www.w3.org/2000/svg"> <path d="M17 13.5v6H5v-12h6m3-3h6v6m0-6-9 9" class="icon_svg-stroke" stroke="#999" stroke-width="1.5" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path> </svg> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="https://medium.com/@al-folio/displaying-external-posts-on-your-al-folio-blog-b60a1d241a0a?source=rss-17feae71c3c4------2" target="_blank" rel="external nofollow noopener">Displaying External Posts on Your al-folio Blog</a> <svg width="1rem" height="1rem" viewbox="0 0 30 30" xmlns="http://www.w3.org/2000/svg"> <path d="M17 13.5v6H5v-12h6m3-3h6v6m0-6-9 9" class="icon_svg-stroke" stroke="#999" stroke-width="1.5" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path> </svg> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/ONNX-0/">ONNX-opt 0</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%8F%8A%E8%B0%83%E8%AF%95/">内核模块开发环境及调试</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/largebin-attack-%E4%BB%A5%E5%8F%8A-IO%E6%B5%81%E7%9A%84%E5%88%A9%E7%94%A8(%E4%B8%80)/">large bin attack及house of cat</a> </li> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2025 Leak Box 258. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js?a0db7e5d5c70cc3252b3138b0c91dcaf" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?c8a01c11a92744d44b093fc3bda915df" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script src="/assets/js/mathjax-setup.js?a5bb4e6a542c546dd929b24b8b236dfd"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script defer src="/assets/js/progress-bar.js?2f30e0e6801ea8f5036fa66e1ab0a71a" type="text/javascript"></script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>
    addBackToTop();
  </script> <script type="module" src="/assets/js/search/ninja-keys.min.js?a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script src="/assets/js/search-setup.js?6c304f7b1992d4b60f7a07956e52f04a"></script> <script src="/assets/js/search-data.js"></script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> </body> </html>