<!DOCTYPE html> <html lang="cn"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> 矩阵并行计算的探索---大作业 | Leak Box 258 </title> <meta name="author" content="Leak Box 258"> <meta name="description" content="A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. "> <meta name="keywords" content="PL, Rust, C++, Linux"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" href="/assets/css/scholar-icons.css?62b2ac103a88034e6882a5be5f3e2772"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%99%BF%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://leakbox258.github.io/blog/2024/%E7%9F%A9%E9%98%B5%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97%E7%9A%84%E6%8E%A2%E7%B4%A2/"> <script src="/assets/js/theme.js?a81d82887dd692e91686b43de4542f18"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>
    initTheme();
  </script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Leak</span> Box 258 </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">repositories </a> </li> <li class="nav-item "> <a class="nav-link" href="/books/">bookshelf </a> </li> <li class="nav-item dropdown "> <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">submenus </a> <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown"> <a class="dropdown-item " href="/books/">bookshelf</a> <div class="dropdown-divider"></div> <a class="dropdown-item " href="/blog/">blog</a> </div> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title">矩阵并行计算的探索---大作业</h1> <p class="post-meta"> Created on November 15, 2024 by 久菜合子 </p> <p class="post-tags"> <a href="/blog/2024"> <i class="fa-solid fa-calendar fa-sm"></i> 2024 </a>   ·   <a href="/blog/tag/dev"> <i class="fa-solid fa-hashtag fa-sm"></i> dev</a> </p> </header> <article class="post-content"> <div id="markdown-content"> <p>ps: 课题来自于泥卓的课后作业 ps: 建议把页面markdown自己放到vscode或者typora上, 因为本站的markdown似乎没有办法显示Latex语法</p> <h3 id="实验器材与工具">实验器材与工具</h3> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>处理器：13th Gen Intel(R) Core(TM) i7-13700H   2.40 GHz
机带RAM: 16.0GB(15.7GB可用)
WSL 版本： 2.3.24.0
内核版本： 5.15.153.1-2
WSLg 版本： 1.0.65
MSRDC 版本： 1.2.5620
Direct3D 版本： 1.611.1-81528511
DXCore 版本： 10.0.26100.1-240331-1435.ge-release
Windows 版本： 10.0.22631.4317
g++ 版本：11.4.0
nvidia-cuda-toolkit: 12.3
</code></pre></div></div> <h3 id="矩阵乘法优化算法">矩阵乘法优化算法</h3> <h5 id="存在矩阵mmn和矩阵nnt做矩阵乘法按照矩阵乘法的定义一共需要做mnt次乘法计算以及mnt次加法计算不难理解如果可以减少运算的次数那么就会产生直观的优化效果">   存在矩阵M(m*n)和矩阵N(n*t)做矩阵乘法，按照矩阵乘法的定义，一共需要做m*n*t次乘法计算，以及m*n*t次加法计算，不难理解如果可以减少运算的次数，那么就会产生直观的优化效果</h5> <h5 id="strassen算法">Strassen算法<br> </h5> <h5 id="由上述分析一般的矩阵运算需要on3的复杂度但strassen算法通过分治的思想将大矩阵化成小矩阵-可以将这个值降至约on281">   由上述分析，一般的矩阵运算需要O(n\^3)的复杂度，但Strassen算法通过分治的思想，将大矩阵化成小矩阵, 可以将这个值降至约O(n\^2.81)<br> </h5> <h5 id="如图将两个44矩阵分割为四个分块矩阵">   如图，将两个4*4矩阵分割为四个分块矩阵，</h5> <p>$ A = \begin{bmatrix} \begin{pmatrix}a_{11}&amp;a_{12}\a_{21}&amp;a_{22}\end{pmatrix} &amp; \begin{pmatrix}a_{31}&amp;a_{32}\a_{41}&amp;a_{42}\end{pmatrix}<br> \begin{pmatrix}a_{51}&amp;a_{52}\a_{61}&amp;a_{62}\end{pmatrix} &amp; \begin{pmatrix}a_{71}&amp;a_{72}\a_{81}&amp;a_{82}\end{pmatrix} \end{bmatrix} = \begin{bmatrix}A_1 &amp; A_2 \ A_3 &amp; A_4\end{bmatrix} <br> B = \begin{bmatrix} \begin{pmatrix}b_{11}&amp;b_{12}\b_{21}&amp;b_{22}\end{pmatrix} &amp; \begin{pmatrix}b_{31}&amp;b_{32}\b_{41}&amp;b_{42}\end{pmatrix}<br> \begin{pmatrix}b_{51}&amp;b_{52}\b_{61}&amp;b_{62}\end{pmatrix} &amp; \begin{pmatrix}b_{71}&amp;b_{72}\b_{81}&amp;b_{82}\end{pmatrix} \end{bmatrix} = \begin{bmatrix}B_1 &amp; B_2 \ B_3 &amp; B_4\end{bmatrix} $</p> <h5 id="此时c_11和矩阵c的计算方式如下">   此时，$C_{11}$和矩阵$C$的计算方式如下</h5> <p>$ C_{11} = \left(\begin{pmatrix}a_{11}&amp;a_{12}\a_{21}&amp;a_{22}\end{pmatrix}\begin{pmatrix}b_{11}&amp;b_{12}\b_{21}&amp;b_{22}\end{pmatrix}\right)+\left(\begin{pmatrix}a_{31}&amp;a_{32}\a_{41}&amp;a_{42}\end{pmatrix}\begin{pmatrix}b_{51}&amp;b_{52}\b_{61}&amp;b_{62}\end{pmatrix}\right) $ $ C = \begin{bmatrix} C_{11} &amp; C_{12}<br> C_{21} &amp; C_{22} \end{bmatrix} $</p> <h5 id="用这种方式计算时时间代价来自两部分多次子矩阵乘法以及运算结果合并与组合">   用这种方式计算时，时间代价来自两部分，多次子矩阵乘法，以及运算结果合并与组合</h5> <p>$T(n) = k*T(n/2) + O(n^2), k代表矩阵乘法次数$</p> <h5 id="上式中的后项表示加法和合并的时间复杂度由于矩阵乘法本身为on3而前项的乘法是主要的时间开销所以化简的一种方式是尽可能减少乘法次数">   上式中的后项表示加法和合并的时间复杂度，由于矩阵乘法本身为$O(n^3)$，而前项的乘法是主要的时间开销。所以化简的一种方式是尽可能减少乘法次数</h5> <h5 id="以上面的a-b为例">   以上面的$A, B$为例</h5> <h5 id="首先先通过加减获得10个-22-矩阵如下">   首先先通过加减获得10个 2*2 矩阵如下</h5> <p>$ S_1 = B_{12} - B_{22}<br> S_2 = A_{11} + A_{12}<br> S_3 = A_{21} + A_{22}<br> S_4 = B_{21} - B_{11}<br> S_5 = A_{11} + A_{22}<br> S_6 = B_{11} + B_{22}<br> S_7 = A_{12} - A_{22}<br> S_8 = B_{21} + B_{22}<br> S_9 = A_{11} - A_{21}<br> S_{10} = B_{11} + B_{12} $</p> <h5 id="然后再进一步通过乘法运算得到">   然后再进一步通过乘法运算得到</h5> <p>$ P_{1} =A_{11}\cdot S_{1}=A_{11}\cdot B_{12}-A_{11}\cdot B_{22}<br> P_{2} =S_{2}\cdot B_{22}=A_{11}\cdot B_{22}+A_{12}\cdot B_{22}<br> P_{3} =S_{3}\cdot B_{11}=A_{21}\cdot B_{11}+A_{22}\cdot B_{11}<br> P_{4} =A_{22}\cdot S_{4}=A_{22}\cdot B_{21}-A_{22}\cdot B_{11}<br> P_{5} =S_{5}\cdot S_{6}=A_{11}\cdot B_{11}+A_{11}\cdot B_{22}+A_{22}\cdot B_{11}+A_{22}\cdot B_{22}<br> P_{6} =S_{7}\cdot S_{8}=A_{12}\cdot B_{21}+A_{12}\cdot B_{22}-A_{22}\cdot B_{21}-A_{22}\cdot B_{22}<br> P_{7} =S_{9}\cdot S_{10}=A_{11}\cdot B_{11}+A_{11}\cdot B_{12}-A_{21}\cdot B_{11}-A_{21}\cdot B_{12} $</p> <h5 id="根据组合可以发现c实际上可以由上述计算的结果加减得到">   根据组合，可以发现$C$实际上可以由上述计算的结果加减得到</h5> <p>$ C_{11} = P_5 + P_4 - P_2 + P_6 <br> C_{12} = P_1 + P_2 <br> C_{21} = P_3 + P_4 <br> C_{22} = P_5 + P_1 - P_3 - P_7 $</p> <h5 id="上述方法总共有7次-22-的矩阵乘法比直接计算少一次这是因为最后一次乘法的结果实际上可以由之前7次加减组合得到对于较大的矩阵乘法使用分治的方法递归的化为更小的矩阵相乘可以在递归的过程中多次减少所需乘法的数量对于本例时间复杂度为onlog_27">   上述方法总共有7次 2*2 的矩阵乘法，比直接计算少一次,这是因为最后一次乘法的结果实际上可以由之前7次加减组合得到。对于较大的矩阵乘法，使用分治的方法递归的化为更小的矩阵相乘，可以在递归的过程中多次减少所需乘法的数量<br>   对于本例，时间复杂度为$O(n^{log_27})$</h5> <h5 id="更具体方式参考httpszhuanlanzhihucomp78657463-">   更具体方式参考https://zhuanlan.zhihu.com/p/78657463 <br> </h5> <h5 id="进一步的使用coppersmith-winograd可以将复杂度降至on2376">   进一步的，使用Coppersmith-Winograd可以将复杂度降至$O(n^{2.376})$<br> </h5> <h3 id="进程级别并行">进程级别并行</h3> <h4 id="cannon卡农算法">Cannon卡农算法</h4> <h5 id="假如可以将不同的c_ij的计算划给不同的进程分别计算最后组合拼接以获得的最终的矩阵c在这个过程中单独的一个进程将会需要a_i1-a_i2-a_i3b_1j-b_2j-b_3j等多个子矩阵来计算c_ij但是由于每个进程需要获取的子矩阵中存在重叠也就是一个子矩阵会被复制进入多个进程不利于节省空间开支在使用卡农算法时使每个进程只保存当前进程的计算结果以及两个子矩阵在各个进程完成了一轮计算后通过进程间的通信进程之间交换子矩阵以达到避免重复保存的效果">   假如可以将不同的$C_{ij}$的计算划给不同的进程分别计算，最后组合拼接以获得的最终的矩阵$C$.<br>   在这个过程中，单独的一个进程将会需要$A_{i1}, A_{i2}, A_{i3}…B_{1j}, B_{2j}, B_{3j}…$等多个子矩阵来计算$C_{ij}$，但是由于每个进程需要获取的子矩阵中存在重叠，也就是一个子矩阵会被复制进入多个进程，不利于节省空间开支。<br>   在使用卡农算法时，使每个进程只保存当前进程的计算结果、以及两个子矩阵，在各个进程完成了一轮计算后，通过进程间的通信，进程之间交换子矩阵，以达到避免重复保存的效果。</h5> <h5 id="例如存在方阵annbnn相乘得到矩阵c第一步将矩阵各分为sqrtn--sqrtn向下取整个子矩阵并将运算任务分配至n个线程-对应计算c_ij的进程中需要保存的子矩阵是a_ij-b_ij第二步进行子矩阵的对齐操作以计算c_ij的线程为例通过进程间通信使得a_ij在整个a中循环左移i位得到a_ij-i-1sqrtnsqrtn同理b_ij向上循环右移j位">   例如存在方阵A(n*n)，B(n*n)相乘得到矩阵C.<br>   第一步，将矩阵各分为$\sqrt{n} * \sqrt{n}$（向下取整）个子矩阵，并将运算任务分配至$n$个线程, 对应计算$C_{ij}$的进程中需要保存的子矩阵是$A_{ij}, B_{ij}$<br>   第二步，进行子矩阵的对齐操作。以计算$C_{ij}$的线程为例，通过进程间通信，使得$A_{ij}$在整个$A$中循环左移i位，得到$A_{i((j-i-1+\sqrt{n})\%\sqrt{n})}$，同理$B_{ij}$向上循环右移j位.</h5> <p><img src="https://www.helloimg.com/i/2024/11/10/67305d00b2eee.png" alt="697687-20190318173518810-1350254261.png"></p> <h5 id="第三步各个进程执行一次矩阵乘法累加到c_ij然后将a_ij和b_ij分别向左向上移动一步-重复第三步直到一共计算sqrtn次乘法">   第三步，各个进程执行一次矩阵乘法，累加到$C_{ij}$，然后将$A_{ij}$和$B_{ij}$分别向左向上移动一步<br>    重复第三步，直到一共计算$\sqrt{n}$次乘法</h5> <h5 id="第五步将各个进程的结果组合得到矩阵乘法结果">   第五步，将各个进程的结果组合得到矩阵乘法结果.</h5> <h5 id="在这种方法中除了乘法运算之外进程之间的通讯也会影响运算速度">   在这种方法中，除了乘法运算之外，进程之间的通讯也会影响运算速度，</h5> <h4 id="分布式并行">分布式并行</h4> <h5 id="分布式并行计算是指将一个大型的计算任务分解成多个较小的子任务这些子任务被分配到多个计算节点如服务器处理器等上同时进行计算这些节点通过网络进行通信和协调最终将各个子任务的计算结果汇总得到整个任务的解决方案mpi是这种分布式并行的一种实现方式mpi是一套在进程间传输数据的接口-现有的mpi实现有mpich-openmpi-intel-mpi根据进程之间通信方式不同mpi的具体操作方式可以分为主从模式和对等模式以下是一个使用mpich基于主从模式的cannon算法的实现">   分布式并行计算是指将一个大型的计算任务分解成多个较小的子任务，这些子任务被分配到多个计算节点（如服务器、处理器等）上同时进行计算。这些节点通过网络进行通信和协调，最终将各个子任务的计算结果汇总，得到整个任务的解决方案<br>   MPI是这种分布式并行的一种实现方式，MPI是一套在进程间传输数据的接口, 现有的MPI实现有<code class="language-plaintext highlighter-rouge">MPICH, openMPI, Intel MPI</code><br>   根据进程之间通信方式不同，MPI的具体操作方式可以分为主从模式和对等模式，以下是一个使用MPICH基于主从模式的Cannon算法的实现。</h5> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">"/usr/include/mpi/mpi.h"</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;math.h&gt;</span><span class="cp">
</span> 
<span class="kt">int</span> <span class="nf">get_index</span><span class="p">(</span><span class="kt">int</span> <span class="n">row</span><span class="p">,</span><span class="kt">int</span> <span class="n">col</span><span class="p">,</span><span class="kt">int</span> <span class="n">N</span><span class="p">){</span>
   <span class="k">return</span> <span class="p">((</span><span class="n">row</span><span class="o">+</span><span class="n">N</span><span class="p">)</span><span class="o">%</span><span class="n">N</span><span class="p">)</span><span class="o">*</span><span class="n">N</span><span class="o">+</span><span class="p">(</span><span class="n">col</span><span class="o">+</span><span class="n">N</span><span class="p">)</span><span class="o">%</span><span class="n">N</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
   <span class="kt">int</span> <span class="n">M</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span><span class="n">N</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span><span class="n">K</span><span class="o">=</span><span class="mi">4</span><span class="p">;</span>
   <span class="kt">int</span> <span class="n">rank</span><span class="p">,</span><span class="n">comm_sz</span><span class="p">;</span>
   <span class="kt">double</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">;</span> <span class="c1">//计时时间</span>
   <span class="n">MPI_Status</span> <span class="n">status</span><span class="p">;</span>
 
   <span class="n">MPI_Init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">argc</span><span class="p">,</span><span class="o">&amp;</span><span class="n">argv</span><span class="p">);</span>
   <span class="n">MPI_Comm_size</span><span class="p">(</span><span class="n">MPI_COMM_WORLD</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">comm_sz</span><span class="p">);</span>
   <span class="n">MPI_Comm_rank</span><span class="p">(</span><span class="n">MPI_COMM_WORLD</span><span class="p">,</span><span class="o">&amp;</span><span class="n">rank</span><span class="p">);</span>
 
   <span class="kt">int</span> <span class="n">a</span><span class="o">=</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">sqrt</span><span class="p">(</span><span class="n">comm_sz</span><span class="p">);</span> <span class="c1">// A B行列分多少块</span>
 
   <span class="kt">int</span> <span class="n">saveM</span><span class="o">=</span><span class="n">M</span><span class="p">,</span><span class="n">saveN</span><span class="o">=</span><span class="n">N</span><span class="p">,</span><span class="n">saveK</span><span class="o">=</span><span class="n">K</span><span class="p">;</span> <span class="c1">// 为了A B能均分成块</span>

   <span class="kt">int</span> <span class="n">each_M</span><span class="o">=</span><span class="n">M</span><span class="o">/</span><span class="n">a</span><span class="p">,</span><span class="n">each_N</span><span class="o">=</span><span class="n">N</span><span class="o">/</span><span class="n">a</span><span class="p">,</span><span class="n">each_K</span><span class="o">=</span><span class="n">K</span><span class="o">/</span><span class="n">a</span><span class="p">;</span> <span class="c1">// 矩阵A B每块分多少行列数据</span>
 
   <span class="k">if</span><span class="p">(</span><span class="n">rank</span><span class="o">==</span><span class="mi">0</span><span class="p">){</span>
      <span class="kt">double</span> <span class="o">*</span><span class="n">Matrix_A</span><span class="p">,</span><span class="o">*</span><span class="n">Matrix_B</span><span class="p">,</span><span class="o">*</span><span class="n">Matrix_C</span><span class="p">,</span><span class="o">*</span><span class="n">result_Matrix</span><span class="p">;</span>
      <span class="n">Matrix_A</span><span class="o">=</span><span class="p">(</span><span class="kt">double</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">M</span><span class="o">*</span><span class="n">N</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">));</span>
      <span class="n">Matrix_B</span><span class="o">=</span><span class="p">(</span><span class="kt">double</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">N</span><span class="o">*</span><span class="n">K</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">));</span>
      <span class="n">Matrix_C</span><span class="o">=</span><span class="p">(</span><span class="kt">double</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">M</span><span class="o">*</span><span class="n">K</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">));</span>
      <span class="n">result_Matrix</span><span class="o">=</span><span class="p">(</span><span class="kt">double</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">M</span><span class="o">*</span><span class="n">K</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">));</span> <span class="c1">// 保存数据计算结果</span>
 
      <span class="n">init_Matrix</span><span class="p">(</span><span class="n">Matrix_A</span><span class="p">,</span><span class="n">Matrix_B</span><span class="p">,</span><span class="n">Matrix_C</span><span class="p">,</span><span class="n">M</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">K</span><span class="p">,</span><span class="n">saveM</span><span class="p">,</span><span class="n">saveN</span><span class="p">,</span><span class="n">saveK</span><span class="p">);</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">"a=%d each_M=%d each_N=%d each_K=%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">each_M</span><span class="p">,</span><span class="n">each_N</span><span class="p">,</span><span class="n">each_K</span><span class="p">);</span>
 
      <span class="n">start</span><span class="o">=</span><span class="n">MPI_Wtime</span><span class="p">();</span>
      <span class="c1">// 主进程计算第1块</span>
      <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">each_M</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
         <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">each_K</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">){</span>
            <span class="kt">double</span> <span class="n">temp</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">p</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">p</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span><span class="n">p</span><span class="o">++</span><span class="p">){</span>
               <span class="n">temp</span><span class="o">+=</span><span class="n">Matrix_A</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="n">N</span><span class="o">+</span><span class="n">p</span><span class="p">]</span><span class="o">*</span><span class="n">Matrix_B</span><span class="p">[</span><span class="n">p</span><span class="o">*</span><span class="n">K</span><span class="o">+</span><span class="n">j</span><span class="p">];</span>
            <span class="p">}</span>
            <span class="n">result_Matrix</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="n">K</span><span class="o">+</span><span class="n">j</span><span class="p">]</span><span class="o">=</span> <span class="n">temp</span><span class="o">+</span> <span class="n">Matrix_C</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="n">K</span><span class="o">+</span><span class="n">j</span><span class="p">];</span>
         <span class="p">}</span>
      <span class="p">}</span>
 
      <span class="c1">// 向其它进程发送块数据</span>
      <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">comm_sz</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
         <span class="kt">int</span> <span class="n">beginRow</span><span class="o">=</span><span class="p">(</span><span class="n">i</span><span class="o">/</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="n">each_M</span><span class="p">;</span> <span class="c1">// 每个块的行列起始位置(坐标/偏移量)</span>
         <span class="kt">int</span> <span class="n">beginCol</span><span class="o">=</span><span class="p">(</span><span class="n">i</span><span class="o">%</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="n">each_K</span><span class="p">;</span>
         <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">each_M</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span>
            <span class="n">MPI_Send</span><span class="p">(</span><span class="n">Matrix_C</span><span class="o">+</span><span class="p">(</span><span class="n">beginRow</span><span class="o">+</span><span class="n">j</span><span class="p">)</span><span class="o">*</span><span class="n">K</span><span class="o">+</span><span class="n">beginCol</span><span class="p">,</span><span class="n">each_K</span><span class="p">,</span><span class="n">MPI_DOUBLE</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="n">each_M</span><span class="o">+</span><span class="n">each_N</span><span class="p">,</span><span class="n">MPI_COMM_WORLD</span><span class="p">);</span>
         <span class="c1">// 发送A B每块数据</span>
         <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">k</span><span class="o">&lt;</span><span class="n">a</span><span class="p">;</span><span class="n">k</span><span class="o">++</span><span class="p">){</span>
            <span class="kt">int</span> <span class="n">begin_part</span><span class="o">=</span><span class="n">k</span><span class="o">*</span><span class="n">each_N</span><span class="p">;</span> <span class="c1">// 移动A的列 B的行 即A列不同程度的左移，B行不同程度的上移</span>
            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">each_M</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span>
               <span class="n">MPI_Send</span><span class="p">(</span><span class="n">Matrix_A</span><span class="o">+</span><span class="p">(</span><span class="n">beginRow</span><span class="o">+</span><span class="n">j</span><span class="p">)</span><span class="o">*</span><span class="n">N</span><span class="o">+</span><span class="n">begin_part</span><span class="p">,</span><span class="n">each_N</span><span class="p">,</span><span class="n">MPI_DOUBLE</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">MPI_COMM_WORLD</span><span class="p">);</span>
            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">p</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">p</span><span class="o">&lt;</span><span class="n">each_N</span><span class="p">;</span><span class="n">p</span><span class="o">++</span><span class="p">)</span>
               <span class="n">MPI_Send</span><span class="p">(</span><span class="n">Matrix_B</span><span class="o">+</span><span class="p">(</span><span class="n">begin_part</span><span class="o">+</span><span class="n">p</span><span class="p">)</span><span class="o">*</span><span class="n">K</span><span class="o">+</span><span class="n">beginCol</span><span class="p">,</span><span class="n">each_K</span><span class="p">,</span><span class="n">MPI_DOUBLE</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">p</span><span class="o">+</span><span class="n">each_M</span><span class="p">,</span><span class="n">MPI_COMM_WORLD</span><span class="p">);</span>
         <span class="p">}</span>
      <span class="p">}</span>
      <span class="c1">// 接收从进程的计算结果</span>
      <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">comm_sz</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
         <span class="kt">int</span> <span class="n">beginRow</span><span class="o">=</span><span class="p">(</span><span class="n">i</span><span class="o">/</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="n">each_M</span><span class="p">;</span>
         <span class="kt">int</span> <span class="n">endRow</span><span class="o">=</span><span class="n">beginRow</span><span class="o">+</span><span class="n">each_M</span><span class="p">;</span>
         <span class="kt">int</span> <span class="n">beginCol</span><span class="o">=</span><span class="p">(</span><span class="n">i</span><span class="o">%</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="n">each_K</span><span class="p">;</span>
         <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">beginRow</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">endRow</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span>
            <span class="n">MPI_Recv</span><span class="p">(</span><span class="n">result_Matrix</span><span class="o">+</span><span class="n">j</span><span class="o">*</span><span class="n">K</span><span class="o">+</span><span class="n">beginCol</span><span class="p">,</span><span class="n">each_K</span><span class="p">,</span><span class="n">MPI_DOUBLE</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">-</span><span class="n">beginRow</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">each_M</span><span class="o">+</span><span class="n">each_N</span><span class="p">,</span><span class="n">MPI_COMM_WORLD</span><span class="p">,</span><span class="o">&amp;</span><span class="n">status</span><span class="p">);</span>
      <span class="p">}</span>
 
      <span class="n">Matrix_print2</span><span class="p">(</span><span class="n">result_Matrix</span><span class="p">,</span><span class="n">saveM</span><span class="p">,</span><span class="n">saveK</span><span class="p">,</span><span class="n">K</span><span class="p">);</span>
      <span class="n">stop</span><span class="o">=</span><span class="n">MPI_Wtime</span><span class="p">();</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">"rank:%d time:%lfs</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">rank</span><span class="p">,</span><span class="n">stop</span><span class="o">-</span><span class="n">start</span><span class="p">);</span>
 
      <span class="n">free</span><span class="p">(</span><span class="n">Matrix_A</span><span class="p">);</span>
      <span class="n">free</span><span class="p">(</span><span class="n">Matrix_B</span><span class="p">);</span>
      <span class="n">free</span><span class="p">(</span><span class="n">Matrix_C</span><span class="p">);</span>
      <span class="n">free</span><span class="p">(</span><span class="n">result_Matrix</span><span class="p">);</span>
   <span class="p">}</span>
   <span class="k">else</span> <span class="p">{</span>
      <span class="kt">double</span> <span class="o">*</span><span class="n">buffer_A</span><span class="p">,</span><span class="o">*</span><span class="n">buffer_B</span><span class="p">,</span><span class="o">*</span><span class="n">buffer_C</span><span class="p">;</span>
      <span class="n">buffer_A</span><span class="o">=</span><span class="p">(</span><span class="kt">double</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">each_M</span><span class="o">*</span><span class="n">each_N</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">));</span> <span class="c1">// A的均分行的数据</span>
      <span class="n">buffer_B</span><span class="o">=</span><span class="p">(</span><span class="kt">double</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">each_N</span><span class="o">*</span><span class="n">each_K</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">));</span> <span class="c1">// B的均分列的数据</span>
      <span class="n">buffer_C</span><span class="o">=</span><span class="p">(</span><span class="kt">double</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">each_M</span><span class="o">*</span><span class="n">each_K</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">));</span> <span class="c1">// C的均分行的数据</span>
 
      <span class="c1">// 接收C块数据</span>
      <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">each_M</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span>
         <span class="n">MPI_Recv</span><span class="p">(</span><span class="n">buffer_C</span><span class="o">+</span><span class="n">j</span><span class="o">*</span><span class="n">each_K</span><span class="p">,</span><span class="n">each_K</span><span class="p">,</span><span class="n">MPI_DOUBLE</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="n">each_M</span><span class="o">+</span><span class="n">each_N</span><span class="p">,</span><span class="n">MPI_COMM_WORLD</span><span class="p">,</span><span class="o">&amp;</span><span class="n">status</span><span class="p">);</span>
 
      <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">k</span><span class="o">&lt;</span><span class="n">a</span><span class="p">;</span><span class="n">k</span><span class="o">++</span><span class="p">){</span> <span class="c1">// 把每块数据求和</span>
         <span class="c1">//接收A B块数据</span>
         <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">each_M</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span>
            <span class="n">MPI_Recv</span><span class="p">(</span><span class="n">buffer_A</span><span class="o">+</span><span class="n">j</span><span class="o">*</span><span class="n">each_N</span><span class="p">,</span><span class="n">each_N</span><span class="p">,</span><span class="n">MPI_DOUBLE</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">MPI_COMM_WORLD</span><span class="p">,</span><span class="o">&amp;</span><span class="n">status</span><span class="p">);</span>
         <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">p</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">p</span><span class="o">&lt;</span><span class="n">each_N</span><span class="p">;</span><span class="n">p</span><span class="o">++</span><span class="p">)</span>
            <span class="n">MPI_Recv</span><span class="p">(</span><span class="n">buffer_B</span><span class="o">+</span><span class="n">p</span><span class="o">*</span><span class="n">each_K</span><span class="p">,</span><span class="n">each_K</span><span class="p">,</span><span class="n">MPI_DOUBLE</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">p</span><span class="o">+</span><span class="n">each_M</span><span class="p">,</span><span class="n">MPI_COMM_WORLD</span><span class="p">,</span><span class="o">&amp;</span><span class="n">status</span><span class="p">);</span>
 
         <span class="c1">//计算乘积结果,并将结果发送给主进程</span>
         <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">each_M</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">each_K</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">){</span>
               <span class="kt">double</span> <span class="n">temp</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
               <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">p</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">p</span><span class="o">&lt;</span><span class="n">each_N</span><span class="p">;</span><span class="n">p</span><span class="o">++</span><span class="p">){</span>
                  <span class="n">temp</span><span class="o">+=</span><span class="n">buffer_A</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="n">each_N</span><span class="o">+</span><span class="n">p</span><span class="p">]</span><span class="o">*</span><span class="n">buffer_B</span><span class="p">[</span><span class="n">p</span><span class="o">*</span><span class="n">each_K</span><span class="o">+</span><span class="n">j</span><span class="p">];</span>
               <span class="p">}</span>
               <span class="k">if</span><span class="p">(</span><span class="n">k</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>
                  <span class="n">buffer_C</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="n">each_K</span><span class="o">+</span><span class="n">j</span><span class="p">]</span><span class="o">=</span> <span class="n">temp</span><span class="o">+</span> <span class="n">buffer_C</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="n">each_K</span><span class="o">+</span><span class="n">j</span><span class="p">];</span>
               <span class="k">else</span>
                  <span class="n">buffer_C</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="n">each_K</span><span class="o">+</span><span class="n">j</span><span class="p">]</span><span class="o">+=</span> <span class="n">temp</span><span class="p">;</span>
            <span class="p">}</span>
         <span class="p">}</span>
      <span class="p">}</span>
      <span class="c1">// 将结果发送给主进程</span>
      <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">each_M</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">){</span>
         <span class="n">MPI_Send</span><span class="p">(</span><span class="n">buffer_C</span><span class="o">+</span><span class="n">j</span><span class="o">*</span><span class="n">each_K</span><span class="p">,</span><span class="n">each_K</span><span class="p">,</span><span class="n">MPI_DOUBLE</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">each_M</span><span class="o">+</span><span class="n">each_N</span><span class="p">,</span><span class="n">MPI_COMM_WORLD</span><span class="p">);</span>
      <span class="p">}</span>
 
      <span class="n">free</span><span class="p">(</span><span class="n">buffer_A</span><span class="p">);</span>
      <span class="n">free</span><span class="p">(</span><span class="n">buffer_B</span><span class="p">);</span>
      <span class="n">free</span><span class="p">(</span><span class="n">buffer_C</span><span class="p">);</span>
   <span class="p">}</span>
   <span class="n">MPI_Finalize</span><span class="p">();</span>
   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h5 id="由于进程有独立的内存空间维护进程空间需要消耗一定资源其次由于内存互不重叠进程之间的消息必须显式地传递和接收相较于单一机器使用mpi更适合计算机集群中使用">   由于进程有独立的内存空间，维护进程空间需要消耗一定资源。其次，由于内存互不重叠，进程之间的消息必须显式地传递和接收。相较于单一机器使用，MPI更适合计算机集群中使用。</h5> <h3 id="线程级别并行">线程级别并行</h3> <h5 id="在上述分布式并行中提及了由于基于消息传递优化的卡农算法而对于单一机器多核处理器来说实际上没有必要将计算单元的数据相互隔离对应地也就是没有必要为每个运算单元维护进程在一个进程中使用多个线程即可由于线程间共享内存也就避免了复杂地消息传播">   在上述分布式并行中，提及了由于基于消息传递优化的卡农算法，而对于单一机器多核处理器来说，实际上没有必要将计算单元的数据相互隔离。对应地，也就是没有必要为每个运算单元维护进程，在一个进程中使用多个线程即可，由于线程间共享内存，也就避免了复杂地消息传播.</h5> <h4 id="共享内存并行">共享内存并行</h4> <h5 id="基于上述的理念提出了基于多线程的共享内存并行具体到编程时可以使用手动管理posix线程-也可以使用openmpopen-multiple-processing-添加预编译命令完成">   基于上述的理念，提出了基于多线程的共享内存并行。具体到编程时，可以使用<pthread.h>手动管理POSIX线程, 也可以使用OpenMP(Open Multiple processing), 添加预编译命令完成</pthread.h> </h5> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;cstring&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;omp.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;time.h&gt;</span><span class="cp">
</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="mi">64</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">NormalMul</span><span class="p">[</span><span class="n">N</span><span class="p">][</span><span class="n">N</span><span class="p">];</span>
<span class="kt">float</span> <span class="n">MPMul</span><span class="p">[</span><span class="n">N</span><span class="p">][</span><span class="n">N</span><span class="p">];</span>

<span class="kt">void</span> <span class="nf">check</span><span class="p">(){</span>
    <span class="c1">// 检查使用，输出前16个元素并对比</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">NormalMul</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="sc">' '</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">MPMul</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="sc">' '</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

<span class="p">}</span>

<span class="kt">void</span> <span class="nf">MulNormal</span><span class="p">(</span><span class="kt">float</span> <span class="o">**</span><span class="n">A</span><span class="p">,</span> <span class="kt">float</span> <span class="o">**</span><span class="n">B</span><span class="p">){</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">){</span>
            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span><span class="p">){</span>
                <span class="n">NormalMul</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">B</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">MulMP</span><span class="p">(</span><span class="kt">float</span> <span class="o">**</span><span class="n">A</span><span class="p">,</span> <span class="kt">float</span> <span class="o">**</span><span class="n">B</span><span class="p">){</span>
    <span class="c1">// 在此处添加预编译命令</span>
    <span class="cp">#pragma omp parallel for num_threads(4) schedule(dynamic)
</span>    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">){</span>
            <span class="kt">float</span> <span class="n">temp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span><span class="p">){</span>
                <span class="n">temp</span> <span class="o">+=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">B</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
            <span class="p">}</span>
            <span class="n">MPMul</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kt">float</span><span class="o">**</span> <span class="nf">randMatrix</span><span class="p">(){</span>
    <span class="n">srand</span><span class="p">(</span><span class="n">static_cast</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">time</span><span class="p">(</span><span class="n">nullptr</span><span class="p">)));</span>
    <span class="kt">float</span> <span class="o">**</span><span class="n">Matrix</span> <span class="o">=</span> <span class="p">(</span><span class="kt">float</span><span class="o">**</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">N</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="p">));</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="n">Matrix</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span> <span class="o">*</span> <span class="n">N</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">){</span>
            <span class="n">Matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">static_cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">rand</span><span class="p">())</span> <span class="o">/</span> <span class="n">static_cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">RAND_MAX</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">Matrix</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>

    <span class="kt">float</span> <span class="o">**</span><span class="n">A</span> <span class="o">=</span> <span class="n">randMatrix</span><span class="p">();</span>
    <span class="kt">float</span> <span class="o">**</span><span class="n">B</span> <span class="o">=</span> <span class="n">randMatrix</span><span class="p">();</span>
    <span class="c1">// 分别计算并计时</span>
    <span class="kt">clock_t</span> <span class="n">normal_beg</span> <span class="o">=</span> <span class="n">clock</span><span class="p">();</span>
    <span class="n">MulNormal</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">);</span>
    <span class="kt">clock_t</span> <span class="n">normal_end</span> <span class="o">=</span> <span class="n">clock</span><span class="p">();</span>

    <span class="kt">clock_t</span> <span class="n">MP_beg</span> <span class="o">=</span> <span class="n">clock</span><span class="p">();</span>
    <span class="n">MulMP</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">);</span>
    <span class="kt">clock_t</span> <span class="n">MP_end</span> <span class="o">=</span> <span class="n">clock</span><span class="p">();</span>
    <span class="c1">// 输出</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">"normal: "</span><span class="o">&lt;&lt;</span><span class="n">normal_end</span> <span class="o">-</span> <span class="n">normal_beg</span><span class="o">&lt;&lt;</span><span class="s">" ms"</span><span class="o">&lt;&lt;</span><span class="sc">'\n'</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">"MP:     "</span><span class="o">&lt;&lt;</span><span class="n">MP_end</span> <span class="o">-</span> <span class="n">MP_beg</span><span class="o">&lt;&lt;</span><span class="s">" ms"</span><span class="o">&lt;&lt;</span><span class="sc">'\n'</span><span class="p">;</span>
    <span class="n">check</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h5 id="输出结果以及对比">   输出结果以及对比</h5> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>normal: 1097 ms
MP:     454 ms
13.9073 16.8046 14.3195 17.28 13.1921 15.0843 15.269 16.6484 15.771 15.2247 14.5149 13.783 12.2384 14.3623 15.2282 15.4888 
13.9073 16.8046 14.3195 17.28 13.1921 15.0843 15.269 16.6484 15.771 15.2247 14.5149 13.783 12.2384 14.3623 15.2282 15.4888
</code></pre></div></div> <h5 id="示例中使用了简单的pragma预处理指令并行最外层的循环设置线程为4在矩阵大小为6464是取得了较好的效果然而如果进一步增大矩阵大小可能出现cache命中率下降线程之间错误共享综合时间反而不如串行的现象此时需要手动对线程进一步细化管理例如schedulemode-size-critical等预处理指令其次如果增加线程数量num_threads会导致维护线程的开支增大以及线程之间的资源竞争所以需要对线程数量进行权衡">   示例中使用了简单的<code class="language-plaintext highlighter-rouge">#pragma</code>预处理指令并行最外层的循环，设置线程为4，在矩阵大小为64*64是取得了较好的效果<br>   然而，如果进一步增大矩阵大小，可能出现cache命中率下降，线程之间’错误共享’，综合时间反而不如串行的现象。此时，需要手动对线程进一步细化管理，例如<code class="language-plaintext highlighter-rouge">schedule(mode, size), critical</code>等预处理指令<br>   其次，如果增加线程数量(num_threads)，会导致维护线程的开支增大，以及线程之间的资源竞争，所以需要对线程数量进行权衡.</h5> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># thread_num = 16;</span>
normal: 805 ms
MP:     194067 ms
17.8174 17.7196 16.8649 16.4366 19.456 16.0795 17.8538 17.5493 17.6787 16.7344 15.528 15.5007 12.8625 17.4086 17.7185 16.5289 
17.8174 17.7196 16.8649 16.4366 19.456 16.0795 17.8538 17.5493 17.6787 16.7344 15.528 15.5007 12.8625 17.4086 17.7185 16.5289
</code></pre></div></div> <h3 id="数据级别并行">数据级别并行</h3> <h5 id="数据级并行是一种显式并行技术主要通过单指令多数据single-instruction-multiple-data-simd的方式实现在simd模型中一条指令可以同时对多个数据进行相同的操作这种并行性特别适用于处理大量相同类型的数据集如图像处理音频处理科学计算中的向量和矩阵运算等在x86汇编中有很多的拓展指令集能够实现simd-例如mmxsseavx-这些指令集通过将单一数据组合并放入拓展的寄存器中如xmm系列寄存器配合专用的拓展指令完成数据级别的并行和快速计算以浮点数的加法为例使用sse拓展指令拓展指令可以使用gccg自带的库进行连接也可以在代码中直接插入内联汇编指令下面的示例代码采用前者的方法">   数据级并行是一种显式并行技术，主要通过单指令多数据（Single Instruction, Multiple Data, SIMD）的方式实现。在SIMD模型中，一条指令可以同时对多个数据进行相同的操作。这种并行性特别适用于处理大量相同类型的数据集，如图像处理、音频处理、科学计算中的向量和矩阵运算等<br>   在X86汇编中，有很多的拓展指令集能够实现SIMD, 例如MMX、SSE、AVX, 这些指令集通过将单一数据组合并放入拓展的寄存器中(如xmm系列寄存器)，配合专用的拓展指令，完成数据级别的并行和快速计算。<br>   以浮点数的加法为例，使用SSE拓展指令。拓展指令可以使用gcc/g++自带的库进行连接，也可以在代码中直接插入内联汇编指令，下面的示例代码采用前者的方法.</h5> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;pmmintrin.h&gt;</span><span class="c1"> </span><span class="cp">
#include</span> <span class="cpf">&lt;ctime&gt;</span><span class="cp">
</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="mi">64</span><span class="p">;</span>

<span class="kt">float</span> <span class="n">NormalMul</span><span class="p">[</span><span class="n">N</span><span class="p">][</span><span class="n">N</span><span class="p">];</span>
<span class="kt">float</span> <span class="n">SSEMul</span><span class="p">[</span><span class="n">N</span><span class="p">][</span><span class="n">N</span><span class="p">];</span>

<span class="kt">void</span> <span class="nf">check</span><span class="p">(){</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">NormalMul</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="sc">' '</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">SSEMul</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="sc">' '</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

<span class="p">}</span>
<span class="c1">// 矩阵数据随即处理</span>
<span class="kt">float</span><span class="o">**</span> <span class="nf">randMatrix</span><span class="p">(){</span>
    <span class="n">srand</span><span class="p">(</span><span class="n">static_cast</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">time</span><span class="p">(</span><span class="n">nullptr</span><span class="p">)));</span>
    <span class="kt">float</span> <span class="o">**</span><span class="n">Matrix</span> <span class="o">=</span> <span class="p">(</span><span class="kt">float</span><span class="o">**</span><span class="p">)</span><span class="n">_mm_malloc</span><span class="p">(</span><span class="n">N</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="p">),</span> <span class="mi">16</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="n">Matrix</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="p">)</span><span class="n">_mm_malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span> <span class="o">*</span> <span class="n">N</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">){</span>
            <span class="n">Matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">static_cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">rand</span><span class="p">())</span> <span class="o">/</span> <span class="n">static_cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">RAND_MAX</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">Matrix</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">MulNormal</span><span class="p">(</span><span class="kt">float</span> <span class="o">**</span><span class="n">A</span><span class="p">,</span> <span class="kt">float</span> <span class="o">**</span><span class="n">B</span><span class="p">){</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">){</span>
            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span><span class="p">){</span>
                <span class="n">NormalMul</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">B</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">];</span> <span class="c1">// &lt;---- 计算方式与SSE方法保持一致</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">MulSSE</span><span class="p">(</span><span class="kt">float</span> <span class="o">**</span><span class="n">A</span><span class="p">,</span> <span class="kt">float</span> <span class="o">**</span><span class="n">B</span><span class="p">){</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">){</span>
            <span class="n">__m128</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">_mm_setzero_ps</span><span class="p">();</span> <span class="c1">// 初始化一个空的xmm寄存器</span>
            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">k</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">){</span>
                <span class="n">temp</span> <span class="o">=</span> <span class="n">_mm_add_ps</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> 
                <span class="n">_mm_mul_ps</span><span class="p">(</span><span class="n">_mm_load_ps</span><span class="p">(</span><span class="o">&amp;</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]),</span> 
                <span class="n">_mm_load_ps</span><span class="p">(</span><span class="o">&amp;</span><span class="n">B</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">])));</span>
            <span class="p">}</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">_mm_hadd_ps</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">temp</span><span class="p">);</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">_mm_hadd_ps</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">temp</span><span class="p">);</span>
            <span class="n">_mm_store_ss</span><span class="p">(</span><span class="o">&amp;</span><span class="n">SSEMul</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">],</span> <span class="n">temp</span><span class="p">);</span> <span class="c1">// 两次水平加法，获取一个xmm寄存器中的4个float数据的加和</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="kt">float</span> <span class="o">**</span><span class="n">A</span> <span class="o">=</span> <span class="n">randMatrix</span><span class="p">();</span>
    <span class="kt">float</span> <span class="o">**</span><span class="n">B</span> <span class="o">=</span> <span class="n">randMatrix</span><span class="p">();</span>
    
    <span class="kt">clock_t</span> <span class="n">normal_beg</span> <span class="o">=</span> <span class="n">clock</span><span class="p">();</span>
    <span class="n">MulNormal</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">);</span>
    <span class="kt">clock_t</span> <span class="n">normal_end</span> <span class="o">=</span> <span class="n">clock</span><span class="p">();</span>

    <span class="kt">clock_t</span> <span class="n">SSE_beg</span> <span class="o">=</span> <span class="n">clock</span><span class="p">();</span>
    <span class="n">MulSSE</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">);</span>
    <span class="kt">clock_t</span> <span class="n">SSE_end</span> <span class="o">=</span> <span class="n">clock</span><span class="p">();</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">"normal: "</span><span class="o">&lt;&lt;</span><span class="n">normal_end</span> <span class="o">-</span> <span class="n">normal_beg</span><span class="o">&lt;&lt;</span><span class="s">" ms"</span><span class="o">&lt;&lt;</span><span class="sc">'\n'</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">"SSE:    "</span><span class="o">&lt;&lt;</span><span class="n">SSE_end</span> <span class="o">-</span> <span class="n">SSE_beg</span><span class="o">&lt;&lt;</span><span class="s">" ms"</span><span class="o">&lt;&lt;</span><span class="sc">'\n'</span><span class="p">;</span>
    <span class="n">check</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// g++ -msse3 SSE.cpp -o SSE</span>
</code></pre></div></div> <h5 id="结果输出">   结果输出</h5> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># const int N = 64;</span>
normal: 1113 ms
SSE:    373 ms
22.9132 14.8315 16.3082 15.3699 18.9539 17.6561 20.4305 17.9889 15.3361 15.531 15.0805 18.0234 16.0815 15.5114 15.6305 18.4012 
22.9132 14.8315 16.3082 15.3699 18.9539 17.6561 20.4305 17.9889 15.3361 15.531 15.0805 18.0234 16.0815 15.5114 15.6305 18.4012 
</code></pre></div></div> <h5 id="使用sse指令有许多细节需要考虑这是由于_mm_add_ps等接口并非函数而是打包的汇编指令使用时有诸多限制">   使用SSE指令有许多细节需要考虑，这是由于<code class="language-plaintext highlighter-rouge">_mm_add_ps</code>等接口，并非函数而是打包的汇编指令，使用时有诸多限制<br> </h5> <h5 id="编译过程中不存在类型检查和对齐检查所以在编写中需要手动确认变量内存的大小和对齐以避免出现由于不当地使用汇编指令造成的内存溢出甚至是段错误下面是源代码的二进制文件中的一段截取对应的是_mm_setzero_ps的工作">   编译过程中不存在类型检查和对齐检查，所以在编写中需要手动确认变量内存的大小和对齐，以避免出现由于不当地使用汇编指令造成的内存溢出甚至是段错误。<br>   下面是源代码的二进制文件中的一段截取，对应的是<code class="language-plaintext highlighter-rouge">_mm_setzero_ps</code>的工作。</h5> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>.text:0000000000001231                 mov     rax, <span class="o">[</span>rbp+var_68]
.text:0000000000001235                 movups  xmm0, xmmword ptr <span class="o">[</span>rax]
.text:0000000000001238                 movaps  <span class="o">[</span>rbp+var_60], xmm0
.text:000000000000123C                 mov     eax, <span class="o">[</span>rbp+var_7C]
</code></pre></div></div> <h5 id="其次sse指令中的movups和movaps要求的是连续的一块16bit内存所以需要对矩阵运算做一些改造考虑如下代码是cpu串行计算时最内层的计算方式注意其中的bkj在依次遍历k的过程中bkjbk1jbk2j的内存不连续-无法通过指令直接加载进入xmm寄存器">   其次，SSE指令中的<code class="language-plaintext highlighter-rouge">movups和movaps</code>要求的是连续的一块16bit内存，所以，需要对矩阵运算做一些改造<br>   考虑如下代码，是cpu串行计算时，最内层的计算方式。注意其中的<code class="language-plaintext highlighter-rouge">B[k][j]</code>，在依次遍历<code class="language-plaintext highlighter-rouge">k</code>的过程中，<code class="language-plaintext highlighter-rouge">B[k][j]、B[k+1][j]、B[k+2][j]</code>的内存不连续, 无法通过指令直接加载进入xmm寄存器</h5> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span><span class="p">){</span>
    <span class="n">NormalMul</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">B</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div></div> <h5 id="将矩阵b从-行x列-的格式转化为-列x行-的格式如下">   将矩阵B从 行x列 的格式，转化为 列x行 的格式，如下</h5> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span><span class="p">){</span>
    <span class="n">NormalMul</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">B</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div></div> <h5 id="此时遍历过程中两个操作数就都是连续的内存">   此时，遍历过程中两个操作数就都是连续的内存</h5> <h3 id="gpu并行计算">GPU并行计算</h3> <h5 id="gpu拥有大量的计算核心擅长于计算与图形相关的各种矩阵运算大规模数据的简单处理当单机的运算资源不足是可以将部分运算分配给gpu-利用gpu进行并行运算以nvidia的独显为例使用配套的cuda工具链中的nvcc编译器编写一个2维矩阵的乘法运算源代码中使用__host__和__device__关键字来区分分配给cpu或者是gpu的工作对于gpu的函数还需提前设置网格grid和线程块block">   GPU拥有大量的计算核心，擅长于计算与图形相关的各种矩阵运算(大规模数据的简单处理)。当单机的运算资源不足是，可以将部分运算分配给GPU, 利用GPU进行并行运算.<br>   以Nvidia的独显为例，使用配套的CUDA工具链中的nvcc编译器，编写一个2维矩阵的乘法运算<br>   源代码中，使用<code class="language-plaintext highlighter-rouge">__host__</code>和<code class="language-plaintext highlighter-rouge">__device__</code>关键字来区分分配给CPU或者是GPU的工作，对于GPU的函数，还需提前设置网格(grid)和线程块(block)<br> </h5> <h5 id="很久之前的写的代码拿出来水一下">   很久之前的写的代码拿出来水一下</h5> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">"utils.cuh"</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;ctime&gt;</span><span class="cp">
</span><span class="n">using</span> <span class="n">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">const</span> <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">Matrix_CPU_A</span><span class="p">[</span><span class="n">N</span><span class="p">][</span><span class="n">N</span><span class="p">],</span> <span class="n">Matrix_CPU_B</span><span class="p">[</span><span class="n">N</span><span class="p">][</span><span class="n">N</span><span class="p">],</span> <span class="n">Matrix_CPU_C</span><span class="p">[</span><span class="n">N</span><span class="p">][</span><span class="n">N</span><span class="p">];</span>
<span class="kt">float</span> <span class="o">**</span><span class="n">Matrix_GPU_A</span><span class="p">,</span><span class="o">**</span><span class="n">Matrix_GPU_B</span><span class="p">,</span><span class="o">**</span><span class="n">Matrix_GPU_C</span><span class="p">;</span>

<span class="n">__host__</span> <span class="kt">void</span> <span class="nf">randomMatrix</span><span class="p">(</span><span class="kt">float</span> <span class="n">matrix</span><span class="p">[</span><span class="n">N</span><span class="p">][</span><span class="n">N</span><span class="p">]){</span>
    <span class="n">srand</span><span class="p">(</span><span class="n">static_cast</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">time</span><span class="p">(</span><span class="n">nullptr</span><span class="p">)));</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">){</span>
            <span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">static_cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">rand</span><span class="p">())</span> <span class="o">/</span> <span class="n">static_cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">RAND_MAX</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">__host__</span> <span class="kt">void</span> <span class="nf">CPUMul</span><span class="p">(){</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">){</span>
            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span><span class="p">){</span>
                <span class="n">Matrix_CPU_C</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">Matrix_CPU_A</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">Matrix_CPU_B</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="n">__host__</span> <span class="kt">void</span> <span class="nf">check</span><span class="p">(</span><span class="kt">float</span> <span class="n">matrix</span><span class="p">[</span><span class="n">N</span><span class="p">][</span><span class="n">N</span><span class="p">]){</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
        <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="sc">' '</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">__device__</span> <span class="kt">float</span> <span class="nf">GPUMulAtom</span><span class="p">(</span><span class="kt">float</span> <span class="n">a</span><span class="p">,</span> <span class="kt">float</span> <span class="n">b</span><span class="p">){</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">__global__</span> <span class="kt">void</span> <span class="nf">GPUMul</span><span class="p">(</span><span class="kt">float</span> <span class="o">**</span><span class="n">A</span><span class="p">,</span> <span class="kt">float</span> <span class="o">**</span><span class="n">B</span><span class="p">,</span> <span class="kt">float</span> <span class="o">**</span><span class="n">C</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">col</span> <span class="o">=</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">range</span> <span class="o">=</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
    <span class="n">C</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">GPUMulAtom</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">range</span><span class="p">],</span> <span class="n">B</span><span class="p">[</span><span class="n">range</span><span class="p">][</span><span class="n">col</span><span class="p">]);</span>
<span class="p">}</span>
<span class="n">__global__</span> <span class="kt">void</span> <span class="nf">GPUCheck</span><span class="p">(</span><span class="kt">float</span> <span class="o">**</span><span class="n">matrix</span><span class="p">){</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%f "</span><span class="p">,</span> <span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">randomMatrix</span><span class="p">(</span><span class="n">Matrix_CPU_A</span><span class="p">);</span>
    <span class="n">randomMatrix</span><span class="p">(</span><span class="n">Matrix_CPU_B</span><span class="p">);</span>
    <span class="kt">float</span> <span class="o">**</span><span class="n">Matrix_GPU_A</span><span class="p">,</span><span class="o">**</span><span class="n">Matrix_GPU_B</span><span class="p">,</span><span class="o">**</span><span class="n">Matrix_GPU_C</span><span class="p">;</span>

    <span class="n">cudaMalloc</span><span class="p">((</span><span class="kt">float</span><span class="o">***</span><span class="p">)</span><span class="o">&amp;</span><span class="n">Matrix_GPU_A</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="o">*</span> <span class="n">N</span> <span class="o">*</span> <span class="n">N</span> <span class="p">);</span>
    <span class="n">cudaMalloc</span><span class="p">((</span><span class="kt">float</span><span class="o">***</span><span class="p">)</span><span class="o">&amp;</span><span class="n">Matrix_GPU_B</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="o">*</span> <span class="n">N</span> <span class="o">*</span> <span class="n">N</span> <span class="p">);</span>
    <span class="n">cudaMalloc</span><span class="p">((</span><span class="kt">float</span><span class="o">***</span><span class="p">)</span><span class="o">&amp;</span><span class="n">Matrix_GPU_C</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="o">*</span> <span class="n">N</span> <span class="o">*</span> <span class="n">N</span> <span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">Matrix_GPU_A</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">Matrix_GPU_B</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">Matrix_GPU_C</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">cudaMemset</span><span class="p">(</span><span class="n">Matrix_GPU_A</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="o">*</span> <span class="n">N</span> <span class="o">*</span> <span class="n">N</span><span class="p">);</span>
        <span class="n">cudaMemset</span><span class="p">(</span><span class="n">Matrix_GPU_B</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="o">*</span> <span class="n">N</span> <span class="o">*</span> <span class="n">N</span><span class="p">);</span>
        <span class="n">cudaMemset</span><span class="p">(</span><span class="n">Matrix_GPU_C</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="o">*</span> <span class="n">N</span> <span class="o">*</span> <span class="n">N</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">cudaFree</span><span class="p">(</span><span class="n">Matrix_GPU_A</span><span class="p">);</span>
        <span class="n">cudaFree</span><span class="p">(</span><span class="n">Matrix_GPU_B</span><span class="p">);</span>
        <span class="n">cudaFree</span><span class="p">(</span><span class="n">Matrix_GPU_C</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"cudaMalloc failed</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">cudaMemcpy</span><span class="p">(</span><span class="n">Matrix_CPU_A</span><span class="p">,</span><span class="n">Matrix_GPU_A</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="o">*</span> <span class="n">N</span><span class="o">*</span> <span class="n">N</span><span class="p">,</span><span class="n">cudaMemcpyHostToDevice</span><span class="p">);</span>
    <span class="n">cudaMemcpy</span><span class="p">(</span><span class="n">Matrix_CPU_B</span><span class="p">,</span><span class="n">Matrix_GPU_B</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="o">*</span> <span class="n">N</span><span class="o">*</span> <span class="n">N</span><span class="p">,</span><span class="n">cudaMemcpyHostToDevice</span><span class="p">);</span>
    <span class="n">cudaMemcpy</span><span class="p">(</span><span class="n">Matrix_CPU_C</span><span class="p">,</span><span class="n">Matrix_GPU_C</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="o">*</span> <span class="n">N</span><span class="o">*</span> <span class="n">N</span><span class="p">,</span><span class="n">cudaMemcpyHostToDevice</span><span class="p">);</span>

    <span class="kt">clock_t</span> <span class="n">CPU_begin</span> <span class="o">=</span> <span class="n">clock</span><span class="p">();</span>
    <span class="n">CPUMul</span><span class="p">();</span>
    <span class="kt">clock_t</span> <span class="n">CPU_end</span> <span class="o">=</span> <span class="n">clock</span><span class="p">();</span>
    <span class="c1">// check(Matrix_CPU_C);</span>
    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">"CPU: "</span><span class="o">&lt;&lt;</span><span class="n">CPU_end</span> <span class="o">-</span> <span class="n">CPU_begin</span><span class="o">&lt;&lt;</span><span class="s">" ms"</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>

    <span class="n">dim3</span> <span class="n">block</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">N</span><span class="p">);</span>
    <span class="n">dim3</span> <span class="n">grid</span><span class="p">(</span><span class="n">N</span><span class="p">);</span>
    <span class="kt">clock_t</span> <span class="n">GPU_begin</span> <span class="o">=</span> <span class="n">clock</span><span class="p">();</span>
    <span class="n">GPUMul</span><span class="o">&lt;&lt;&lt;</span><span class="n">grid</span><span class="p">,</span> <span class="n">block</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">Matrix_GPU_A</span><span class="p">,</span> <span class="n">Matrix_GPU_B</span><span class="p">,</span> <span class="n">Matrix_GPU_C</span><span class="p">);</span>
    <span class="n">cudaDeviceSynchronize</span><span class="p">();</span>
    <span class="kt">clock_t</span> <span class="n">GPU_end</span> <span class="o">=</span> <span class="n">clock</span><span class="p">();</span>
    <span class="c1">// GPUCheck(Matrix_GPU_C);</span>
    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">"GPU: "</span><span class="o">&lt;&lt;</span><span class="n">GPU_end</span> <span class="o">-</span> <span class="n">GPU_begin</span><span class="o">&lt;&lt;</span><span class="s">" ms"</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>

    <span class="n">cudaFree</span><span class="p">(</span><span class="n">Matrix_GPU_A</span><span class="p">);</span>
    <span class="n">cudaFree</span><span class="p">(</span><span class="n">Matrix_GPU_B</span><span class="p">);</span>
    <span class="n">cudaFree</span><span class="p">(</span><span class="n">Matrix_GPU_C</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># const int N = 1024;</span>
CPU: 6607223 ms
GPU: 8970 ms
<span class="c"># const int N = 2048;</span>
CPU: 182436212 ms
GPU: 22204 ms
</code></pre></div></div> <h5 id="需要注意的是由于cpu和gpu是不同的部件两者之间需要通过pcie总线通信这个过程会消耗比较多的时间相较于单步计算而言所以在计算量比较小的时候gpu并行相较于cpu串行不会有太好的效果">   需要注意的是，由于CPU和GPU是不同的部件，两者之间需要通过PCIe总线通信，这个过程会消耗比较多的时间(相较于单步计算而言)，所以在计算量比较小的时候，GPU并行相较于CPU串行不会有太好的效果.</h5> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># const int N = 64;</span>
CPU: 1178 ms
GPU: 5040 ms
</code></pre></div></div> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="https://blog.google/technology/ai/google-gemini-update-flash-ai-assistant-io-2024/" target="_blank" rel="external nofollow noopener">Google Gemini updates: Flash 1.5, Gemma 2 and Project Astra</a> <svg width="1rem" height="1rem" viewbox="0 0 30 30" xmlns="http://www.w3.org/2000/svg"> <path d="M17 13.5v6H5v-12h6m3-3h6v6m0-6-9 9" class="icon_svg-stroke" stroke="#999" stroke-width="1.5" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path> </svg> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="https://medium.com/@al-folio/displaying-external-posts-on-your-al-folio-blog-b60a1d241a0a?source=rss-17feae71c3c4------2" target="_blank" rel="external nofollow noopener">Displaying External Posts on Your al-folio Blog</a> <svg width="1rem" height="1rem" viewbox="0 0 30 30" xmlns="http://www.w3.org/2000/svg"> <path d="M17 13.5v6H5v-12h6m3-3h6v6m0-6-9 9" class="icon_svg-stroke" stroke="#999" stroke-width="1.5" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path> </svg> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/ONNX/">ONNX-opt day0</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%8F%8A%E8%B0%83%E8%AF%95/">内核模块开发环境及调试</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/C++%E6%80%8E%E4%B9%88UAF/">[水贴]C++应该怎么UAF</a> </li> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2025 Leak Box 258. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js?a0db7e5d5c70cc3252b3138b0c91dcaf" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?c8a01c11a92744d44b093fc3bda915df" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script src="/assets/js/mathjax-setup.js?a5bb4e6a542c546dd929b24b8b236dfd"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script defer src="/assets/js/progress-bar.js?2f30e0e6801ea8f5036fa66e1ab0a71a" type="text/javascript"></script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>
    addBackToTop();
  </script> <script type="module" src="/assets/js/search/ninja-keys.min.js?a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script src="/assets/js/search-setup.js?6c304f7b1992d4b60f7a07956e52f04a"></script> <script src="/assets/js/search-data.js"></script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> </body> </html>