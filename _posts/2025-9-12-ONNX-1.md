---
layout: post
title: "ONNX-opt 1"
date:   2025-9-12
tags: [dev, nn, onnx, ai-compiler]
comments: true
author: 久菜合子
---

##### ONNX-optimizer
ONNX-opt 虽然是一个很古老的 AI 优化器，但可能也有一些参考价值
ONNX-opt 使用 Pass 对模型进行优化，参见源代码`onnx-optmizer/pass.h`中的 transform pass 的基类
```c++
class Pass {
  PassType pass_type;
  PassEfficiency pass_efficiency;
  PassOptimizationType pass_optimization_type;
    ...
};

// Enum that represents the type of optimization it is.
enum PassType {
  // Class of optimizations that fuses operations.
  Fuse = 0,
  // Class of optimizations that removes useless operations.
  Nop = 1,
  // Class of optimizations that includes some form of separation.
  Separate = 2,
  // Immutable pass, also sometimes referred to as an analysis pass.
  Immutable = 3,
  // Class of optimizations that replaces nodes with other.
  Replace = 4,
  // Other type of pass.
  Other = 5
};
enum PassOptimizationType {
  // Is not optimizing anything. Most likely will be used in an immutable pass.
  None = 0,
  // Optimizes for compute.
  Compute = 1,
  // Optimizes for memory.
  Memory = 2,
  // Optimizes for both compute and memory.
  ComputeMemory = 3,
  // Optimizes for stability (e.g. log-sum-exp trick).
  Stability = 4
};
enum PassEfficiency {
  // A partially efficient optimization pass cannot guarantee that running two
  // consecutive passes
  // will return the same result as running a single pass.
  Partial = 0,
  // A completely efficient optimization guarantees that running two consecutive
  // passes is equivalent
  // to running a single pass.
  Complete = 1
};
```
transform pass 基于操作类型划分有一下几类
- `Fuse`: 进行算子合并
- `Nop`: 进行冗余消除
- `Separate`：进行算子拆分
- `Immutable`: 前后模型不变的pass，有时指代 analysis pass
- `Replace`: 对计算图节点进行替换
- `Other`: 其他
基于pass的效果划分有一下几类
- `None`: 无
- `Compute`: 改善计算
- `Memory`: 改善访存
- `ComputeMemory`: ...
- `Stability`: 提高稳定性
最后，一个pass的效果可能是稳定的，也可能是不稳定的<br><br>
同样，还有analysis pass，定义相对简单, 依赖于上面的`Immutable` pass，一个 analysis pass 通过 `runPass` 的返回值获取分析结果，
```c++
class Pass {
    ...
    virtual std::shared_ptr<PostPassAnalysis> runPass(Graph &graph) = 0;
    ...
}

// Base struct representing result of a pass.
struct PostPassAnalysis {
  virtual ~PostPassAnalysis() = default;
};

// Enum that represents the return type of the analysis.
enum PassAnalysisType {
  // An empty analysis is returned. Most likely will return PostPassAnalysis.
  Empty = 0,
  // A count based analysis is returned. Most likely of type
  // CountBasedPassAnalysis
  CountBased = 1
};

// Pass Analysis done after a predicate based pass.
struct CountBasedPassAnalysis : PostPassAnalysis {
  Pass *pass;
  ...
  bool graphChanged();
  bool numSucceededTransforms();

    ...

  // Whether or not a repeated application of the pass might be useful.
  bool fixedPointOptimizationNeeded() {
    return this->graphChanged() &&
           pass->getPassEfficiency() == PassEfficiency::Partial;
  }
  ...
};
```
`CountBasedPassAnalysis`应该是目前ONNX-opt唯一的`PostPassAnalysis`的继承示例（empty无需继承）<br><br>
`Pass *pass` 是 `runPass` 中传入的 `this` 指针<br><br>

##### PassManager
ONNX-opt 有两类Manager可用，对应上一节提到的两种`Optimizer`, 一种是`GeneralPassManager`，另一种是`FixedPointPassManager`
```c++
class PassManager {
    ...
};

class GeneralPassManager : public PassManager {
 public:
  GeneralPassManager() {}
  ~GeneralPassManager() override;

  void add(std::shared_ptr<Pass> pass) override;
  std::shared_ptr<PassManagerAnalysis> run(Graph& graph) override;

 protected:
  std::vector<std::shared_ptr<Pass>> passes;
};

class FixedPointPassManager : public GeneralPassManager {
  std::shared_ptr<PassManagerAnalysis> run(Graph& graph) override;
};
```
没有任何理解上的难度，下面是如何实现这么一个 fix point：
```c++
std::shared_ptr<PassManagerAnalysis> FixedPointPassManager::run(Graph& graph) {
  bool fixed_point_optimization_done;

  do {
    fixed_point_optimization_done = false;
    for (const std::shared_ptr<Pass>& pass : this->passes) {
      std::shared_ptr<PostPassAnalysis> analysis = pass->runPass(graph);
      if (pass->getPassAnalysisType() == PassAnalysisType::Empty) {
        continue;
      }
      std::shared_ptr<CountBasedPassAnalysis> count_analysis =
          std::static_pointer_cast<CountBasedPassAnalysis>(analysis);

      while (count_analysis->fixedPointOptimizationNeeded()) {
        count_analysis = std::static_pointer_cast<CountBasedPassAnalysis>(
            pass->runPass(graph));
        fixed_point_optimization_done = true;
      }
    }
  } while (fixed_point_optimization_done);

  return std::shared_ptr<PassManagerAnalysis>(new EmptyPassManagerAnalysis());
}
```
也是非常简单，当`runPass`返回的 analysis 结果不为空时，调用`fixedPointOptimizationNeeded`检查是否可以进行不动点迭代，然后一直迭代到没有不同点为止<br><br>
##### 两类 transform pass
###### PredicateBasedPass
基于计算图上匹配字图的 transform pass，有两个关键方法`patternMatchPredicate`和`runTransform`, 在实际进行pass之前，先使用前者匹配字图, 如果匹配到则调用后者进行转换，这个流程在 `runPass -> _runPassInternal` 执行。ONNX-opt 的大部分的 pass 都是这种类型
```c++
class PredicateBasedPass : public Pass {
 public:
  explicit PredicateBasedPass(PassType pass_type,
                              PassEfficiency pass_efficiency,
                              PassOptimizationType pass_optimization_type)
      : Pass(pass_type, pass_efficiency, pass_optimization_type) {}
  ~PredicateBasedPass() override;

  virtual bool patternMatchPredicate(Node *node) = 0;
  virtual bool runTransform(Node *node, Graph &graph,
                            NodeDestroyType &destroy_current) = 0;

  std::shared_ptr<PostPassAnalysis> runPass(Graph &graph) override;
  PassAnalysisType getPassAnalysisType() const override;

  static int getOpsetVersion(const Graph &g) {
  Graph &mut_g = const_cast<Graph &>(g);
    for (const OpSetID &opset : mut_g.opset_versions_mutable()) {
      if (opset.domain() == "") {
        return opset.version();
      }
    }
    return 0;
  }

 private:
  unsigned int _runPassInternal(Graph &graph);
};
```
这里比较重要的是 `runTransform` 是如何修改图的，这个需要之后对 ONNX 的 `IR, Node, Graph` 等内容进行分析<br><br>
###### FullGraphBasedPass
在整个图上的优化:
```c++
// The most general pass which allows the user to run a pass given only a graph.
class FullGraphBasedPass : public Pass {
 public:
  explicit FullGraphBasedPass(PassType pass_type,
                              PassEfficiency pass_efficiency,
                              PassOptimizationType pass_optimization_type)
      : Pass(pass_type, pass_efficiency, pass_optimization_type) {}
  ~FullGraphBasedPass() override;
};
```
举个例子，`eliminate_deadend.h`, 大致就是在整个计算图上，根据use关系，找到 unreachable node 并删除的优化
```c++
unsigned int EliminateDead(Graph& graph) {
unsigned int nodes_removed = 0;
auto nodes = graph.nodes().reverse();
for (auto it = nodes.begin(); it != nodes.end(); it++) {
    auto node = *it;
    if (!node->hasUses()) {
    nodes_removed++;
    it.destroyCurrent();
    }
}
return nodes_removed;
}
```
可以看到，`nodes` 是整个图中节点的拓扑排序<br><br>